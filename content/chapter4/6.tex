As introduced, concepts can be used as type constraints. There are different places where type constraints can be used:

\begin{itemize}
\item
In the declaration of a template type parameter

\item
In the declaration of a call parameter declared with auto

\item
As a requirement in a compound requirement
\end{itemize}

For example:

\begin{cpp}
template<std::integral T> // type constraint for a template parameter
class MyClass {
	...
};

auto myFunc(const std::integral auto& val) { // type constraint for an auto parameter
	...
};

template<typename T>
concept MyConcept = requires(T x) {
		{ x + x } -> std::integral; // type constraint for return type
	};
\end{cpp}

Here, we use unary constraints that are called for a single parameter or type returned by an expression.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Type Constraints with Multiple Parameters}

You can also use constraints with multiple parameters, for which the parameter type or return value is then used as the first argument:

\begin{cpp}
template<std::convertible_to<int> T> // conversion to int required
class MyClass {
	...
};

auto myFunc(const std::convertible_to<int> auto& val) { // conversion to int required
	...
};

template<typename T>
concept MyConcept = requires(T x) {
		{ x + x } -> std::convertible_to<int>; // conversion to int required
	};
\end{cpp}

Another example often used is to constrain the type of a callable (function, function object, lambda) to require that you can pass a certain number of arguments of certain types using the concepts std::invocable or std::regular\_invocable: for example, to require the passing of an operation that takes an int and a std::string, you have to declare:

\begin{cpp}
template<std::invocable<int, std::string> Callable>
void call(Callable op);
\end{cpp}

or:

\begin{cpp}
void call(std::invocable<int, std::string> auto op);
\end{cpp}

The difference between std::invocable and std::regular\_invocable is that the latter guarantees not to modify the passed operation and arguments. That is a semantic difference that helps only to document the intention. Often, just std::invocable is used.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Type Constraints and auto}

Type constraints can be used in all places where auto can be used. The major application of this feature is to use the type constraints for the function parameters declared with auto. For example:

\begin{cpp}
void foo(const std::integral auto& val)
{
	...
}
\end{cpp}

However, you can also use type constraint for auto as follows:

\begin{itemize}
\item
To constrain declarations:

\begin{cpp}
std::floating_point auto val1 = f(); // valid if f() yields floating-point value

for (const std::integral auto& elem : coll) { // valid if elements are integral values
	...
}
\end{cpp}

\item
To constrain return types:

\begin{cpp}
std::copyable auto foo(auto) { // valid if foo() returns copyable value
	...
}
\end{cpp}

\item
To constrain non-type template parameters:

\begin{cpp}
template<typename T, std::integral auto Max>
class SizedColl {
	...
};
\end{cpp}
\end{itemize}

This also works with concepts that take multiple parameters:

\begin{cpp}
template<typename T, std::convertible_to<T> auto DefaultValue>
class MyType {
	...
};
\end{cpp}

For another example, see the support for lambdas as non-type template parameters.












