

You can use requires clauses or concepts to constrain almost all forms of generic code:

\begin{itemize}
\item
Function templates:
\begin{cpp}
template<typename T>
requires ...
void print(const T&) {
	...
}
\end{cpp}

\item
Class templates
\begin{cpp}
template<typename T>
requires ...
class MyType {
	...
}
\end{cpp}

\item
Alias templates

\item
Variable templates

\item
You can even constrain member functions
\end{itemize}

For these templates, you can constrain both type and value parameters.

However, note that you cannot constrain concepts:

\begin{cpp}
template<std::ranges::sized_range T> // ERROR
concept IsIntegralValType = std::integral<std::ranges::range_value_t<T>>;
\end{cpp}

Instead, you have to specify this as follows:

\begin{cpp}
template<typename T>
concept IsIntegralValType = std::ranges::sized_range<T> &&
							std::integral<std::ranges::range_value_t<T>>;
\end{cpp}


\mySubsubsection{3.2.1}{Constraining Alias Templates}

Here is an example of constraining alias templates (generic using declarations):

\begin{cpp}
template<std::ranges::range T>
using ValueType = std::ranges::range_value_t<T>;
\end{cpp}

The declaration is equivalent to the following:

\begin{cpp}
template<typename T>
requires std::ranges::range<T>
using ValueType = std::ranges::range_value_t<T>;
\end{cpp}

Type ValueType<> is now defined only for types that are ranges:

\begin{cpp}
ValueType<int> vt1; // ERROR
ValueType<std::vector<int>> vt2; // int
ValueType<std::list<double>> vt3; // double
\end{cpp}

\mySubsubsection{3.2.2}{Constraining Variable Templates}

Here is an example of constraining variable templates:

\begin{cpp}
template<std::ranges::range T>
constexpr bool IsIntegralValType = std::integral<std::ranges::range_value_t<T>>;
\end{cpp}

Again, this is equivalent to the following:

\begin{cpp}
template<typename T>
requires std::ranges::range<T>
constexpr bool IsIntegralValType = std::integral<std::ranges::range_value_t<T>>;
\end{cpp}

The Boolean variable template is now defined only for ranges:

\begin{cpp}
bool b1 = IsIntegralValType<int>; // ERROR
bool b2 = IsIntegralValType<std::vector<int>>; // true
bool b3 = IsIntegralValType<std::list<double>>; // false
\end{cpp}

\mySubsubsection{3.2.3}{Constraining Member Functions}

Requires clauses can also be part of the declaration of member functions. That way, programmers can specify different APIs based on requirements and concepts.

Consider the following example:

\filename{lang/valorcoll.hpp}

\begin{cpp}
#include <iostream>
#include <ranges>

template<typename T>
class ValOrColl {
	T value;
	public:
	ValOrColl(const T& val)
	: value{val} {
	}
	ValOrColl(T&& val)
	: value{std::move(val)} {
	}
	
	void print() const {
		std::cout << value << '\n';
	}
	
	void print() const requires std::ranges::range<T> {
		for (const auto& elem : value) {
			std::cout << elem << ' ';
		}
		std::cout << '\n';
	}
};
\end{cpp}

Here, we define a class ValOrColl that can hold a single value or a collection of values as value of type T. Two print() member functions are provided and the class uses the standard concept std::ranges::range to decided which one to call:

\begin{itemize}
\item
If type T is a collection, the constraint is satisfied so that both print() member functions are available. However, the second print(), which iterates over the elements of the collection, is preferred by overload resolution, because this member function has a constraint.

\item
If type T is not a collection, only the first print() is available and therefore used.
\end{itemize}

For example, you can use the class as follows:

\filename{lang/valorcoll.cpp}

\begin{cpp}
#include "valorcoll.hpp"
#include <vector>

int main()
{
	ValOrColl o1 = 42;
	o1.print();
	ValOrColl o2 = std::vector{1, 2, 3, 4};
	o2.print();
}
\end{cpp}

The program has the following output:

\begin{shell}
42
1 2 3 4
\end{shell}

Note that you can constrain only templates this way. You cannot use requires to constrain ordinary functions:

\begin{cpp}
void foo() requires std::numeric_limits<char>::is_signed // ERROR
{
	...
}
\end{cpp}

One example of a constraining member function inside the C++standard library is the conditional availability of begin() for const views.

\mySubsubsection{3.2.4}{Constraining Non-Type Template Parameters}

It is not only types that you can constrain. You can also constrain values that are template parameters (non-type template parameters (NTTP)). For example:

\begin{cpp}
template<int Val>
concept LessThan10 = Val < 10;
\end{cpp}

Or more generic:

\begin{cpp}
template<auto Val>
concept LessThan10 = Val < 10;
\end{cpp}

This concept can be used as follows:

\begin{cpp}
template<typename T, int Size>
requires LessThan10<Size>
class MyType {
	...
};
\end{cpp}

We will discuss more examples later.










