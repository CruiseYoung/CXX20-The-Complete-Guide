
本节列出迭代器和范围的所有基本概念，这些概念在算法和类似函数中很有用。

注意，范围的概念是在命名空间std::ranges中提供的，不是在std中。并在头文件<ranges>中声明。

迭代器的概念在头文件<iterator>中声明。

\mySubsubsection{5.3.1}{范围和视图的概念}

定义了几个概念来约束范围，其与迭代器的概念相对应，并处理了自C++20以来新的迭代器类别。

\mySamllsection{std::ranges::range<Rg>}

\begin{itemize}
\item
保证Rg是一个有效的范围。

\item
这个概念在头文件<compare>中定义。

\item
Rg类型的对象支持通过使用std::ranges::begin()和std::ranges::end()对元素进行迭代。

若范围是一个数组，或者提供begin()和end()成员，或者可以与独立的begin()和end()函数一起使用，就会出现这种情况。

\item
此外，对于std::ranges::begin()和std::ranges::end()，适用以下约束:

\begin{itemize}
\item
必须在(平摊的)常数时间内运行。

\item
不修改范围。

\item
begin()在多次调用时产生相同的位置(除非该范围至少不提供前向迭代器)。
\end{itemize}

可以以良好的性能迭代所有元素(甚至多次迭代，除非有纯输入迭代器)。

\item
要求:

\begin{itemize}
\item
对于Rg类型的对象rg，支持std::ranges::begin(rg)和std::ranges::end(rg)
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::output\_range<Rg, T>}

\begin{itemize}
\item
保证Rg至少可提供接受T类型值的输出迭代器(可以用来编写的迭代器)的范围。

\item
要求:

\begin{itemize}
\item
需要满足std::range<Rg>

\item
迭代器类型满足std::output\_iterator和T
\end{itemize}
\end{itemize}


\mySamllsection{std::ranges::input\_range<Rg>}

\begin{itemize}
\item
保证Rg是一个至少提供输入迭代器(可用于读取的迭代器)的范围。

\item
要求:

\begin{itemize}
\item
需要满足std::range<Rg>

\item
迭代器类型满足std::input\_iterator
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::forward\_range<Rg>}

\begin{itemize}
\item
保证Rg是一个至少提供前向迭代器(可用于读写和多次迭代的迭代器)的范围。

\item
注意，迭代器的iterator\_category成员可能不匹配。对于产生左值的迭代器，它是std::input\_iterator\_tag(若可用)。

\item
要求:

\begin{itemize}
\item
需要满足std::input\_range<Rg>

\item
迭代器类型满足std::forward\_iterator
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::bidirectional\_range<Rg>}

\begin{itemize}
\item
保证Rg是一个至少提供双向迭代器的范围(可以用于读写和向后迭代的迭代器)。

\item
注意，迭代器的iterator\_category成员可能不匹配。对于产生左值的迭代器，它是std::input\_iterator\_tag(若可用)。

\item
要求:

\begin{itemize}
\item
需要满足std::forward\_range<Rg>

\item
迭代器类型满足std::bidirectional\_iterator
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::random\_access\_range<Rg>}

\begin{itemize}
\item
保证Rg是一个提供随机访问迭代器(可用于读写、前后跳转和计算距离的迭代器)的范围。

\item
注意，迭代器的iterator\_category成员可能不匹配。对于产生左值的迭代器，它是std::input\_iterator\_tag(若可用)。

\item
要求:

\begin{itemize}
\item
需要满足std::bidirectional\_range<Rg>

\item
迭代器类型满足std::random\_access\_iterator
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::contiguous\_range<Rg>}

\begin{itemize}
\item
保证Rg是一个范围，该范围提供随机访问迭代器，并附加约束元素存储在连续内存中。

\item
注意，迭代器的iterator\_category成员不匹配。若定义了类别成员，则只有std::random\_access\_iterator\_tag，若值是右值，甚至只有std::input\_iterator\_tag。

\item
要求:

\begin{itemize}
\item
需要满足std::random\_access\_range<Rg>

\item
迭代器类型满足std::contiguous\_iterator

\item
调用std::ranges::data()将生成指向第一个元素的裸指针
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::sized\_range<Rg>}

\begin{itemize}
\item
保证Rg是可以在常量时间内计算出元素数量的范围(通过调用成员size()或通过计算开始和结束之间的差值)。

\item
若满足这个概念，std::ranges::size()对于Rg类型的对象是快速且定义良好的。

\item
注意，这个概念的性能方面是一个语义约束，不能在编译时检查。为了表明一个类型即使提供了size()也不满足这个概念，可以定义std::disable\_size \_range<Rg>产生true。

\item
要求:

\begin{itemize}
\item
需要满足std::range<Rg>

\item
支持std::ranges::size()
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::common\_range<Rg>}

\begin{itemize}
\item
保证Rg是一个范围，其中开始迭代器和哨兵(结束迭代器)具有相同的类型。

\item
保证总是由:

\begin{itemize}
\item
所有标准容器(vector, list等)

\item
empty\_view

\item
single\_view

\item
common\_view
\end{itemize}

保证不是由:

\begin{itemize}
\item
查看视图

\item
删除const视图

\item
没有最终值或最终值为不同类型的iota视图
\end{itemize}

对于其他视图，其取决于底层范围的类型。

\item
要求:

\begin{itemize}
\item
需要满足std::range<Rg>

\item
std::ranges::iterator\_t<Rg>和std::ranges::sentinel\_t<Rg>具有相同类型
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::borrowed\_range<Rg>}

\begin{itemize}
\item
保证在当前上下文中传递的范围Rg，产生即使该范围不再存在也可以使用的迭代器。若传递左值或传递的范围始终是借来的范围，则满足该概念。

\item
若满足这个概念，则范围的迭代器与范围的生命周期无关。所以当创建迭代器的范围被销毁时，迭代器不能挂起。但若范围的迭代器指向基础范围，并且基础范围不再存在，则其仍然可以悬挂。

\item
形式上，若Rg是左值(例如有名称的对象)，或者变量模板std::ranges::enable\_borrow \_range<Rg>为真，则满足该概念，以下视图都是如此:subrange、ref\_view、string\_view、span、iota\_view和empty\_view。

\item
要求:

\begin{itemize}
\item
需要满足std::range<Rg>

\item
Rg是左值或enable\_borrow \_range<Rg>产生true
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::view<Rg>}

\begin{itemize}
\item
保证Rg是一个视图(复制、移动、赋值和销毁代价很低的范围)。

\item
视图有以下要求:

\begin{itemize}
\item
It has to be a range (support iteration over the elements).

\item
It has to be movable.

\item
The move constructor and, if available, the copy constructor have to have constant complexity.

\item
The move assignment operator and, if available, the copy assignment operator have to be cheap (constant complexity or not worse than destruction plus creation).
\end{itemize}

All but the last requirements are checked by corresponding concepts. The last requirement is a semantic constraint and has to be guaranteed by the implementer of a type by deriving publicly from std::ranges::view\_interface or by specializing std::ranges::enable\_view<Rg> to yield true.

\item
要求:

\begin{itemize}
\item
std::range<Rg> is satisfied

\item
std::movable<Rg> is satisfied

\item
The variable template std::ranges::enable\_view<Rg> is true
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::viewable\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range that can be safely converted to a view with the std::views::all() adaptor.

\item
The concept is satisfied if Rg is either already a view or an lvalue of a range or a movable rvalue or a range but not an initializer list.

\item
要求:

\begin{itemize}
\item
std::range<Rg> is satisfied

\end{itemize}
\end{itemize}

\mySubsubsection{5.3.2}{类指针对象的概念}

This section lists all standard concepts for objects for which you can use the operator * to deal with a value they point to. This usually applies to raw pointers, smart pointers, and iterators. Therefore, these concepts are usually used as base constraints for concepts that deal with iterators and algorithms.

Note that support of the operator -> is not required for these concepts.

These concepts are declared in the header file <iterator>.


\mySamllsection{基本概念的间接支持}

\mySamllsection{std::indirectly\_writable<P, Val>}

\begin{itemize}
\item
Guarantees that P is a pointer-like object supporting the operator * to assign a Val.
	
\item
Satisfied by non-const raw pointers, smart pointers, and iterators provided Val can be assigned to where P refers to.
\end{itemize}


\mySamllsection{std::indirectly\_readable<P>}

\begin{itemize}
\item
Guarantees that P is a pointer-like object supporting the operator * for read access.

\item
Satisfied by raw pointers, smart pointers, and iterators.


\item
要求:
\begin{itemize}
\item
The resulting value has the same reference type for both const and non-const objects (which rules out std::optional<>). This ensures that the constness of P does not propagate to where it points to (which is usually not the case when the operator returns a reference to a member).

\item
std::iter\_value\_t<P> must be valid. The type does not have to support the operator ->.
\end{itemize}
\end{itemize}

\mySamllsection{间接可读对象的概念}

For pointer-like concepts that are indirectly readable, you can check additional constraints:

\mySamllsection{std::indirectly\_movable<InP,OutP>}

\begin{itemize}
\item
Guarantees that values of InP can be move assigned directly to values of OutP.

\item
With this concept, the following code is valid:

\begin{cpp}
void foo(InP inPos, OutP, outPos) {
	*outPos = std::move(*inPos);
}
\end{cpp}

\item
要求:
\begin{itemize}
\item
std::indirectly\_readable<InP> is satisfied

\item
std::indirectly\_writable is satisfied for rvalue references of the values of InP to (the values of) OutP
\end{itemize}
\end{itemize}

\mySamllsection{std::indirectly\_movable\_storable<InP,OutP>}

\begin{itemize}
\item
Guarantees that values of InP can be move assigned indirectly to values of OutP even when using a (temporary) object of the type to where OutP points to.

\item
With this concept, the following code is valid:

\begin{cpp}
void foo(InP inPos, OutP, outPos) {
	OutP::value_type tmp = std::move(*inPos);
	*outPos = std::move(tmp);
}
\end{cpp}

\item
要求:
\begin{itemize}
\item
std::indirectly\_movable<InP, OutP> is satisfied

\item
std::indirectly\_writable is satisfied for the InP value to the objects OutP refers to

\item
std::movable is satisfied for the values InP refers to

\item
Rvalues that InP refers to are copy/move constructible and assignable
\end{itemize}
\end{itemize}

\mySamllsection{std::indirectly\_copyable<InP, OutP>}

\begin{itemize}
\item
Guarantees that values of InP can be assigned directly to values of OutP.

\item
With this concept, the following code is valid:

\begin{cpp}
void foo(InP inPos, OutP outPos) {
	*outPos = *inPos;
}
\end{cpp}

\item
要求:
\begin{itemize}
\item
std::indirectly\_readable<InP> is satisfied

\item
std::indirectly\_writable is satisfied for references of the values of InP to (the values of) OutP assignable
\end{itemize}
\end{itemize}

\mySamllsection{std::indirectly\_copyable\_storable<InP, OutP>}

\begin{itemize}
\item
Guarantees that values of InP can be assigned indirectly to values of OutP even when using a (temporary) object of the type to where OutP points to.

\item
With this concept, the following code is valid:

\begin{cpp}
void foo(InP inPos, OutP outPos) {
	OutP::value_type tmp = *inPos;
	*outPos = tmp;
}
\end{cpp}

\item
要求:
\begin{itemize}
\item
std::indirectly\_copyable<InP, OutP> is satisfied

\item
std::indirectly\_writable is satisfied for const lvalue and rvalue references of the InP value to the objects OutP refers to

\item
std::copyable is satisfied for the values InP refers to

\item
The values InP refers to are copy/move constructible and assignable
\end{itemize}
\end{itemize}

\mySamllsection{std::indirectly\_swappable<P>, std::indirectly\_swappable<P1, P2>}

\begin{itemize}
\item
Guarantees that values of P or P1 and P2 can be swapped (using std::ranges::iter\_swap()).

\item
要求:
\begin{itemize}
\item
std::indirectly\_readable<P1> (and std::indirectly\_readable<P2>) is satisfied

\item
For any two objects of types P1 and P2, std::ranges::iter\_swap() is supported
\end{itemize}
\end{itemize}

\mySamllsection{std::indirectly\_comparable<P1, P2, Comp>, std::indirectly\_comparable<P1, P2, Comp, Proj1>, std::indirectly\_comparable<P1, P2, Comp, Proj1, Proj2>}

\begin{itemize}
\item
Guarantees that you can compare the elements (optionally transformed with Proj1 and Proj2) to where P1 and P2 refer.

\item
要求:
\begin{itemize}
\item
std::indirect\_binary\_predicate for Comp

\item
std::projected<P1, Proj1> and std::projected<P2, Proj2> are satisfied with std::identity as default projections
\end{itemize}
\end{itemize}

\mySubsubsection{5.3.3}{迭代器的概念}

This section lists the concepts for requiring different types of iterators. They deal with the fact that we have new iterator categories since C++20 and they correspond with the concepts for ranges.

These concepts are provided in the header file <iterator>.

\mySamllsection{std::input\_output\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos supports the basic interface of all iterators: operator++ and operator*, where operator* has to refer to a value.

The concept does not require that the iterator is copyable (thus, this is less than the basic requirements for iterators used by algorithms).

\item
要求:
\begin{itemize}
\item
std::weakly\_incrementable<pos> is satisfied

\item
The operator * yields a reference
\end{itemize}
\end{itemize}

\mySamllsection{std::output\_iterator<Pos, T>}

\begin{itemize}
\item
Guarantees that Pos is an output iterator (an iterator where you can assign values to the elements) to whose values you can assign values of typeT.

\item
Iterators of type Pos can be used to assign a value val of type T with:

\begin{cpp}
*i++ = val;
\end{cpp}

\item
These iterators are only good for single-pass iterations.

\item
要求:
\begin{itemize}
\item
std::input\_or\_output\_iterator<Pos> is satisfied

\item
std::indirectly\_writable<Pos, I> is satisfied
\end{itemize}
\end{itemize}

\mySamllsection{std::input\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is an input iterator (an iterator where you can read values from the elements).

\item
These iterators are only good for single-pass iterations if std::forward\_iterator is not also satisfied.

\item
要求:
\begin{itemize}
\item
std::input\_or\_output\_iterator<Pos> is satisfied

\item
std::indirectly\_readable<Pos> is satisfied

\item
Pos has an iterator category derived from std::input\_iterator\_tag
\end{itemize}
\end{itemize}

\mySamllsection{std::forward\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is a forward iterator (a reading iterator with which you can iterate forward multiple times over elements).

\item
Note that the iterator\_category member of the iterator may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
要求:
\begin{itemize}
\item
std::input\_iterator<Pos> is satisfied

\item
std::incrementable<Pos> is satisfied

\item
Pos has an iterator category derived from std::forward\_iterator\_tag
\end{itemize}
\end{itemize}

\mySamllsection{std::bidirectional\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is a bidirectional iterator (a reading iterator with which you can iterate forward and backward multiple times over elements).

\item
Note that the iterator\_category member of the iterator may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
要求:
\begin{itemize}
\item
std::forward\_iterator<Pos> is satisfied

\item
Support to iterate backward with the operator -{}-

\item
Pos has an iterator category derived from std::bidirectional\_iterator\_tag
\end{itemize}
\end{itemize}

\mySamllsection{std::random\_access\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is a random-access iterator (a reading iterator with which you can jump back and forth over the elements).

\item
Note that the iterator\_category member of the iterator may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
要求:
\begin{itemize}
\item
std::bidirectional\_iterator<Pos> is satisfied

\item
std::totally\_ordered<Pos> is satisfied

\item
std::sized\_sentinel\_for<Pos, Pos> is satisfied

\item
Support for +, +=, -, -=, []

\item
Pos has an iterator category derived from std::random\_access\_iterator\_tag
\end{itemize}
\end{itemize}

\mySamllsection{std::contiguous\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is an iterator that iterates over elements in contiguous memory.

\item
Note that the iterator\_category member of the iterator does not match. If the category member is defined, it is only std::random\_access\_iterator\_tag, or even only std::input\_iterator\_tag if the values are prvalues.

\item
要求:
\begin{itemize}
\item
std::random\_access\_iterator<Pos> is satisfied

\item
Pos has an iterator category derived from std::contiguous\_iterator\_tag

\item
to\_address() for an element is a raw pointer to the element
\end{itemize}
\end{itemize}

\mySamllsection{std::sentinel\_for<S, Pos>}

\begin{itemize}
\item
Guarantees that S can be used as a sentinel (end iterator of maybe a different type) for Pos.

\item
要求:
\begin{itemize}
\item
std::semiregular<S> is satisfied

\item
std::input\_or\_output\_iterator<Pos> is satisfied

\item
Can compare Pos and S using the operators == and !=
\end{itemize}
\end{itemize}

\mySamllsection{std::sized\_sentinel\_for<S, Pos>}

\begin{itemize}
\item
Guarantees that S can be used as a sentinel (end iterator of maybe a different type) for Pos and you can compute the distance between them in constant time.

\item
To signal that you cannot compute the distance in constant time (even though you can compute the distance), you can define that std::disable\_sized\_sentinel\_for<Rg> yields true.

\item
要求:
\begin{itemize}
\item
std::sentinel\_for<S, Pos> is satisfied

\item
Calling the operator - for a Pos and S yields a value of the difference type of the iterator

\item
std::disable\_sized\_sentinel\_for<S, Pos> is not defined to yield true
\end{itemize}
\end{itemize}

\mySubsubsection{5.3.4}{算法的迭代器概念}

\mySamllsection{std::permutable<Pos>}

\begin{itemize}
\item
Guarantees that you can iterate forward by using the operator ++ and reorder elements by moving and swapping them

\item
要求:
\begin{itemize}
\item
std::forward\_iterator<Pos> is satisfied

\item
std::indirectly\_movable\_storable<Pos> is satisfied

\item
std::indirectly\_swappable<Pos> is satisfied
\end{itemize}
\end{itemize}

\mySamllsection{std::mergeable<Pos1, Pos2, ToPos>,
std::mergeable<Pos1, Pos2, ToPos, Comp>,
std::mergeable<Pos1, Pos2, ToPos, Comp, Proj1>,
std::mergeable<Pos1, Pos2, ToPos, Comp, Proj1, Proj2>,}

\begin{itemize}
\item
Guarantees that you can merge the elements of two sorted sequences to where Pos1 and Pos2 refer by copying them into a sequence to where ToPos refers. The order is defined by the operator < or Comp (applied to the values optionally transformed with projections Proj1 and Proj2).

\item
要求:
\begin{itemize}
\item
std::input\_iterator is satisfied for both Pos1 and Pos2

\item
std::weakly\_incrementable<ToPos> is satisfied

\item
std::indirectly\_copyable<PosN, ToPos> is satisfied for both Pos1 and Pos2

\item
std::indirect\_strict\_weak\_order of Comp as well as std::projected<Pos1, Proj1> and std::projected<Pos2, Proj2> are satisfied (with < as the default comparison and std::identity as the default projection), which implies:

\begin{itemize}
\item
std::indirectly\_readable is satisfied for Pos1 and Pos2

\item
std::copy\_constructible<Comp> is satisfied

\item
std::strict\_weak\_order<Comp> is satisfied for Comp\& and the (projected) value/reference types
\end{itemize}
\end{itemize}
\end{itemize}

\mySamllsection{std::sortable<Pos>
	std::sortable<Pos, Comp>
	std::sortable<Pos, Comp, Proj>}

\begin{itemize}
\item
Guarantees that you can sort the elements that the iterator Pos refers to with the operator < or Comp (after optionally applying the projection Proj to the values).

\item
要求:
\begin{itemize}
\item
std::permutable<Pos> is satisfied

\item
std::indirect\_strict\_weak\_order of Comp and the (projected) values is satisfied (with < as the default comparison and std::identity as the default projection), which implies:

\begin{itemize}
\item
std::indirectly\_readable<Pos> is satisfied

\item
std::copy\_constructible<Comp> is satisfied

\item
std::strict\_weak\_order<Comp> is satisfied for Comp\& and the (projected) value/reference types
\end{itemize}
\end{itemize}
\end{itemize}

























