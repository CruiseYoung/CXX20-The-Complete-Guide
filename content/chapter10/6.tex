
The formatting library can define formatting for user-defined types. What you need is a formatter, which is pretty straightforward to implement.

\mySubsubsection{10.6.1}{Basic Formatter API}

A formatter is a specialization of the class template std::formatter<> for your type(s). Inside the formatter, two member functions have to be defined:

\begin{itemize}
\item
parse() to implement how to parse the format string specifiers for your type

\item
format() to perform the actual formatting for an object/value of your type
\end{itemize}

Let us look at a first minimal example (we will improve it step by step) that specifies how to format an object/value that has a fixed value. Assume the type is defined like this (see format/always40.hpp):

\begin{cpp}
class Always40 {
	public:
	int getValue() const {
		return 40;
	}
};
\end{cpp}

For this type, we can define a first formatter (which we should definitely improve) as follows:

\filename{format/formatalways40.hpp}

\begin{cpp}
#include "always40.hpp"
#include <format>
#include <iostream>

template<>
struct std::formatter<Always40>
{
	// parse the format string for this type:
	constexpr auto parse(std::format_parse_context& ctx) {
		return ctx.begin(); // return position of } (hopefully there)
	}
	
	// format by always writing its value:
	auto format(const Always40& obj, std::format_context& ctx) const {
		return std::format_to(ctx.out(), "{}", obj.getValue());
	}
};
\end{cpp}

This is already good enough so that the following works:

\begin{cpp}
Always40 val;
std::cout << std::format("Value: {}\n", val);
std::cout << std::format("Twice: {0} {0}\n", val);
\end{cpp}

The output would be:

\begin{shell}
Value: 40
Twice: 40 40
\end{shell}

We define the formatter as a specialization of type std::formatter<> for our type Always40:

\begin{cpp}
template<>
struct std::formatter<Always40>
{
	...
};
\end{cpp}

Because we only have public members, we use struct instead of class.


\mySamllsection{Parsing the Format String}

In parse(), we implement the function to parse the format string:

\begin{cpp}
// parse the format string for this type:
constexpr auto parse(std::format_parse_context& ctx) {
	return ctx.begin(); // return position of } (hopefully there)
}
\end{cpp}

The function takes a std::format\_parse\_context, which provides an API to iterate over the remaining characters of the passed format string. ctx.begin() points to the first character of the format specifier for the value to be parsed or the \} if there is no specifier:

\begin{itemize}
\item
If the format string is "Value: \{:7.2f\}"
ctx.begin() points to: "7.2f\}"

\item
If the format string is "Twice: \{0\} \{0\}"
ctx.begin() points to: "\} \{0\}"
when called for the first time

\item
If the format string is "\{\}\verb|\|n"
ctx.begin() points to: "\}\verb|\|n"
\end{itemize}

There is also a ctx.end(), which points to the end of the whole format string. This means that the opening \{ was already parsed and you have to parse all characters until the corresponding closing \}.

For the format string "Val: \{1:\_>20\}cm \verb|\|n", ctx.begin() is the position of the \_ and ctx.end() is the end of the whole format string after the \verb|\|n. The task of parse() is to parse the specified format of the passed argument, which means that you have to parse only the characters \_>20, and then return the position of the end of the format specifier which is the trailing \} behind the character 0.

In our implementation, we do not support any format specifier yet. Therefore, we simply return the position of the first character we get, which will work only if the next character really is the \} (dealing with character before the closing \} is the first thing we have to improve). Calling std::format() with any specified format character will not work:

\begin{cpp}
Always40 val;
std::format("'{:7}", val) // ERROR
\end{cpp}

Note that the parse() member function should be constexpr to support compile-time computing of the format string. This means that the code has to accept all restrictions of constexpr functions (which were relaxed with C++20).

However, you can see how this API allows programmers to parse whatever format we have specified for their types. This is used, for example, to support formatted output of the chrono library. Of course, we should follow the conventions of the standard specifiers to avoid programmer confusion.

\mySamllsection{Performing the Formatting}

In format(), we implement the function to format the passed value:

\begin{cpp}
// format by always writing its value:
auto format(const Always40& value, std::format_context& ctx) const {
	return std::format_to(ctx.out(), "{}", value.getValue());
}
\end{cpp}

The function takes two parameters:

\begin{itemize}
\item
Our value passed as an argument to std::format() (or similar functions)

\item
A std::format\_context, which provides the API to write the resulting characters of the formatting (according to the parsed format)
\end{itemize}

The most important function of the format context is out(), which yields an object you can pass to std::format\_to() to write the actual characters of the formatting. The function has to return the new position for further output, which is returned by std::format\_to().

Note that the format() member function of a formatter should be const. According to the original C++20 standard, that was not required (see \url{http://wg21.link/lwg3636} for details).

\mySubsubsection{10.6.2}{Improved Parsing}

Let us improve the example we saw previously. First, we should ensure that the parser deals with the format specifiers in a better way:

\begin{itemize}
\item
We should take care of all characters up to the closing \}.

\item
We should throw an exception when illegal formatting arguments are specified.

\item
We should deal with valid formatting arguments (such as a specified field width).
\end{itemize}

Let us look at all of these topics by looking at an improved version of the previous formatter (this time dealing with a type that always has the value 41):

\filename{format/formatalways41.hpp}

\begin{cpp}
#include "always41.hpp"
#include <format>
template<>
class std::formatter<Always41>
{
	int width = 0; // specified width of the field
public:
	// parse the format string for this type:
	constexpr auto parse(std::format_parse_context& ctx) {
		auto pos = ctx.begin();
		while (pos != ctx.end() && *pos != '}') {
		if (*pos < '0' || *pos > '9') {
			throw std::format_error{std::format("invalid format '{}'", *pos)};
		}
		width = width * 10 + *pos - '0'; // new digit for the width
		++pos;
		}
		return pos; // return position of }
	}
	
	// format by always writing its value:
	auto format(const Always41& obj, std::format_context& ctx) const {
		return std::format_to(ctx.out(), "{:{}}", obj.getValue(), width);
	}
};
\end{cpp}

Our formatter now has a member to store the specified field width:

\begin{cpp}
template<>
class std::formatter<Always41>
{
	int width = 0; // specified width of the field
	...
};
\end{cpp}

The field width is initialized with 0, but can be specified by the format string.

The parser now has a loop that processes all characters up to the trailing \}:

\begin{cpp}
constexpr auto parse(std::format_parse_context& ctx) {
	auto pos = ctx.begin();
	while (pos != ctx.end() && *pos != '}') {
		...
		++pos;
	}
	return pos; // return position of }
}
\end{cpp}

Note that the loop has to check for both whether there is still a character and whether it is the trailing \}, because the programmer calling std::format() might have forgotten the trailing \}.

Inside the loop, we multiply the current width with the integral value of the digit character:

\begin{cpp}
width = width * 10 + *pos - '0'; // new digit for the width
\end{cpp}

If the character is not a digit, we throw a std::format exception initialized with std::format():

\begin{cpp}
if (*pos < '0' || *pos > '9') {
	throw std::format_error{std::format("invalid format '{}'", *pos)};
}
\end{cpp}

Note that we cannot use std::isdigit() here because it is not a function we could call at compile time.

You can test the formatter as follows: format/always41.cpp 

The program has the following output:

\begin{shell}
41
Value: 41
Twice: 41 41
With width: ’      41’
Format Error: invalid format ’f’
\end{shell}

The value is right-aligned because this is the default alignment for integral values.

\mySubsubsection{10.6.3}{Using Standard Formatters for User-Defined Formatters}

We can still improve the formatter implemented above:

\begin{itemize}
\item
We can allow alignment specifiers.

\item
We can support fill characters.
\end{itemize}

Fortunately, we do not have to implement the complete parsing ourselves. Instead, we can use the standard formatters to benefit from the format specifiers they support. Actually, there are two approaches for doing that:

\begin{itemize}
\item
You can delegate the works to a local standard formatter.

\item
You can inherit from a standard formatter.
\end{itemize}

\mySamllsection{Delegating Formatting to Standard Formatters}

To delegate formatting to standard formatters, you have to

\begin{itemize}
\item
Declare a local standard formatter

\item
Let the parse() function delegate the work to the standard formatter

\item
Let the format() function delegate the work to the standard formatter
\end{itemize}

In general, this should look as follows:

\filename{format/formatalways42ok.hpp}

\begin{cpp}
#include "always42.hpp"
#include <format>

// *** formatter for type Always42:
template<>
struct std::formatter<Always42>
{
	// use a standard int formatter that does the work:
	std::formatter<int> f;
	
	// delegate parsing to the standard formatter:
	constexpr auto parse(std::format_parse_context& ctx) {
		return f.parse(ctx);
	}
	
	// delegate formatting of the value to the standard formatter:
	auto format(const Always42& obj, std::format_context& ctx) const {
		return f.format(obj.getValue(), ctx);
	}
};
\end{cpp}

As usual, we declare a specialization of std::formatter<> for type Always42. However, this time, we use a local standard formatter for type int that does the work. We delegate both the parsing and the formatting to it. In fact, we extract the value from our type with getValue() and use the standard int formatter to do the rest of the formatting.

We can test the formatter with the following program:

\filename{format/always42.cpp}

\begin{cpp}
#include "always42.hpp"
#include "formatalways42.hpp"
#include <iostream>

int main()
{
	try {
		Always42 val;
		std::cout << val.getValue() << '\n';
		std::cout << std::format("Value: {}\n", val);
		std::cout << std::format("Twice: {0} {0}\n", val);
		std::cout << std::format("With width: '{:7}'\n", val);
		std::cout << std::format("With all: '{:.^7}'\n", val);
	}
	catch (std::format_error& e) {
		std::cerr << "Format Error: " << e.what() << std::endl;
	}
}
\end{cpp}

The program has the following output:

\begin{shell}
42
Value: 42
Twice: 42 42
With width: ’     42’
With all:   ’..42...’
\end{shell}

Note that the value is still right-aligned by default because that is the default alignment for int.

Note also that in practice, you might need some modifications for this code, which is discussed later in detail:

\begin{itemize}
\item
Declaring format() as const might not compile unless the formatter is declared as mutable.

\item
Declaring parse() as constexpr might not compile.
\end{itemize}

\mySamllsection{Inheriting From Standard Formatters}

Usually, it is even enough to derive from a standard formatter so that the formatter member and its parse() function are implicitly available:

\filename{format/formatalways42inherit.hpp}

\begin{cpp}
#include "always42.hpp"
#include <format>

// *** formatter for type Always42:
// - use standard int formatter
template<>
struct std::formatter<Always42> : std::formatter<int>
{
	auto format(const Always42& obj, std::format_context& ctx) {
		// delegate formatting of the value to the standard formatter:
		return std::formatter<int>::format(obj.getValue(), ctx);
	}
};
\end{cpp}

However, note that in practice, you might also need some modifications for this code:

\begin{itemize}
\item
Declaring format() as const might not compile.
\end{itemize}

\mySamllsection{Using Standard Formatters in Practice}

In practice, there are some issues with what was standardized with C++20 so that afterwards some things had to be clarified:

\begin{itemize}
\item
C++20 as originally standardized did not require that the format() member function of a formatter should be const (see \url{http://wg21.link/lwg3636} for details). To support implementations of the C++ standard library that do not declare format() as a const member function, you have to either declare it as a non-const function or declare the local formatter as mutable.

\item
Existing implementations might not yet support compile-time parsing with a parse() member function that is constexpr because compile-time parsing was added after C++20 was standardized (see \url{http: //wg21.link/p2216r3}). In that case, we cannot delegate compile-time parsing to a standard formatter.
\end{itemize}

As a consequence, in practice, the formatter for type Always42 might have to look as follows:

\filename{format/formatalways42.hpp}

\begin{cpp}
#include "always42.hpp"
#include <format>

// *** formatter for type Always42:
template<>
struct std::formatter<Always42>
{
	// use a standard int formatter that does the work:
#if __cpp_lib_format < 202106
	mutable // in case the standard formatters have a non-const format()
#endif
	std::formatter<int> f;
	
	// delegate parsing to the standard int formatter:
#if __cpp_lib_format >= 202106
	constexpr // in case standard formatters don’t support constexpr parse() yet
#endif
	auto parse(std::format_parse_context& ctx) {
		return f.parse(ctx);
	}
	
	// delegate formatting of the int value to the standard int formatter:
	auto format(const Always42& obj, std::format_context& ctx) const {
		return f.format(obj.getValue(), ctx);
	}
};
\end{cpp}

As you can see, the code

\begin{itemize}
\item
Declares parse() only with constexpr if the corresponding fix was adopted

\item
Might declare the local formatter with mutable so that the const format() member function can call a standard format() function that is not const
\end{itemize}

For both, the implementation uses a feature test macro that signals that compile-time parsing is supported (expecting that its adoptions also make the format() member functions of the standard formatters const ).

\mySubsubsection{10.6.4}{Using Standard Formatters for Strings}

If you have more complicated types to format, one common approach is to create a string and then use the standard formatter for strings (std::string or std::string\_view if only string literals are used).

For example, we can define an enumeration type and a formatter for it as follows:

\filename{format/color.hpp}

\begin{cpp}
#include <format>
#include <string>

enum class Color { red, green, blue };

// *** formatter for enum type Color:
template<>
struct std::formatter<Color> : public std::formatter<std::string>
{
	auto format(Color c, format_context& ctx) const {
		// initialize a string for the value:
		std::string value;
		switch (c) {
			using enum Color;
			case red:
				value = "red";
				break;
			case green:
				value = "green";
				break;
			case blue:
				value = "blue";
				break;
			default:
				value = std::format("Color{}", static_cast<int>(c));
				break;
		}
		// and delegate the rest of formatting to the string formatter:
		return std::formatter<std::string>::format(value, ctx);
	}
};
\end{cpp}

By inheriting the formatter from the formatter for strings, we inherit its parse() functions, which means that we support all format specifiers strings have. In the format() function, we then perform the mapping to a string and then let the standard formatter do the rest of the formatting.

We can use the formatter as follows:

\filename{format/color.cpp}

\begin{cpp}
#include "color.hpp"
#include <iostream>
#include <string>
#include <format>

int main()
{
	for (auto val : {Color::red, Color::green, Color::blue, Color{13}}) {
		// use user-provided formatter for enum Color:
		std::cout << std::format("Color {:_>8} has value {:02}\n",
								  val, static_cast<int>(val));
	}
}
\end{cpp}

The program has the following output:

\begin{shell}
Color _____red has value 00
Color ___green has value 01
Color ____blue has value 02
Color _Color13 has value 13
\end{shell}

This approach usually works fine if you do not introduce your own format specifiers. If only string literals are used as possible values, you could even use the formatter for std::string\_view instead.




