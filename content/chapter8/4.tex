
This section discusses all features of C++20 for creating views that generate values themselves (meaning that they do not refer to elements or values outside the view).

\mySubsubsection{8.4.1}{Iota View}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:}                 & std::ranges::iota\_view\textless{}\textgreater{} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}              & Generator of an incrementing sequence of values  \\ \hline
\textbf{Factory:}              & std::views::iota()                               \\ \hline
\textbf{Element type:}         & Values                                           \\ \hline
\textbf{Category:}        & Input to random access(depends on the type of the start value) \\ \hline
\textbf{Is sized range:}       & If initialized with an end value                 \\ \hline
\textbf{Is common range:} & If limited and the end has the same type as the values         \\ \hline
\textbf{Is borrowed range:}    & Always                                           \\ \hline
\textbf{Caches:}               & Nothing                                          \\ \hline
\textbf{Const iterable:}       & Always                                           \\ \hline
\textbf{Propagates constness:} & Never(but elements are not lvalues)              \\ \hline
\end{longtable}

The class template std::ranges::iota\_view<> is a view that generates a sequence of values. These values may be integral, such as

\begin{itemize}
\item
1, 2, 3 ...

\item
’a’, ’b’, ’c’ ...
\end{itemize}

or they might use the operator ++ to generate a sequence of pointers or iterators.

The sequence might be limited or unlimited (endless).

The major use case of the iota view is to provide a view that iterates over a sequence of values. For example:

\begin{cpp}
std::ranges::iota_view v1{1, 100}; // view with values: 1, 2, ... 99
for (auto val : v1) {
	std::cout << val << '\n'; // print these values
}
\end{cpp}

\mySamllsection{Range Factories for Iota Views}

Iota views can also (and usually should) be created with a range factory:

\begin{cpp}
std::views::iota(val)
std::views::iota(val, endVal)
\end{cpp}

For example:

\begin{cpp}
for (auto val : std::views::iota(1, 100)) { // iterate over values 1, 2, ... 99
	std::cout << val << '\n'; // print these values
}
\end{cpp}

Here is a full example program using iota views:

\filename{ranges/iotaview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <vector>
#include <ranges>

void print(std::ranges::input_range auto&& coll)
{
	int num = 0;
	for (const auto& elem : coll) {
		std::cout << elem << ' ';
		if (++num > 30) { // print only up to 30 values:
			std::cout << "...";
			break;
		}
	}
	std::cout << '\n';
}

int main()
{
	std::ranges::iota_view<int> iv0; // 0 1 2 3 ...
	print(iv0);
	
	std::ranges::iota_view iv1{-2}; // -2 -1 0 1 ...
	print(iv1);
	
	std::ranges::iota_view iv2{10, 20}; // 10 11 12 ... 19
	print(iv2);
	
	auto iv3 = std::views::iota(1); // -2 -1 0 1 ...
	print(iv3);
	
	auto iv4 = std::views::iota('a', 'z'+1); // a b c ... z
	print(iv4);
	
	std::vector coll{0, 8, 15, 47, 11};
	for (auto p : std::views::iota(coll.begin(), coll.end())) { // sequence of iterators
		std::cout << *p << ' '; // 0 8 15 47 11
	}
	std::cout << '\n';
}
\end{cpp}

The program has the following output:

\begin{shell}
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ...
-2 -1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ...
10 11 12 13 14 15 16 17 18 19
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ...
a b c d e f g h i j k l m n o p q r s t u v w x y z
0 8 15 47 11	
\end{shell}

Note that the output from ’a’ to ’z’ depends on the character set of the platform.

\mySamllsection{Special Characteristics of Iota Views}

Because the iterators hold the current value, the iota view is a borrowed range (the lifetime of its iterators does not depend on the view). If the iota view is limited and the end value has the same type as the begin value, the view is a common range.

If the iota view is endless or the type of the end differs from the type of the begin, it is not a common range. You might have to use a common view to harmonize the types of the begin iterator and the sentinel (end iterator).

\mySamllsection{Interface of Iota Views}

Table Operations of the class std::ranges::iota\_view<> lists the API of an iota view.


% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation}       & \textbf{Effect}                                                    \\ \hline
\endfirsthead
%
\endhead
%
ioat\_view\textless{}Type\textgreater v & Creates an unlimited sequence starting with the default value of Type               \\ \hline
iota\_view v\{begVal\}   & Creates an unlimited sequence starting with begVal                 \\ \hline
iota\_view v\{begVal, endVal\}          & Creates a sequence starting with begVal up to the value before endVal               \\ \hline
iota\_view v\{beg, end\} & Helper constructor to enable sub-views                             \\ \hline
v.begin()                & Yields the begin iterator(referring to the starting value)         \\ \hline
v.end()                                 & Yields the sentinel(end iterator), which is std::unreachable\_sentinel if unlimited \\ \hline
v.empty()                & Yields whether v is empty                                          \\ \hline
if (v)                   & true if v is not empty                                             \\ \hline
v.size()                 & Yields the number of elements(available if limited and computable) \\ \hline
v.front()                & Yields the first element                                           \\ \hline
v.back()                 & Yields the last element(available if limited and common)           \\ \hline
v{[}idx{]}               & Yields the n-th element                                            \\ \hline
\end{longtable}

\begin{center}
Table 8.8. Operations of the class std::ranges::iota\_view<>
\end{center}

When declaring an iota view as follows:

\begin{cpp}
std::ranges::iota_view v1{1, 100}; // range with values: 1, 2, ... 99
\end{cpp}

the type of v1 is deduced as std::ranges::iota\_view<int, int>, which creates an object that provides the basic API, with begin() and end() yielding an iterator to these values. The iterators store the current value internally and increment it when the iterator is incremented:

\begin{cpp}
std::ranges::iota_view v1{1, 100}; // range with values: 1, 2, ... 99
auto pos = v1.begin(); // initialize iterator with value 1
std::cout << *pos; // print current value (here, value 1)
++pos; // increment to next value (i.e., increment value to 2)
std::cout << *pos; // print current value (here, value 2)
\end{cpp}

Thus, the type of the values has to support the operator ++. For this reason, a value type such as bool or std::string is not possible.

Note that the type of this iterator is up to the implementation of iota\_view, which means that you have to use auto when using it. Alternatively, you could declare pos with std::ranges::iterator\_t<>:

\begin{cpp}
std::ranges::iterator_t<decltype(v1)> pos = v1.begin();
\end{cpp}

As for ranges of iterators, the range of values is a half-open range and the end value is not included. To include the end value, you might have to increment the end :

\begin{cpp}
std::ranges::iota_view letters{'a', 'z'+1}; // values: ’a’, ’b’, ... ’z’
for (auto c : letters) {
	std::cout << c << ' '; // print these values/letters
}
\end{cpp}

Note that the output of this loop depends on the character set. Only if the lower-case letters have consecutive values (as is the case with ASCII or ISO-Latin-1 or UTF-8) the view iterates over nothing else but lower-case characters. By using char8\_t, you can ensure portably that this is the case for UTF-8 characters:

\begin{cpp}
std::ranges::iota_view letters{u8'a', u8'z'+1}; // UTF-8 values from a to z
\end{cpp}

If no end value is passed, the view is unlimited and generates an endless sequence of values:

\begin{cpp}
std::ranges::iota_view v2{10L}; // unlimited range with values: 10L, 11L, 12L, ...
std::ranges::iota_view<int> v3; // unlimited range with values: 0, 1, 2, ...
\end{cpp}

The type of v3 is std::ranges::iota\_view<int, std::unreachable\_sentinel\_t>, meaning that end() yields std::unreachable\_sentinel.

An unlimited iota view is endless. When the iterator represents the highest value and iterates to the next value, it calls the operator ++, which formally, is undefined behavior (in practice, it usually performs an overflow, so that the next value is the lowest value of the value type). If the view has an end value that never matches, it behaves the same.

\mySamllsection{Using Iota Views to Iterate over Pointers and Iterators}

You can initialize an iota view with iterators or pointers. In that case, the iota view uses the first value as begin and the last value as end, but the elements are iterators/pointers instead of the values.

You can use this to deal with iterators to all elements of a range.

\begin{cpp}
std::list<int> coll{2, 4, 6, 8, 10, 12, 14};
...
// pass iterator to each element to foo():
for (const auto& itorElem : std::views::iota(coll.begin(), coll.end())) {
	std::cout << *itorElem << '\n';
}
\end{cpp}

You can also use this feature to initialize a container with iterators to all elements of a collection coll:

\begin{cpp}
std::ranges::iota_view itors{coll.begin(), coll.end()};
std::vector<std::ranges::iterator_t<decltype(coll)>> refColl{itors.begin(),
	itors.end()};
\end{cpp}

Note that if you skip the specification of the element type of refColl, you have to use parentheses. Otherwise, you would initialize the vector with two iterator elements:

\begin{cpp}
std::vector refColl(itors.begin(), itors.end());
\end{cpp}

The main reason that this constructor is provided is to support generic code that can create a sub-view of an iota view, like, for example, the drop view does:

\begin{cpp}
// generic function to drop the first element from a view:
auto dropFirst = [] (auto v) {
						return decltype(v){++v.begin(), v.end()};
					};
std::ranges::iota_view v1{1, 9}; // iota view with elems from 1 to 8
auto v2 = dropFirst(v1); // iota view with elems from 2 to 8
\end{cpp}

In this case, the availability of the member functions size() and operator[] depends on the support for these operators in the passed range.

\mySubsubsection{8.4.2}{Single View}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:}                 & std::ranges::single\_view\textless{}\textgreater{} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}              & Generator of a range with a single element         \\ \hline
\textbf{Factory:}              & std::views::single()                               \\ \hline
\textbf{Element type:}         & Reference                                          \\ \hline
\textbf{Category:}             & Contiguous                                         \\ \hline
\textbf{Is sized range:}       & Always with size 1                                 \\ \hline
\textbf{Is common range:}      & Always                                             \\ \hline
\textbf{Is borrowed range:}    & Never                                              \\ \hline
\textbf{Caches:}               & Nothing                                            \\ \hline
\textbf{Const iterable:}       & Always                                             \\ \hline
\textbf{Propagates constness:} & Always                                             \\ \hline
\end{longtable}

The class template std::ranges::single\_view<> is a view that owns one element. Unless the value type is const, you can even modify the value.

The overall effect is that a single view behaves roughly like a cheap collection of one element that does not allocate any heap memory.

The major use case of the single view is to call generic code to operate on a cheap view with exactly one element/value:

\begin{cpp}
std::ranges::single_view<int> v1{42}; // single view
for (auto val : v1) {
	... // called once
}
\end{cpp}

This can be used for test cases or for cases where code has to provide a view that in a specific context, has to contain exactly one element.

\mySamllsection{Range Factories for Single Views}

Single views can also (and usually should) be created with a range factory:

\begin{cpp}
std::views::single(val)
\end{cpp}

For example:

\begin{cpp}
for (auto val : std::views::single(42)) { // iterate over the single int value 42
	... // called once
}
\end{cpp}

Here is a full example program using single views:

\filename{ranges/singleview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <ranges>

void print(std::ranges::input_range auto&& coll)
{
	for (const auto& elem : coll) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}

int main()
{
	std::ranges::single_view<double> sv0; // single view double 0.0
	std::ranges::single_view sv1{42}; // single_view<int> with int 42
	
	auto sv2 = std::views::single('x'); // single_view<char>
	auto sv3 = std::views::single("ok"); // single_view<const char*>
	std::ranges::single_view<std::string> sv4{"ok"}; // single view with string "ok"
	
	print(sv0);
	print(sv1);
	print(sv2);
	print(sv3);
	print(sv4);
	print(std::ranges::single_view{42});
}
\end{cpp}

The program has the following output:

\begin{shell}
0
42
x
ok
ok
42
\end{shell}

\mySamllsection{Special Characteristics of Single Views}

The single view models the following concepts:

\begin{itemize}
\item
std::ranges::contiguous\_range

\item
std::ranges::sized\_range
\end{itemize}

The view is always a common range and never a borrowed range (the lifetime of its iterators does not depend on the view).

\mySamllsection{Interface of Single Views}

Table Operations of the class std::ranges::single\_view<> lists the API of a single view.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation} & \textbf{Effect}                                         \\ \hline
\endfirsthead
%
\endhead
%
single\_view\textless{}Type\textgreater v                                    & Creates a view with one value-initialized element of type Type   \\ \hline
single\_view v\{val\}                                                        & Creates a view with one element of value val of its type         \\ \hline
single\_view\textless{}Type\textgreater v\{std::in\_place, arg1, arg2, ...\} & Creates a view with one element initialized with arg1, arg2, ... \\ \hline
v.begin()          & Yields a raw pointer to the element                     \\ \hline
v.end()            & Yields a raw pointer to the position behind the element \\ \hline
v.empty()          & Always false                                            \\ \hline
if(v)              & Always true                                             \\ \hline
v.size()           & Yields 1                                                \\ \hline
v.front()          & Yields a reference to the current value                 \\ \hline
v.back()           & Yields a reference to the current value                 \\ \hline
v{[}idx{]}         & Yields the current value for idx 0                      \\ \hline
r.data()           & Yields a raw pointer to the element                     \\ \hline
\end{longtable}

\begin{center}
Table 8.9. Operations of the class std::ranges::single\_view<>
\end{center}

If you call the constructor without passing an initial value, the element in the single view is valueinitialized. That means it either uses the default constructor of its Type or initializes the value with 0, false, or nullptr.

To initialize a single view with objects that need multiple initializers, you have two options:

\begin{itemize}
\item
Passing the initialized object:

\begin{cpp}
std::ranges::single_view sv1{std::complex{1,1}};
auto sv2 = std::views::single(std::complex{1,1});
\end{cpp}

\item
Passing the initial values as arguments after an argument std::in\_place:

\begin{cpp}
std::ranges::single_view<std::complex<int>> sv4{std::in_place, 1, 1};
\end{cpp}
\end{itemize}

Note that for a non-const single view, you can modify the value of the “element:”

\begin{cpp}
std::ranges::single_view v2{42};
std::cout << v2.front() << '\n'; // prints 42
++v2.front(); // OK, modifies value of the view
std::cout << v2.front() << '\n'; // prints 43
\end{cpp}

You can prevent this by declaring the element type as const:

\begin{cpp}
std::ranges::single_view<const int> v3{42};
++v3.front(); // ERROR
\end{cpp}

The constructor taking a value either copies or moves this values into the view. This means that the view cannot refer to the initial value (declaring the element type to be a reference does not compile).

Because begin() and end() yield the same value, the view is always a common range. Because iterators refer to the value stored in the view to be able to modify it, the single view is not a borrowed range (the lifetime of its iterators does depend on the view)

\mySubsubsection{8.4.3}{Empty View}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:}                 & std::ranges::empty\_view\textless{}\textgreater{} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}              & Generator of a range wit no element               \\ \hline
\textbf{Factory:}              & std::views::empty\textless{}\textgreater{}        \\ \hline
\textbf{Element type:}         & Reference                                         \\ \hline
\textbf{Category:}             & Contiguous                                        \\ \hline
\textbf{Is sized range:}       & Always with size 0                                \\ \hline
\textbf{Is common range:}      & Always                                            \\ \hline
\textbf{Is borrowed range:}    & Always                                            \\ \hline
\textbf{Caches:}               & Nothing                                           \\ \hline
\textbf{Const iterable:}       & Always                                            \\ \hline
\textbf{Propagates constness:} & Never                                             \\ \hline
\end{longtable}

The class template std::ranges::empty\_view<> is a view with no elements. However, you have to specify the element type.

The major use case of the empty view is to call generic code with a cheap view that has no elements and for which the type system knows that it never has any elements:


\begin{cpp}
std::ranges::empty_view<int> v1; // empty view
for (auto val : v1) {
	... // never called
}
\end{cpp}

This can be used for test cases or for cases where code has to provide a view that in a specific context, can never have any elements.

\mySamllsection{Range Factories for Empty Views}

Empty views can also (and usually should) be created with a range factory, which which is a variable template, meaning that you declare it with a template parameter for the type but no call parameters:

\begin{cpp}
std::views::empty<type>
\end{cpp}

For example:

\begin{cpp}
for (auto val : std::views::empty<int>) { // iterate over no int values
	... // never called
}
\end{cpp}

Here is a full example program using empty views:

\filename{ranges/emptyview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <ranges>

void print(std::ranges::input_range auto&& coll)
{
	if (coll.empty()) {
		std::cout << "<empty>\n";
	}
	else {
		for (const auto& elem : coll) {
			std::cout << elem << ' ';
		}
		std::cout << '\n';
	}
}

int main()
{
	std::ranges::empty_view<double> ev0; // empty view of double
	auto ev1 = std::views::empty<int>; // empty view of int
	
	print(ev0);
	print(ev1);
}
\end{cpp}

The program has the following output:

\begin{shell}
<empty>
<empty>
\end{shell}

\mySamllsection{Special Characteristics of Empty Views}

An empty view behaves roughly like an empty vector. In fact, it models the following concepts:

\begin{itemize}
\item
std::ranges::contiguous\_range (which implies std::ranges::random\_access\_range)

\item
std::ranges::sized\_range
\end{itemize}

Both begin() and end() simply always yield the nullptr, meaning that the range is also a common range and a borrowed range (the lifetime of its iterators does not depend on the view).

\mySamllsection{Interface of Empty Views}

Table Operations of the class std::ranges::empty\_view<> lists the API of an empty view.

You might wonder why an empty view provides front(), back(), and operator[] that always have undefined behavior. Calling them is always a fatal runtime error. However, remember that generic code always has to check (or know) that there are elements before calling front(), back(), or the operator [], meaning that this generic code would never call these member functions. Such code will compile even for empty views.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation} & \textbf{Effect}                                                       \\ \hline
\endfirsthead
%
\endhead
%
empty\_view\textless{}Type\textgreater v & Creates a view with no elements of type Type                          \\ \hline
v.begin()                                & Yields a raw pointer to the element type initialized with the nullptr \\ \hline
v.end()            & Yields a raw pointer to the element type initialized with the nullptr \\ \hline
v.empty()          & Yields true                                                           \\ \hline
if (v)             & Always false                                                          \\ \hline
v.size()           & Yields 0                                                              \\ \hline
v.front()          & Always undefined behavior(fatal runtime error)                        \\ \hline
v.back()           & Always undefined behavior(fatal runtime error)                        \\ \hline
v{[}idx{]}         & Always undefined behavior(fatal runtime error)                        \\ \hline
r.data             & Yields a raw pointer to the element type initialized with the nullptr \\ \hline
\end{longtable}

\begin{center}
Table 8.10. Operations of the class std::ranges::empty\_view<>
\end{center}

For example, you can pass an empty view to code like this and it will compile:

\begin{cpp}
void foo(std::ranges::random_access_range auto&& rg)
{
	std::cout << "sortFirstLast(): \n";
	std::ranges::sort(rg);
	if (!std::ranges::empty(rg)) {
		std::cout << " first: " << rg.front() << '\n';
		std::cout << " last: " << rg.back() << '\n';
	}
}

foo(std::ranges::empty_view<int>{}); // OK
\end{cpp}

\mySubsubsection{8.4.4}{IStream View}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:} &
\begin{tabular}[c]{@{}l@{}}std::ranges::basic\_istream\_view\textless{}\textgreater\\ std::ranges::istream\_view\textless{}\textgreater\\ std::ranges::wistream\_view\textless{}\textgreater{}\end{tabular} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}              & Generator of a range with elements read from a stream \\ \hline
\textbf{Factory:}              & std::views::istream\textless{}\textgreater{}()        \\ \hline
\textbf{Element type:}         & Reference                                             \\ \hline
\textbf{Category:}             & Input                                                 \\ \hline
\textbf{Is sized range:}       & Never                                                 \\ \hline
\textbf{Is common range:}      & Never                                                 \\ \hline
\textbf{Is borrowed range:}    & Never                                                 \\ \hline
\textbf{Caches:}               & Nothing                                               \\ \hline
\textbf{Const iterable:}       & Never                                                 \\ \hline
\textbf{Propagates constness:} & --                                                    \\ \hline
\end{longtable}

The class template std::ranges::basic\_istream\_view<> is a view that reads elements from an input stream (such as the standard input, from a file, or from a string stream).

As usual for stream types, the type is generic for the type of the characters and provides specializations for char and wchar\_t:

\begin{itemize}
\item
The class template std::ranges::istream\_view<> is a view that reads elements from an input stream using characters of type char.

\item
The class template std::ranges::wistream\_view<> is a view that reads elements from an input stream using characters of type wchar\_t.
\end{itemize}

For example:

\begin{cpp}
std::istringstream myStrm{"0 1 2 3 4"};

for (const auto& elem : std::ranges::istream_view<int>{myStrm}) {
	std::cout << elem << '\n';
}
\end{cpp}

\mySamllsection{Range Factories for IStream Views}

Istream views can also (and usually should) be created with a range factory. The factory passes its parameters to the std::ranges::basic\_istream\_view constructor using the character type of the passed range:

\begin{cpp}
std::views::istream<Type>(rg)
\end{cpp}

For example:

\begin{cpp}
std::istringstream myStrm{"0 1 2 3 4"};

for (const auto& elem : std::views::istream<int>(myStrm)) {
	std::cout << elem << '\n';
}
\end{cpp}

or:

\begin{cpp}
std::wistringstream mywstream{L"1.1 2.2 3.3 4.4"};
auto vw = std::views::istream<double>(mywstream);
\end{cpp}

The initialization of vw is equivalent to both of the following initializations:

\begin{cpp}
auto vw2 = std::ranges::basic_istream_view<double, wchar_t>{myStrm};
auto vw3 = std::ranges::wistream_view<double>{myStrm};
\end{cpp}

Here is a full example program using istream views:

\filename{ranges/istreamview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <sstream>
#include <ranges>

void print(std::ranges::input_range auto&& coll)
{
	for (const auto& elem : coll) {
		std::cout << elem << " ";
	}
	std::cout << '\n';
}

int main()
{
	std::string s{"2 4 6 8 Motorway 1977 by Tom Robinson"};
	
	std::istringstream mystream1{s};
	std::ranges::istream_view<std::string> vs{mystream1};
	print(vs);
	
	std::istringstream mystream2{s};
	auto vi = std::views::istream<int>(mystream2);
	print(vi);
}
\end{cpp}

The program has the following output:

\begin{shell}
2 4 6 8 Motorway 1977 by Tom Robinson
2 4 6 8
\end{shell}

The program iterates twice over an string stream initialized with the string s:

\begin{itemize}
\item
The istream view vs iterates over all strings read from the input string stream mystream1. It prints all sub-strings of s.

\item
The istream view vi iterates over all ints read from the input string stream mystream2. Its reading ends when it reaches Motorway.
\end{itemize}

\mySamllsection{IStream Views and const}

Note that you cannot iterate over a const istream view. For example:

\begin{cpp}
void printElems(const auto& coll) {
	for (const auto elem& e : coll) {
		std::cout << elem << '\n';
	}
}

std::istringstream myStrm{"0 1 2 3 4"};

printElems(std::views::istream<int>(myStrm)); // ERROR
\end{cpp}

The problem is that begin() is provided only for a non-const istream view because a value is processed in two steps (begin()/++ and then operator*) and the value is stored in the view in the meantime.

The reason for modifying the view is demonstrated by the following example of reading strings from an istream view by using a low-level way to iterate over the “elements” of the view:

\begin{cpp}
std::istringstream myStrm{"stream with very-very-very-long words"};

auto v = std::views::istream<std::string>(myStrm);

for (auto pos = v.begin(); pos != v.end(); ++pos) {
	std::cout << *pos << '\n';
}
\end{cpp}

This code has the following output:

\begin{shell}
stream
with
very-very-very-long
words
\end{shell}

When the iterator pos iterates over the view va, it reads strings from the input stream myStrm with begin() and ++. These strings have to be stored internally so that they can be used via the operator *. If we store the string in the iterator, the iterator might have to hold memory for the string and copying the iterator would have to copy this memory. However, copying an iterator should not be expensive. Therefore, the view stores the string in the view, which has the effect that the view is modified while we are iterating.

As a consequence, you have to use universal/forwarding references to support this view in generic code:

\begin{cpp}
void printElems(auto&& coll) {
	...
}
\end{cpp}

\mySamllsection{Interface of IStream Views}

Table Operations of the class std::ranges::basic\_istream\_view<> lists the API of an istream view.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation} & \textbf{Effect}                                     \\ \hline
\endfirsthead
%
\endhead
%
istream\_view\textless{}Type\textgreater v\{strm\} & Creates an istream view of type Type reading from strm \\ \hline
v.begin()          & Reads the first value and yields tha begin iterator \\ \hline
v.end()            & Yields std::default\_sentinel as end iterator       \\ \hline
\end{longtable}

\begin{center}
Table 8.11. Operations of the class std::ranges::basic\_istream\_view<>
\end{center}

All you can do is to use iterators to read value by value until the end of the stream is reached. No other member function (like empty() or front()) is provided.

Note that the original specification of istream views in the C++20 standard had some inconsistencies with other views, which were fixed afterwards (see \url{http://wg21.link/p2432}). With this fix, we have the current behavior:

\begin{itemize}
\item
You can fully specify all template parameters:

\begin{cpp}
std::ranges::basic_istream_view<int, char, std::char_traits<char>> v1{myStrm};
\end{cpp}

\item
The last template parameter has a working default value, meaning that you can use:

\begin{cpp}
std::ranges::basic_istream_view<int, char> v2{myStrm}; // OK
\end{cpp}

\item
However, you cannot skip more parameters:

\begin{cpp}
std::ranges::basic_istream_view<int> v3{myStrm}; // ERROR
\end{cpp}

\item
However, the istream views follow the usual convention that there are special types for char and wchar\_t streams without the basic\_ prefix:

\begin{cpp}
std::ranges::istream_view<int> v4{myStrm}; // OK for char streams

std::wistringstream mywstream{L"0 1 2 3 4"};
std::ranges::wistream_view<int> v5{mywstream}; // OK for wchar_t streams
\end{cpp}

\item
And a corresponding range factory is provided:

\begin{cpp}
auto v6 = std::views::istream<int>(myStrm); // OK
\end{cpp}
\end{itemize}

\mySubsubsection{8.4.5}{String View}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:} &
\begin{tabular}[c]{@{}l@{}}std::basic\_string\_view\textless{}\textgreater\\ std::string\_view\\ std::u8string\_view\\ std::u16string\_view\\ std::u32string\_view\\ std::wstring\_view\end{tabular} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}              & All characters of a character sequence \\ \hline
\textbf{Factory:}              & --                                     \\ \hline
\textbf{Element type:}         & const reference                        \\ \hline
\textbf{Category:}             & Contiguous                             \\ \hline
\textbf{Is sized range:}       & Always                                 \\ \hline
\textbf{Is common range:}      & Always                                 \\ \hline
\textbf{Is borrowed range:}    & Always                                 \\ \hline
\textbf{Caches:}               & Nothing                                \\ \hline
\textbf{Const iterable:}       & Always                                 \\ \hline
\textbf{Propagates constness:} & Elements are always const              \\ \hline
\end{longtable}

The class template std::basic\_string\_view<> and its specializations std::string\_view, std::u16string\_view, std::u32string\_view, and std::wstring\_view are the only view types that were already available in the C++17 standard library. However, C++20 adds the specialization for UTF-8 characters: std::u8string\_view.

String views do not follow a couple of conventions that views usually have:

\begin{itemize}
\item
The view is defined in the namespace std (instead of std::ranges).

\item
The view has its own header file <string\_view>.

\item
The view has no range adaptor/factory to create view objects.

\item
The view provides only read access to the elements/characters.

\item
The view provides cbegin() and cend() member functions.

\item
The view supports no conversion to bool.
\end{itemize}

For example:

\begin{cpp}
for (char c : std::string_view{"hello"}) {
	std::cout << c << ' ';
}
std::cout << '\n';
\end{cpp}

This loop has the following output:

\begin{shell}
h e l l o
\end{shell}

\mySamllsection{Special Characteristics of String Views}

Iterators do not refer to this view. Instead, they refer to the underlying character sequence. Therefore, a string view is a borrowed range. However, note that iterators can still dangle when the underlying character sequence is no longer there.

\mySamllsection{View-Specific Interface of String Views}

Table View operations of the class std::basic\_string\_view<> lists the view-relevant parts of the API of a string view.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation}   & \textbf{Effect}                                                       \\ \hline
\endfirsthead
%
\endhead
%
string\_view sv      & Creates a string view with no elements                                \\ \hline
string\_view sv\{s\} & Creates a string view to s                                            \\ \hline
v.begin()            & Yields a raw pointer to the element type initialized with the nullptr \\ \hline
v.end()              & Yields a raw pointer to the element type initialized with the nullptr \\ \hline
sv.empty()           & Yields whether sv is empty                                            \\ \hline
sv.size()            & Yields the number of characters                                       \\ \hline
sv.front()           & Yields the first character                                            \\ \hline
sv.back()            & Yields the last character                                             \\ \hline
sv{[}idx{]}          & Yields th n-th character                                              \\ \hline
sv.data()            & Yields a raw pointer to the characters or nullptr                     \\ \hline
...                  & Several other operations provided for read-only strings               \\ \hline
\end{longtable}

\begin{center}
Table 8.12. View operations of the class std::ranges::basic\_string\_view<>
\end{center}

In addition to the usual interface of views, the type also provides the full API of all read-only operations of strings.

For more details, take a look at my book C++17 - The Complete Guide (see \url{http://www.cppstd17.com}).

\mySubsubsection{8.4.6}{Span}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:}                 & std::span\textless{}\textgreater{}           \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}              & All elements of a range in contiguous memory \\ \hline
\textbf{Factory:}              & std::views::counted()                        \\ \hline
\textbf{Element type:}         & Reference                                    \\ \hline
\textbf{Requires:}             & Contiguous range                             \\ \hline
\textbf{Category:}             & Contiguous                                   \\ \hline
\textbf{Is sized range:}       & Always                                       \\ \hline
\textbf{Is common range:}      & Always                                       \\ \hline
\textbf{Is borrowed range:}    & Always                                       \\ \hline
\textbf{Caches:}               & Nothing                                      \\ \hline
\textbf{Const iterable:}       & Always                                       \\ \hline
\textbf{Propagates constness:} & Never                                        \\ \hline
\end{longtable}

The class template std::span<> is a view to a sequence of elements that are stored in contiguous memory. It is described in its own chapter in detail. Here, we present only the properties of spans as a view.

The major benefit of spans is that they support referring to a subrange of n elements in the middle or at the end of the referred range. For example:

\begin{cpp}
std::vector<std::string> vec{"New York", "Tokyo", "Rio", "Berlin", "Sydney"};

// sort the three elements in the middle:
std::ranges::sort(std::span{vec}.subspan(1, 3));

// print last three elements:
print(std::span{vec}.last(3));
\end{cpp}

This example is discussed later in a section of the chapter about spans.

Note that spans do not follow a couple of conventions that views usually have:

\begin{itemize}
\item
The view is defined in the namespace std instead of std::ranges.

\item
The view has its own header file <span>.

\item
The view supports no conversion to bool.
\end{itemize}

\mySamllsection{Range Factories for Spans}

There is no range factory for initializing a span from a begin (iterator) and an end (sentinel). However, there is a range factory that might create a span from begin and a count:

\begin{cpp}
std::views::counted(beg, sz)
\end{cpp}

std::views::counted() creates a span of dynamic size initialized with the first sz elements of the contiguous range, starting with the iterator beg (for a non-contiguous range, counted() creates a subrange).

For example:

\begin{cpp}
std::vector<int> vec{1, 2, 3, 4, 5, 6, 7, 8, 9};

auto v = std::views::counted(vec.begin()+1, 3); // span with 2nd to 4th elem of vec
\end{cpp}

When std::views::counted() creates a span, the span has dynamic extent (its size can vary).

\mySamllsection{Special Characteristics of Spans}

Iterators do not refer to a span. Instead, they refer to the underlying elements. Therefore, a span is a borrowed range. However, note that iterators can still dangle when the underlying character sequence is no longer there.

\mySamllsection{View-Specific Interface of Spans}

Table View operations of the class std::span<> lists the view-relevant parts of the API of a span.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation} & \textbf{Effect}                                   \\ \hline
\endfirsthead
%
\endhead
%
span sp            & Creates a span with no elements                   \\ \hline
span sp\{s\}       & Creates a span to s                               \\ \hline
sp.begin()         & Yields the begin iterator                         \\ \hline
sp.end()           & Yields the sentinel (end iterator)                \\ \hline
sp.empty()         & Yields whether sv is empty                        \\ \hline
sp.size()          & Yields the number of characters                   \\ \hline
sp.front()         & Yields the first character                        \\ \hline
sp.back()          & Yields the last character                         \\ \hline
sp{[}idx{]}        & Yields the n-th character                         \\ \hline
sp.data()          & Yields a raw pointer to the characters or nullptr \\ \hline
...                & See the section about spans operations            \\ \hline
\end{longtable}

\begin{center}
Table 8.13. View operations of the class std::span<>
\end{center}

For more details, see the section about span operations.









