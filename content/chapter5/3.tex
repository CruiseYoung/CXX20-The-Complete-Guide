
This section lists all basic concepts for iterators and ranges, which are useful in algorithms and similar functions.

Note that the concepts for ranges are provided in the namespace std::ranges instead of std. They are declared in the header file <ranges>.

Concepts for iterators are declared in the header file <iterator>.

\mySubsubsection{5.3.1}{Concepts for Ranges and Views}

Several concepts are defined to constrain ranges. They correspond with the concepts for iterators and deal with the fact that we have new iterator categories since C++20.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a valid range.

\item
This concept is defined in the header file <compare>.

\item
This means that objects of type Rg support iteration over the elements by using std::ranges::begin() and std::ranges::end().

This is the case if the range is either an array or provides begin() and end() members or can be used with free-standing begin() and end() functions.

\item
In addition, for std::ranges::begin() and std::ranges::end(), the following constraints apply:

\begin{itemize}
\item
They have to operate in (amortized) constant time.

\item
They do not modify the range.

\item
begin() yields the same position when called multiple times (unless the range does not provide at least forward iterators).
\end{itemize}

That all means that we can iterate over all elements with good performance (even multiple times unless we have pure input iterators).

\item
Requires:

\begin{itemize}
\item
For an object rg of type Rg, std::ranges::begin(rg) is supported and std::ranges::end(rg) is supported
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::output\_range<Rg, T>}

\begin{itemize}
\item
Guarantees that Rg is a range that provides at least output iterators (iterators that you can use to write) that accept values of type T.

\item
Requires:

\begin{itemize}
\item
std::range<Rg> is satisfied

\item
std::output\_iterator is satisfied for the iterator type and T
\end{itemize}
\end{itemize}


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::input\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range that provides at least input iterators (iterators that you can use to read).

\item
Requires:

\begin{itemize}
\item
std::range<Rg> is satisfied

\item
std::input\_iterator is satisfied for the iterator type
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::forward\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range that provides at least forward iterators (iterators that you can use to read and write and to iterate over multiple times).

\item
Note that the iterator\_category member of the iterators may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
Requires:

\begin{itemize}
\item
std::input\_range<Rg> is satisfied

\item
std::forward\_iterator is satisfied for the iterator type
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::bidirectional\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range that provides at least bidirectional iterators (iterators that you can use to read and write and to iterate over also backward).

\item
Note that the iterator\_category member of the iterators may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
Requires:

\begin{itemize}
\item
std::forward\_range<Rg> is satisfied

\item
std::bidirectional\_iterator is satisfied for the iterator type
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::random\_access\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range that provides random-access iterators (iterators that you can use to read and write, jump back and forth, and compute the distance).

\item
Note that the iterator\_category member of the iterators may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
Requires:

\begin{itemize}
\item
std::bidirectional\_range<Rg> is satisfied

\item
std::random\_access\_iterator is satisfied for the iterator type
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::contiguous\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range that provides random-access iterators with the additional constraint that the elements are stored in contiguous memory.

\item
Note that the iterator\_category member of the iterators does not match. If the category member is defined, it is only std::random\_access\_iterator\_tag, or even only std::input\_iterator\_tag if the values are prvalues.

\item
Requires:

\begin{itemize}
\item
std::random\_access\_range<Rg> is satisfied

\item
std::contiguous\_iterator is satisfied for the iterator type

\item
Calling std::ranges::data() yields a raw pointer to the first element
\end{itemize}
\end{itemize}

\mySamllsection{std::ranges::sized\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range where the number of elements can be computed in constant time (either by calling the member size() or by computing the difference between the beginning and the end).

\item
If this concept is satisfied, std::ranges::size() is fast and well-defined for objects of type Rg.

\item
Note that the performance aspect of this concept is a semantic constraint, which cannot be checked at compile time. To signal that a type does not satisfy this concept even though it provides size(), you can define that std::disable\_sized\_range<Rg> yields true.

\item
Requires:

\begin{itemize}
\item
std::range<Rg> is satisfied

\item
Calling std::ranges::size() is supported
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::common\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range where the begin iterator and the sentinel (end iterator) have the same type.

\item
The guarantee is always given by:

\begin{itemize}
\item
All standard containers (vector, list, etc.)

\item
empty\_view

\item
single\_view

\item
common\_view
\end{itemize}

The guarantee is not given by:

\begin{itemize}
\item
take views

\item
const drop views

\item
iota views with no end value or an end value of a different type
\end{itemize}

For other views, it depends on the type of the underlying ranges.

\item
Requires:

\begin{itemize}
\item
std::range<Rg> is satisfied

\item
std::ranges::iterator\_t<Rg> and std::ranges::sentinel\_t<Rg> have the same type
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::borrowed\_range<Rg>}

\begin{itemize}
\item
Guarantees that the passed range Rg in the current context yields iterators that can be used even when the range no longer exists. The concept is satisfied if an lvalue is passed or the passed range is always a borrowed range.

\item
If the concept is satisfied, iterators of the range are not tied to the lifetime of the range. This means that iterators cannot dangle when the range they were created from is destroyed. However, they can still dangle if the iterators of the range refer to an underlying range and the underlying range is no longer there.

\item
Formally, the concept is met if Rg is an lvalue (such as an object with a name) or if the variable template std::ranges::enable\_borrowed\_range<Rg> is true, which is the case for the following views: subrange, ref\_view, string\_view, span, iota\_view, and empty\_view.

\item
Requires:

\begin{itemize}
\item
std::range<Rg> is satisfied

\item
Rg is an lvalue or enable\_borrowed\_range<Rg> yields true
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::view<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a view (a range that is cheap to copy or move, assign, and destroy).

\item
A view has the following requirements:

\begin{itemize}
\item
It has to be a range (support iteration over the elements).

\item
It has to be movable.

\item
The move constructor and, if available, the copy constructor have to have constant complexity.

\item
The move assignment operator and, if available, the copy assignment operator have to be cheap (constant complexity or not worse than destruction plus creation).
\end{itemize}

All but the last requirements are checked by corresponding concepts. The last requirement is a semantic constraint and has to be guaranteed by the implementer of a type by deriving publicly from std::ranges::view\_interface or by specializing std::ranges::enable\_view<Rg> to yield true.

\item
Requires:

\begin{itemize}
\item
std::range<Rg> is satisfied

\item
std::movable<Rg> is satisfied

\item
The variable template std::ranges::enable\_view<Rg> is true
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::viewable\_range<Rg>}

\begin{itemize}
\item
Guarantees that Rg is a range that can be safely converted to a view with the std::views::all() adaptor.

\item
The concept is satisfied if Rg is either already a view or an lvalue of a range or a movable rvalue or a range but not an initializer list.

\item
Requires:

\begin{itemize}
\item
std::range<Rg> is satisfied

\end{itemize}
\end{itemize}

\mySubsubsection{5.3.2}{Concepts for Pointer-Like Objects}

This section lists all standard concepts for objects for which you can use the operator * to deal with a value they point to. This usually applies to raw pointers, smart pointers, and iterators. Therefore, these concepts are usually used as base constraints for concepts that deal with iterators and algorithms.

Note that support of the operator -> is not required for these concepts.

These concepts are declared in the header file <iterator>.


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Basic Concepts for Indirect Support}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::indirectly\_writable<P, Val>}

\begin{itemize}
\item
Guarantees that P is a pointer-like object supporting the operator * to assign a Val.
	
\item
Satisfied by non-const raw pointers, smart pointers, and iterators provided Val can be assigned to where P refers to.
\end{itemize}


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::indirectly\_readable<P>}

\begin{itemize}
\item
Guarantees that P is a pointer-like object supporting the operator * for read access.

\item
Satisfied by raw pointers, smart pointers, and iterators.


\item
Requires:
\begin{itemize}
\item
The resulting value has the same reference type for both const and non-const objects (which rules out std::optional<>). This ensures that the constness of P does not propagate to where it points to (which is usually not the case when the operator returns a reference to a member).

\item
std::iter\_value\_t<P> must be valid. The type does not have to support the operator ->.
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Concepts for Indirectly Readable Objects}

For pointer-like concepts that are indirectly readable, you can check additional constraints:

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::indirectly\_movable<InP,OutP>}

\begin{itemize}
\item
Guarantees that values of InP can be move assigned directly to values of OutP.

\item
With this concept, the following code is valid:

\begin{cpp}
void foo(InP inPos, OutP, outPos) {
	*outPos = std::move(*inPos);
}
\end{cpp}

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable<InP> is satisfied

\item
std::indirectly\_writable is satisfied for rvalue references of the values of InP to (the values of) OutP
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::indirectly\_movable\_storable<InP,OutP>}

\begin{itemize}
\item
Guarantees that values of InP can be move assigned indirectly to values of OutP even when using a (temporary) object of the type to where OutP points to.

\item
With this concept, the following code is valid:

\begin{cpp}
void foo(InP inPos, OutP, outPos) {
	OutP::value_type tmp = std::move(*inPos);
	*outPos = std::move(tmp);
}
\end{cpp}

\item
Requires:
\begin{itemize}
\item
std::indirectly\_movable<InP, OutP> is satisfied

\item
std::indirectly\_writable is satisfied for the InP value to the objects OutP refers to

\item
std::movable is satisfied for the values InP refers to

\item
Rvalues that InP refers to are copy/move constructible and assignable
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::indirectly\_copyable<InP, OutP>}

\begin{itemize}
\item
Guarantees that values of InP can be assigned directly to values of OutP.

\item
With this concept, the following code is valid:

\begin{cpp}
void foo(InP inPos, OutP outPos) {
	*outPos = *inPos;
}
\end{cpp}

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable<InP> is satisfied

\item
std::indirectly\_writable is satisfied for references of the values of InP to (the values of) OutP assignable
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::indirectly\_copyable\_storable<InP, OutP>}

\begin{itemize}
\item
Guarantees that values of InP can be assigned indirectly to values of OutP even when using a (temporary) object of the type to where OutP points to.

\item
With this concept, the following code is valid:

\begin{cpp}
void foo(InP inPos, OutP outPos) {
	OutP::value_type tmp = *inPos;
	*outPos = tmp;
}
\end{cpp}

\item
Requires:
\begin{itemize}
\item
std::indirectly\_copyable<InP, OutP> is satisfied

\item
std::indirectly\_writable is satisfied for const lvalue and rvalue references of the InP value to the objects OutP refers to

\item
std::copyable is satisfied for the values InP refers to

\item
The values InP refers to are copy/move constructible and assignable
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::indirectly\_swappable<P>, std::indirectly\_swappable<P1, P2>}

\begin{itemize}
\item
Guarantees that values of P or P1 and P2 can be swapped (using std::ranges::iter\_swap()).

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable<P1> (and std::indirectly\_readable<P2>) is satisfied

\item
For any two objects of types P1 and P2, std::ranges::iter\_swap() is supported
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::indirectly\_comparable<P1, P2, Comp>, std::indirectly\_comparable<P1, P2, Comp, Proj1>, std::indirectly\_comparable<P1, P2, Comp, Proj1, Proj2>}

\begin{itemize}
\item
Guarantees that you can compare the elements (optionally transformed with Proj1 and Proj2) to where P1 and P2 refer.

\item
Requires:
\begin{itemize}
\item
std::indirect\_binary\_predicate for Comp

\item
std::projected<P1, Proj1> and std::projected<P2, Proj2> are satisfied with std::identity as default projections
\end{itemize}
\end{itemize}

\mySubsubsection{5.3.3}{Concepts for Iterators}

This section lists the concepts for requiring different types of iterators. They deal with the fact that we have new iterator categories since C++20 and they correspond with the concepts for ranges.

These concepts are provided in the header file <iterator>.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::input\_output\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos supports the basic interface of all iterators: operator++ and operator*, where operator* has to refer to a value.

The concept does not require that the iterator is copyable (thus, this is less than the basic requirements for iterators used by algorithms).

\item
Requires:
\begin{itemize}
\item
std::weakly\_incrementable<pos> is satisfied

\item
The operator * yields a reference
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::output\_iterator<Pos, T>}

\begin{itemize}
\item
Guarantees that Pos is an output iterator (an iterator where you can assign values to the elements) to whose values you can assign values of typeT.

\item
Iterators of type Pos can be used to assign a value val of type T with:

\begin{cpp}
*i++ = val;
\end{cpp}

\item
These iterators are only good for single-pass iterations.

\item
Requires:
\begin{itemize}
\item
std::input\_or\_output\_iterator<Pos> is satisfied

\item
std::indirectly\_writable<Pos, I> is satisfied
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::input\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is an input iterator (an iterator where you can read values from the elements).

\item
These iterators are only good for single-pass iterations if std::forward\_iterator is not also satisfied.

\item
Requires:
\begin{itemize}
\item
std::input\_or\_output\_iterator<Pos> is satisfied

\item
std::indirectly\_readable<Pos> is satisfied

\item
Pos has an iterator category derived from std::input\_iterator\_tag
\end{itemize}
\end{itemize}


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::forward\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is a forward iterator (a reading iterator with which you can iterate forward multiple times over elements).

\item
Note that the iterator\_category member of the iterator may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
Requires:
\begin{itemize}
\item
std::input\_iterator<Pos> is satisfied

\item
std::incrementable<Pos> is satisfied

\item
Pos has an iterator category derived from std::forward\_iterator\_tag
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::bidirectional\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is a bidirectional iterator (a reading iterator with which you can iterate forward and backward multiple times over elements).

\item
Note that the iterator\_category member of the iterator may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
Requires:
\begin{itemize}
\item
std::forward\_iterator<Pos> is satisfied

\item
Support to iterate backward with the operator -{}-

\item
Pos has an iterator category derived from std::bidirectional\_iterator\_tag
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::random\_access\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is a random-access iterator (a reading iterator with which you can jump back and forth over the elements).

\item
Note that the iterator\_category member of the iterator may not match. For iterators that yield prvalues, it is std::input\_iterator\_tag (if available).

\item
Requires:
\begin{itemize}
\item
std::bidirectional\_iterator<Pos> is satisfied

\item
std::totally\_ordered<Pos> is satisfied

\item
std::sized\_sentinel\_for<Pos, Pos> is satisfied

\item
Support for +, +=, -, -=, []

\item
Pos has an iterator category derived from std::random\_access\_iterator\_tag
\end{itemize}
\end{itemize}

\mySamllsection{std::contiguous\_iterator<Pos>}

\begin{itemize}
\item
Guarantees that Pos is an iterator that iterates over elements in contiguous memory.

\item
Note that the iterator\_category member of the iterator does not match. If the category member is defined, it is only std::random\_access\_iterator\_tag, or even only std::input\_iterator\_tag if the values are prvalues.

\item
Requires:
\begin{itemize}
\item
std::random\_access\_iterator<Pos> is satisfied

\item
Pos has an iterator category derived from std::contiguous\_iterator\_tag

\item
to\_address() for an element is a raw pointer to the element
\end{itemize}
\end{itemize}

\mySamllsection{std::sentinel\_for<S, Pos>}

\begin{itemize}
\item
Guarantees that S can be used as a sentinel (end iterator of maybe a different type) for Pos.

\item
Requires:
\begin{itemize}
\item
std::semiregular<S> is satisfied

\item
std::input\_or\_output\_iterator<Pos> is satisfied

\item
Can compare Pos and S using the operators == and !=
\end{itemize}
\end{itemize}

\mySamllsection{std::sized\_sentinel\_for<S, Pos>}

\begin{itemize}
\item
Guarantees that S can be used as a sentinel (end iterator of maybe a different type) for Pos and you can compute the distance between them in constant time.

\item
To signal that you cannot compute the distance in constant time (even though you can compute the distance), you can define that std::disable\_sized\_sentinel\_for<Rg> yields true.

\item
Requires:
\begin{itemize}
\item
std::sentinel\_for<S, Pos> is satisfied

\item
Calling the operator - for a Pos and S yields a value of the difference type of the iterator

\item
std::disable\_sized\_sentinel\_for<S, Pos> is not defined to yield true
\end{itemize}
\end{itemize}

\mySubsubsection{5.3.4}{Iterator Concepts for Algorithms}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::permutable<Pos>}

\begin{itemize}
\item
Guarantees that you can iterate forward by using the operator ++ and reorder elements by moving and swapping them

\item
Requires:
\begin{itemize}
\item
std::forward\_iterator<Pos> is satisfied

\item
std::indirectly\_movable\_storable<Pos> is satisfied

\item
std::indirectly\_swappable<Pos> is satisfied
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::mergeable<Pos1, Pos2, ToPos>,
std::mergeable<Pos1, Pos2, ToPos, Comp>,
std::mergeable<Pos1, Pos2, ToPos, Comp, Proj1>,
std::mergeable<Pos1, Pos2, ToPos, Comp, Proj1, Proj2>,}

\begin{itemize}
\item
Guarantees that you can merge the elements of two sorted sequences to where Pos1 and Pos2 refer by copying them into a sequence to where ToPos refers. The order is defined by the operator < or Comp (applied to the values optionally transformed with projections Proj1 and Proj2).

\item
Requires:
\begin{itemize}
\item
std::input\_iterator is satisfied for both Pos1 and Pos2

\item
std::weakly\_incrementable<ToPos> is satisfied

\item
std::indirectly\_copyable<PosN, ToPos> is satisfied for both Pos1 and Pos2

\item
std::indirect\_strict\_weak\_order of Comp as well as std::projected<Pos1, Proj1> and std::projected<Pos2, Proj2> are satisfied (with < as the default comparison and std::identity as the default projection), which implies:

\begin{itemize}
\item
std::indirectly\_readable is satisfied for Pos1 and Pos2

\item
std::copy\_constructible<Comp> is satisfied

\item
std::strict\_weak\_order<Comp> is satisfied for Comp\& and the (projected) value/reference types
\end{itemize}
\end{itemize}
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::sortable<Pos>
	std::sortable<Pos, Comp>
	std::sortable<Pos, Comp, Proj>}

\begin{itemize}
\item
Guarantees that you can sort the elements that the iterator Pos refers to with the operator < or Comp (after optionally applying the projection Proj to the values).

\item
Requires:
\begin{itemize}
\item
std::permutable<Pos> is satisfied

\item
std::indirect\_strict\_weak\_order of Comp and the (projected) values is satisfied (with < as the default comparison and std::identity as the default projection), which implies:

\begin{itemize}
\item
std::indirectly\_readable<Pos> is satisfied

\item
std::copy\_constructible<Comp> is satisfied

\item
std::strict\_weak\_order<Comp> is satisfied for Comp\& and the (projected) value/reference types
\end{itemize}
\end{itemize}
\end{itemize}

























