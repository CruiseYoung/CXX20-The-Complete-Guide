
This section lists all concepts for callables

\begin{itemize}
\item
Functions

\item
Function objects

\item
Lambdas

\item
Pointers to members (with the type of the object as an additional parameter)
\end{itemize}

\mySubsubsection{5.4.1}{Basic Concepts for Callables}

\mySamllsection{std::invocable<Op, ArgTypes...>}

\begin{itemize}
\item
Guarantees that you can iterate forward by using the operator ++ and reorder elements by moving and swapping them

\item
Requires:
\begin{itemize}
\item
Guarantees that Op can be called for the arguments of types ArgTypes....

\item
Op can be a function, function object, lambda, or pointer-to-member.

\item
To document that neither the operation nor the passed arguments are modified, you can use std::regular\_invocable instead. However, note that there is only a semantic difference between these two concepts, which cannot be checked at compile time. Therefore, the concept differences only document the intention.

\item
For example:

\begin{cpp}
struct S {
	int member;
	int mfunc(int);
	void operator()(int i) const;
};

void testCallable()
{
	std::invocable<decltype(testCallable)> // satisfied
	std::invocable<decltype([](int){}), char> // satisfied (char converts to int)
	std::invocable<decltype(&S::mfunc), S, int> // satisfied (member-pointer, object, args)
	std::invocable<decltype(&S::member), S>; // satisfied (member-pointer and object)
	std::invocable<S, int>; // satisfied due to operator()
}
\end{cpp}

Note that as a type constraint, you only have to specify the parameter types:

\begin{cpp}
void callWithIntAndString(std::invocable<int, std::string> auto op);
\end{cpp}

For a complete example, see the use of a lambda as a non-type template parameter.

\item
Requires:
\begin{itemize}
\item
std::invoke(op, args) is valid for an op of type Op and args of type ArgTypes...
\end{itemize}
\end{itemize}
\end{itemize}

\mySamllsection{std::regular\_invocable<Op, ArgTypes...>}

\begin{itemize}
\item
Guarantees that Op can be called for the arguments of types ArgTypes... and that the call changes neither the state of the passed operation nor of the passed arguments.

\item
Op can be a function, function object, lambda, or pointer-to-member.

\item
Note that the difference to the concept std::invocable is purely semantic and cannot be checked at compile time. Therefore, the concept differences only document the intention.

\item
Requires:
\begin{itemize}
\item
std::invoke(op, args) is valid for an op of type Op and args of type ArgTypes...
\end{itemize}
\end{itemize}

\mySamllsection{std::predicate<Op, ArgTypes...>}

\begin{itemize}
\item
Guarantees that the callable (function, function object, lambda) Op is a predicate that can be called for the arguments of types ArgTypes....

\item
This implies that the call changes neither the state of the passed operation nor of the passed arguments.

\item
Requires:
\begin{itemize}
\item
std::regular\_invocable<Op> is satisfied

\item
 All calls of Op with ArgTypes... yield a value that can be used as a as Boolean value
\end{itemize}
\end{itemize}

\mySamllsection{std::relation<Pred, T1, T2>}

\begin{itemize}
\item
Guarantees that any two objects of types T1 and T2 have a binary relationship in that they can be passed as arguments to the binary predicate Pred.

\item
This implies that the call changes neither the state of the passed operation nor of the passed arguments.

\item
Note that the differences to the concepts std::equivalence\_relation and std::strict\_weak\_order are purely semantic and cannot be checked at compile time. Therefore, the concept differences only document the intention.

\item
Requires:
\begin{itemize}
\item
std::predicate is satisfied for pred and any combination of two objects of types T1 and T2
\end{itemize}
\end{itemize}

\mySamllsection{std::equivalence\_relation<Pred, T1, T2}

\begin{itemize}
\item
Guarantees that any two objects of types T1 and T2 have an equivalence relationship when compared with Pred.

That is, they can be passed as arguments to the binary predicate Pred and the relationship is reflexive, symmetric, and transitive.

\item
This implies that the call changes neither the state of the passed operation nor of the passed arguments.

\item
Note that the differences to the concepts std::relation and std::strict\_weak\_order are purely semantic and cannot be checked at compile time. Therefore, the concept differences only document the intention.

\item
Requires:
\begin{itemize}
\item
std::predicate is satisfied for pred and any combination of two objects of types T1 and T2
\end{itemize}
\end{itemize}

\mySamllsection{std::strict\_weak\_order<Pred, T1, T2>}

\begin{itemize}
\item
Guarantees that any two objects of types T1 and T2 have a strict weak ordering relationship when compared with Pred.

That is, they can be passed as arguments to the binary predicate Pred and the relationship is irreflexive and transitive.

\item
This implies that the call changes neither the state of the passed operation nor of the passed arguments.

\item
Note that the differences to the concepts std::relation and std::equivalence\_relation are purely semantic and cannot be checked at compile time. Therefore, the concept differences only document the intention.

\item
Requires:
\begin{itemize}
\item
std::predicate is satisfied for pred and any combination of two objects of types T1 and T2
\end{itemize}
\end{itemize}

\mySamllsection{std::uniform\_random\_bit\_generator<Op>}

\begin{itemize}
\item
Guarantees that Op can be used as a random number generator that returns unsigned integral values of (ideally) equal probability.

\item
This concept is defined in the header file <random>.

\item
Requires:
\begin{itemize}
\item
std::invocable<Op\&> is satisfied

\item
std::unsigned\_integral is satisfied for the result of the call

\item
Expressions Op::min() and Op::max() are supported and yield the same type as the generator calls

\item
 Op::min() is less than Op::max()
\end{itemize}
\end{itemize}

\mySubsubsection{5.4.2}{Concepts for Callables Used by Iterators}

\mySamllsection{std::indirectly\_unary\_invocable<Op, Pos>}

\begin{itemize}
\item
Guarantees that Op can be called with the values that Pos refers to.

\item
Note that the difference to the concept indirectly\_regular\_unary\_invocable is purely semantic and cannot be checked at compile time. Therefore, the different concepts only document the intention.

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable<Pos> is satisfied

\item
std::copy\_constructible<Op> is satisfied

\item
std::invocable is satisfied for Op\& and the value and (common) reference type of Pos

\item
The results of calling Op with both a value and a reference have a common reference type
\end{itemize}
\end{itemize}

\mySamllsection{std::indirectly\_regular\_unary\_invocable<Op, Pos>}

\begin{itemize}
\item
Guarantees that Op can be called with the values that Pos refers to and the call does not change the state of Op.

\item
Note that the difference to the concept std::indirectly\_unary\_invocable is purely semantic and cannot be checked at compile time. Therefore, the different concepts only document the intention.

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable<Pos> is satisfied

\item
std::copy\_constructible<Op> is satisfied

\item
std::regular\_invocable is satisfied for Op\& and the value and (common) reference type of Pos

\item
The results of calling Op with both a value and a reference have a common reference type
\end{itemize}
\end{itemize}

\mySamllsection{std::indirect\_unary\_predicate<Pred, Pos>}

\begin{itemize}
\item
Guarantees that the unary predicate Pred can be called with the values that Pos refers to.

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable<Pos> is satisfied

\item
std::copy\_constructible<Pred> is satisfied

\item
std::predicate is satisfied for Pred\& and the value and (common) reference type of Pos

\item
All these calls of Pred yield a value that can be used as a Boolean value
\end{itemize}
\end{itemize}

\mySamllsection{std::indirect\_binary\_predicate<Pred, Pos1, Pos2>}

\begin{itemize}
\item
Guarantees that the binary predicate Pred can be called with the values that Pos1 and Pos2 refer to.

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable is satisfied for Pos1 and Pos2

\item
std::copy\_constructible<Pred> is satisfied

\item
std::predicate is satisfied for Pred\&, a value or (common) reference type of Pos1, and a value or (common) reference type of Pos2

\item
All these calls of Pred yield a value that can be used as a Boolean value
\end{itemize}
\end{itemize}

\mySamllsection{std::indirect\_equivalence\_relation<Pred, Pos1>, std::indirect\_equivalence\_relation<Pred, Pos1, Pos2>}

\begin{itemize}
\item
Guarantees that the binary predicate Pred can be called to check whether two values of Pos1 and Pos1/Pos2 are equivalent.

\item
Note that the difference to the concept std::indirectly\_strict\_weak\_order is purely semantic and cannot be checked at compile time. Therefore, the different concepts only document the intention.

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable is satisfied for Pos1 and Pos2

\item
std::copy\_constructible<Pred> is satisfied

\item
std::predicate is satisfied for Pred\&, a value or (common) reference type of Pos1, and a value or (common) reference type of Pos2

\item
All these calls of Pred yield a value that can be used as a Boolean value
\end{itemize}
\end{itemize}

\mySamllsection{std::indirect\_strict\_weak\_order<Pred, Pos1>, std::indirect\_strict\_weak\_order<Pred, Pos1, Pos2>}

\begin{itemize}
\item
Guarantees that the binary predicate Pred can be called to check whether two values of Pos1 and Pos1/Pos2 have a strict weak order.

\item
Note that the difference to the concept std::indirectly\_equivalence\_relation is purely semantic and cannot be checked at compile time. Therefore, the different concepts only document the intention.

\item
Requires:
\begin{itemize}
\item
std::indirectly\_readable is satisfied for Pos1 and Pos2

\item
std::copy\_constructible<Pred> is satisfied

\item
std::predicate is satisfied for Pred\&, a value or (common) reference type of Pos1, and a value or (common) reference type of Pos2

\item
All these calls of Pred yield a value that can be used as a Boolean value
\end{itemize}
\end{itemize}










