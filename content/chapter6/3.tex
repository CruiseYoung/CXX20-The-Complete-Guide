
如前所述，视图是轻量级范围，可以用作构建块来处理其他范围和视图的所有或部分元素的(修改过的)值。

C++20提供了几个标准视图，可以用来将一个范围转换为一个视图，或者将一个视图转换为一个范围/视图，其中元素可以以各种方式修改:

\begin{itemize}
\item
过滤元素

\item
生成转换后的元素值

\item
修改迭代元素的顺序

\item
拆分或合并范围
\end{itemize}

此外，还有一些视图本身产生值。

对于几乎每一种视图类型，都有一个相应的定制点对象(通常是函数对象)，其允许开发者通过调用函数来创建视图。若函数从传递的范围中创建视图，则这样的函数对象称为范围适配器。若函数在不传递现有范围的情况下创建视图，则称为范围工厂。大多数情况下，这些函数对象具有不带\_view后缀的视图名，但一些更通用的函数对象可能会根据传递的参数创建不同的视图。这些函数对象都定义在特殊的命名空间std::views中，这命名空间std::ranges::views的别名。

表“源视图”列出了C++ 0中从外部资源创建视图或生成值的标准视图，这些视图可以作为视图管道中的起始构建块。还可以查看哪些范围适配器或工厂可以创建它们(若有的话)，若可用，更推荐使用它们，而非原始视图类型。

若没有另行指定，适配器和工厂在名称空间std::视图中可用，视图类型在名称空间std::范围中可用。std::string\_view已经在C++17中引入。所有其他视图都是在C++20中引入的，通常以\_view结尾。唯一不以\_view结尾的视图类型是std::subange和std::span。

表“适配视图”列出了C++20中处理范围和其他视图的范围适配器和标准视图，可以作为视图管道中的任何地方的构建块，包括在视图的开头。同样，更推荐使用它们。

所有视图都提供了具有恒定复杂性的移动(和可选的复制)操作(这些操作所需的时间与元素的数量无关)[原始C++20标准还要求视图具有具有恒定复杂性的默认构造函数和析构函数，但这些要求后来被\url{http://wg21.link/P2325R3}和\url{http://wg21.link/p2415r2}删除了]。概念std::ranges::视图检查相应的需求。

范围工厂/适配器all()、counts()和common()将在一个特殊的章节中描述，所有视图类型以及其他适配器和工厂的详细信息将在视图类型细节一章中描述。

\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{适配器/工厂} &
\textbf{类型} &
\textbf{效果} \\ \hline
\endfirsthead
%
\endhead
%
all(rg) &
\begin{tabular}[c]{@{}l@{}}种类:\\ rg的类型\\ ref\_view\\ owning\_view\end{tabular} &
\begin{tabular}[c]{@{}l@{}}生成的范围rg是视图\\ - 若已经是视图，则返回rg\\ - 若rg是左值，则返回ref\_view\\ - 若rg是右值，则返回一个owning\_view\end{tabular} \\ \hline
counted(beg, sz) &
\begin{tabular}[c]{@{}l@{}}种类:\\ std::span\\ 子范围\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Yields a view from a begin iterator and a count\\ - Yields a span if rg is contiguous and common\\ - Yields a subrange otherwise(if valid)\end{tabular} \\ \hline
iota(val) &
iota\_view &
Yields an endless view with an incrementing sequence of values starting with val \\ \hline
iota(val, endVal) &
iota\_view &
Yields a view with an incrementing sequence of values from val up to (but not including) endVal \\ \hline
single(val) &
signle\_view &
Yields a view with val as the only element \\ \hline
\begin{tabular}[c]{@{}l@{}}empty\textless{}T\textgreater\\ -\end{tabular} &
\begin{tabular}[c]{@{}l@{}}empty\_view\\ basic\_istream\_view\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Yields an empty view of elements of type T\\ Yields a view that reads Ts elements of type T\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}istream\textless{}T\textgreater{}(s)\\ -\\ -\\ -\\ -\end{tabular} &
\begin{tabular}[c]{@{}l@{}}istream\_view\\ wistream\_view\\ std::basic\_string\_view\\ std::span\\ subrange\end{tabular} &
\begin{tabular}[c]{@{}l@{}}Yields a view that reads Ts from char stream s\\ Yields a view that reads Ts from wchar\_t stream s\\ Yields a read-only view to a character array\\ Yields a view to elements in contiguous memory\\ Yields a view for a begin iterator and a sentinel\end{tabular} \\ \hline
\end{longtable}

\begin{center}
Table 6.3. Source views
\end{center}

\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{Adaptor} & \textbf{Type}   & \textbf{Effect}                                       \\ \hline
\endfirsthead
%
\endhead
%
take(num)        & Varies          & The frist(up to) num elements                         \\ \hline
take\_while(pred)                    & take\_while\_view & All leading elements that match a predicate                        \\ \hline
drop(num)        & Varies          & All except the first num elements                     \\ \hline
drop\_while(pred)                    & drop\_while\_view & All except leading elements that match a predicate                 \\ \hline
filter(pred)     & filter\_view    & All elements that match a predicate                   \\ \hline
transform(func)  & transform\_view & The transformed values of all elements                \\ \hline
elements\textless{}idx\textgreater{} & elements\_view    & the idxth member/attribute of all elements                         \\ \hline
keys             & elements\_view  & The first member of all elements                      \\ \hline
values           & elements\_view  & The second member of all elements                     \\ \hline
reverse          & Varies          & All elements in reverse order                         \\ \hline
join             & join\_view      & All elements of a range of multiple ranges            \\ \hline
split(sep)       & split\_view     & All elements of a range split info multiple ranges    \\ \hline
lazy\_split(sep)                     & lazy\_split\_view & All elements of an input or const range split into multiple ranges \\ \hline
common           & Varies          & All elements with same type for iterator and sentinel \\ \hline
\end{longtable}

\begin{center}
Table 6.4. Adapting views
\end{center}

\mySubsubsection{6.3.1}{Views on Rangess}

Containers and strings are not views. This is because they are not lightweight enough: they provide no cheap copy constructors because they have to copy the elements.

However, you can easily use containers as views:

\begin{itemize}
\item
You can explicitly convert a container to a view by passing it to the range adaptor std::views::all().

\item
You can explicitly convert elements of a container to a view by passing a begin iterator and an end (sentinel) or a size to a std::ranges::subrange or std::views::counted().

\item
You can implicitly convert a container to a view by passing it to one of the adapting views. These views usually take a container by converting it implicitly to a view.
\end{itemize}

Usually, the latter option is and should be used. There are multiple ways of implementing this option. For example, you have the following options for passing a range coll to a take view:

\begin{itemize}
\item
You can pass the range as a parameter to the constructor of the view:

\begin{cpp}
std::ranges::take_view first4{coll, 4};
\end{cpp}

\item
You can pass the range as a parameter to the corresponding adaptor:

\begin{cpp}
auto first4 = std::views::take(coll, 4);
\end{cpp}

\item
You can pipe the range into the corresponding adaptor:

\begin{cpp}
auto first4 = coll | std::views::take(4);
\end{cpp}
\end{itemize}

In any case, the view first4 iterates over only the first four elements of coll (or fewer if there are not enough elements). However, what happens exactly here depends on what coll is:

\begin{itemize}
\item
If coll is already a view, take() just takes the view as it is.

\item
If coll is a container, take() uses a view to the container that is automatically created with the adaptor std::views::all(). This adaptor yields a ref\_view that refers to all elements of the container if the container is passed by name (as an lvalue).

\item
If an rvalue is passed (a temporary range such as a container returned by a function or a container marked with std::move()), the range is moved into an owning\_view, which then holds a range of the passed type with all moved elements directly.[The support of temporary objects (rvalues) for views was added after C++20 was published with \url{http://wg21.link/p2415r2}.]
\end{itemize}

For example:

\begin{cpp}
std::vector<std::string> coll{"just", "some", "strings", "to", "deal", "with"};

auto v1 = std::views::take(coll, 4); // iterates over a ref_view to coll

auto v2 = std::views::take(std::move(coll), 4); // iterates over an owning_view
// to a local vector<string>

auto v3 = std::views::take(v1, 2); // iterates over v1
\end{cpp}

In all cases, std::views::take() creates a new take view that finally iterates over the values initialized in coll. However, the resulting types and exact behavior differ as follows:

\begin{itemize}
\item
v1 is a take\_view<ref\_view<vector<string>{}>{}>.

Because we pass the container coll as lvalue (named object), the take view iterates over a ref view to the container.

\item
v2 is a take\_view<owning\_view<vector<string>{}>{}>.

Because we pass coll as an rvalue (temporary object or object marked with std::move()), the take view iterates over an owning view that holds its own vector of strings move-initialized with the passed collection.

\item
v3 is a take\_view<take\_view<ref\_view<vector<string>{}>{}>{}>.

Because we pass the view v1, the take view iterates over this view. The effect is that we finally iterate over coll (for which the elements were moved away with the second statement, so do not do that after the second statement).
\end{itemize}

Internally, the initialization uses the deduction guides and the type utility std::views::all\_t<>, which is explained later in detail.

Note that this behavior allows a range-based for loop to iterate on temporary ranges:

\begin{cpp}
for (const auto& elem : getColl() | std::views::take(5)) {
	std::cout << "- " << elem << '\n';
}

for (const auto& elem : getColl() | std::views::take(5) | std::views::drop(2)) {
	std::cout << "- " << elem << '\n';
}
\end{cpp}

This is remarkable, because in general, it is a fatal runtime error to use a reference to a temporary as a collection a range-based for loop iterates over (a bug that the C++ standards committee has not been willing to fix for years now; see \url{http://wg21.link/p2012}). Because passing a temporary range object (rvalue) moves the range into an owning\_view, the view does not refer to an external container and therefore there is no runtime error.

\mySubsubsection{6.3.2}{Lazy Evaluation}

It is important to understand when exactly views are processed. Views do not start processing when they are defined; instead, they run on demand:

\begin{itemize}
\item
If we need the next element of a view, we compute which one it is by performing the necessary iteration(s).

\item
If we need the value of an element of a view, we compute its value by performing the defined transformation(s).
\end{itemize}

Consider the following program:

\filename{ranges/filttrans.cpp}

\begin{cpp}
#include <iostream>
#include <vector>
#include <ranges>
namespace vws = std::views;

int main()
{
	std::vector<int> coll{ 8, 15, 7, 0, 9 };
	
	// define a view:
	auto vColl = coll
				| vws::filter([] (int i) {
					std::cout << " filter " << i << '\n';
					return i % 3 == 0;
				})
				| vws::transform([] (int i) {
					std::cout << " trans " << i << '\n';
					return -i;
				});
				
	// and use it:
	std::cout << "*** coll | filter | transform:\n";
	for (int val : vColl) {
		std::cout << "val: " << val << "\n\n";
	}
}
\end{cpp}

We define a view vColl that only filters and transforms the elements of the range coll:

\begin{itemize}
\item
By using std::views::filter(), we process only those elements that are a multiple of 3.

\item
By using std::views::transform(), we negate each value.
\end{itemize}

The program has the following output:

\begin{shell}
*** coll | filter | transform:
filter 8
filter 15
trans 15
val: -15

filter 7
filter 0
trans 0

val: 0
filter 9
trans 9
val: -9
\end{shell}

First, note that neither filter() nor transform() are called when or after we define the view vColl. The processing starts when we use the view (here: iterating over vColl). This means that views use lazy evaluation. A view is just the description of a processing. The processing is performed when we need the next element or value.

Let us assume that we do the iteration over vColl more manually, calling begin() and ++ to get the next value and * to get its value:

\begin{cpp}
std::cout << "pos = vColl.begin():\n";
auto pos = vColl.begin();
std::cout << "*pos:\n";
auto val = *pos;
std::cout << "val: " << val << "\n\n";

std::cout << "++pos:\n";
++pos;
std::cout << "*pos:\n";
val = *pos;
std::cout << "val: " << val << "\n\n";
\end{cpp}

For this code, we get the following output:

\begin{shell}
pos = vColl.begin():
filter 8
filter 15
*pos:
trans 15
val: -15

++pos:
filter 7
filter 0
*pos:
trans 0
val: 0
\end{shell}

Let us look at what happens step by step:

\begin{itemize}
\item
When we call begin(), the following happens:

\begin{itemize}
\item
The request to get the first element of vColl is passed to the transform view, which passes it to the filter view, which passes it to coll, which yields an iterator to the first element 8.

\item
The filter view looks at the value of the first element and rejects it. As a consequence, it asks coll for the next element by calling ++ there. The filter gets the position of the second element 15 and passes its position to the transform view.

\item
As a result, pos is initialized as an iterator with the position to the second element.
\end{itemize}

\item
When calling *pos, the following happens:

\begin{itemize}
\item
Because we need the value, the transform view is now called for the current element and yields its negated value.

\item
As a result, val is initialized with the negated value of the current element.
\end{itemize}

\item
When calling ++pos, the same happens again:

\begin{itemize}
\item
The request to get the next element is passed to the filter, which passes the request to coll until an element fits (or we are at the end of coll).

\item
As a result, pos gets the position of the fourth element.
\end{itemize}

\item
By calling *pos again, we perform the transformation and yield the next value for the loop.
\end{itemize}

This iteration continues until the range or one of the views signals that we are at the end.

This pull model has a big benefit: we do not process elements that we never need. For example, assume that we use the view to find the first resulting value that is 0:

\begin{cpp}
std::ranges::find(vColl, 0);
\end{cpp}

The output would then be only:

\begin{shell}
filter 8
filter 15
trans 15
filter 7
filter 0
trans 0
\end{shell}

Another benefit of the pull model is that sequences or pipelines of views can even operate on infinite ranges. We do not compute an unlimited number of values not knowing how many are used; we compute as many values as requested by the user of the view.

\mySubsubsection{6.3.3}{Caching in Views}

Assume that we want to iterate over a view multiple times. It seems a waste of performance if we compute the first valid element again and again. And indeed, views that might skip leading elements cache the begin() once it is called.

Let us change the program above so that it iterates twice over the elements of the view vColl:

\filename{ranges/filttrans2.cpp}

\begin{cpp}
#include <iostream>
#include <vector>
#include <ranges>
namespace vws = std::views;

int main()
{
	std::vector<int> coll{ 8, 15, 7, 0, 9 };
	// define a view:
	auto vColl = coll
	| vws::filter([] (int i) {
		std::cout << " filter " << i << '\n';
		return i % 3 == 0;
	})
	| vws::transform([] (int i) {
		std::cout << " trans " << i << '\n';
		return -i;
	});
	
	// and use it:
	std::cout << "*** coll | filter | transform:\n";
	for (int val : vColl) {
		...
	}
	std::cout << "-------------------\n";
	
	// and use it again:
	std::cout << "*** coll | filter | transform:\n";
	for (int val : vColl) {
		std::cout << "val: " << val << "\n\n";
	}
}
\end{cpp}

The program has the following output:

\begin{shell}
*** coll | filter | transform:
filter 8
filter 15
trans 15
filter 7
filter 0
trans 0
filter 9
trans 9
-------------------
*** coll | filter | transform:
trans 15
val: -15

filter 7
filter 0
trans 0
val: 0

filter 9
trans 9
val: -9
\end{shell}

As you can see, when used for the second time, calling vColl.begin() no longer tries to find the first element because it was cached with the first iteration over the elements of the filter.

Note that this caching of begin() has good and bad and maybe unexpected consequences. First, it is better to initialize a caching view once and use it twice:

\begin{cpp}
// better:
auto v1 = coll | std::views::drop(5);
check(v1);
process(v1);
\end{cpp}

than to initialize and use it twice:

\begin{cpp}
// worse:
check(coll | std::views::drop(5));
process(coll | std::views::drop(5));
\end{cpp}

In addition, modifying leading elements of ranges (changing their value or inserting/deleting elements) may invalidate views if and only if begin() has already been called before the modification.

That means:

\begin{itemize}
\item
If we do not call begin() before a modification, the view is usually valid and works fine when we use it later:

\begin{cpp}
std::list coll{1, 2, 3, 4, 5};
auto v = coll | std::views::drop(2);
coll.push_front(0); // coll is now: 0 1 2 3 4 5
print(v); // initializes begin() with 2 and prints: 2 3 4 5
\end{cpp}

\item
However, if we do call begin() before the modification (e.g., by printing the elements), we can easily get wrong elements. For example:

\begin{cpp}
std::list coll{1, 2, 3, 4, 5};
auto v = coll | std::views::drop(2);
print(v); // init begin() with 3
coll.push_front(0); // coll is now: 0 1 2 3 4 5
print(v); // begin() is still 3, so prints: 3 4 5
\end{cpp}

Here, begin() is cached as an iterator so that the view no longer operates on all elements of the underlying range if new elements are added to or removed from the range.

However, we might also get invalid values. For example:

\begin{cpp}
std::vector vec{1, 2, 3, 4};

auto biggerThan2 = [](auto v){ return v > 2; };
auto vVec = vec | std::views::filter(biggerThan2);

print(vVec); // OK: 3 4

++vec[1];
vec[2] = 0; // vec becomes 1 3 0 4

print(vVec); // OOPS: 0 4;
\end{cpp}

\end{itemize}

Note that this means that an iteration, even if it only reads, may count as a write access. Therefore, iterating over the elements of a view might invalidate a later use if its referred range has been modified in the meantime.

The effect depends on when and how caching is done. See the remarks about caching views in their specific sections:

\begin{itemize}
\item
Filter views, which cache begin() as an iterator or offset

\item
Drop views, which cache begin() as an iterator or offset

\item
Drop-while views, which cache begin() as an iterator or offset

\item
Reverse views, which cache begin() as an iterator or offset
\end{itemize}

Here, you see again that C++ cares about performance:

\begin{itemize}
\item
Caching at initialization time would have unnecessary performance cost if we never iterate over the elements of a view at all.

\item
Not caching at all would have unnecessary performance cost if we iterate a second or more times over the elements of the view (applying a reverse view over a drop-while view might even have quadratic complexity in some cases).
\end{itemize}

However, due to caching, using a view not ad hoc can have pretty surprising consequences. Care must be taken when modifying ranges used by views.

As another consequence, caching might require that a view cannot be const while iterating over its elements. The consequences are even more severe and are discussed later.

\mySubsubsection{6.3.4}{Performance Issues with Filters}

The pull model also has its drawbacks. To demonstrate that, let us change the order of the two views involved (above) so that we first call transform() and then filter():

\filename{ranges/transfilt.cpp}

\begin{cpp}
#include <iostream>
#include <vector>
#include <ranges>
namespace vws = std::views;

int main()
{
	std::vector<int> coll{ 8, 15, 7, 0, 9 };
	
	// define a view:
	auto vColl = coll
	| vws::transform([] (int i) {
		std::cout << " trans: " << i << '\n';
		return -i;
	})
	| vws::filter([] (int i) {
		std::cout << " filt: " << i << '\n';
		return i % 3 == 0;
	});
	
	// and use it:
	std::cout << "*** coll | transform | filter:\n";
	for (int val : vColl) {
	std::cout << "val: " << val << "\n\n";
	}
}
\end{cpp}

Now, the output of the program is as follows:

\begin{shell}
*** coll | transform | filter:
trans: 8
filt: -8
trans: 15
filt: -15
trans: 15
val: -15

trans: 7
filt: -7
trans: 0
filt: 0
trans: 0
val: 0

trans: 9
filt: -9
trans: 9
val: -9
\end{shell}

We have additional calls of the transform view:

\begin{itemize}
\item
We now call transform() for each element.

\item
For elements that pass the filter, we even perform the transformation twice.
\end{itemize}

Calling the transformation for each element is necessary because the filter view comes afterwards and now looks at the transformed values. In this case, the negation does not impact the filter; therefore, putting it to the front looks better.

However, why do we call the transformations for elements that pass the filter twice? The reason lies in the nature of a pipeline that uses the pull model and the fact that we use iterators.

\begin{itemize}
\item
First, the filter needs the transformed value to check it; therefore, the leading transformation has to be performed before the filter can use the resulting value.
	
\item
Remember that ranges and views iterate in two steps over the elements of a range: they first compute the position/iterator (with begin() and ++), and then as a separate step, use * to get the value. This means that for each filter, we have to perform all previous transformations once to be able check the value of the element. However, if true, the filter delivers only the position of the element, not its value. Therefore, when a user of the filter needs the value, it has to perform the transformations once again.
\end{itemize}

In fact, each filter adds one more call of all leading transformations on each element that pass the filter and for which the value is used afterwards.

Given the following pipeline of transformations t1, t2, t3 and filters f1, f2:

\begin{cpp}
t1 | t2 | f1 | t3 | f2
\end{cpp}

we have the following behavior:

\begin{itemize}
\item
For elements where f1 yields false, we call:

\begin{cpp}
t1 t2 f1
\end{cpp}

\item
For elements where f1 yields true but f2 yields false, we call:

\begin{cpp}
t1 t2 f1 t1 t2 t3 f2
\end{cpp}

\item
For elements where f1 and f2 yield true, we call:

\begin{cpp}
t1 t2 f1 t1 t2 t3 f2 t1 t2 t3
\end{cpp}
\end{itemize}

See ranges/viewscalls.cpp for a complete example.

If this makes you worry about the performance of pipelines, take the following into account: yes, you should avoid expensive transformations before you use a filter. However, remember that all views provide functionality that is usually optimized in such a way that only the expressions inside the transformations and filters remain. In trivial cases such as the one here, where a filter checks for a multiple of 3 and the transformation negates, the resulting difference in behavior is effectively like calling

\begin{cpp}
if (-x % 3 == 0) return -x; // first transformation then filter
\end{cpp}

instead of

\begin{cpp}
if (x % 3 == 0) return -x; // first filter then transformation
\end{cpp}

For more details about filters, see the section about the filter view.
