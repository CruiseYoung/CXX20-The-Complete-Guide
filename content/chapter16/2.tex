

模块的目的是处理分布在多个文件上的大量代码。模块可用于包装由2个、10个甚至100个文件组成的小型、中型和超大型组件的代码。这些文件甚至可能由多个开发者和团队提供和维护。

为了演示这种方法的可扩展性及其好处，现在来看一下如何使用多个文件来定义可以被其他代码使用/导入的模块。示例的代码大小仍然很小，通常不会将其分散到多个文件中。我们的目标是用非常简单的示例来演示这些特性。

\mySubsubsection{16.2.1}{模块单元}

通常，模块由多个模块单元组成。模块单元是属于一个模块的翻译单元。

所有模块单元都必须以某种方式编译，只包含声明(传统代码中的头文件)，也需要进行某种预编译。因此，这些文件总可转换成某种特定于平台的内部格式，以避免不得不一次又一次地(预)编译相同的代码。

除了主要的模块接口单元，C++还提供了另外三种单元类型来将模块的代码拆分为多个文件:

\begin{itemize}
\item 
模块实现单元允许开发者在自己的文件中实现定义，这样就可以单独编译(类似于传统的C++源代码在.cpp文件中)。

\item 
内部分区允许开发者在单独的文件中提供仅在模块内可见的声明和定义。

\item 
接口分区甚至允许开发者将导出的模块API拆分为多个文件。
\end{itemize}

下一节将通过示例介绍这些额外的模块单元。

\mySubsubsection{16.2.2}{使用已实现的单元}

The first example of a module that is implemented in multiple files demonstrates how to split definitions (such as function implementations) to avoid having them in one file. The usual motivation for this is to be able to compile the definitions separately.

This can be done by using module implementations (the official name is module implementation units). They are handled like traditional source files that are compiled separately.

Let us look at an example.

\mySamllsection{带有全局模块片段的主接口}

As usual, first we need the primary interface that defines what we export:

\filename{modules/mod1/mod1.cppm}

\begin{cpp}
module; // start module unit with global module fragment

#include <string>
#include <vector>

export module Mod1; // module declaration

struct Order {
	int count;
	std::string name;
	double price;
	
	Order(int c, const std::string& n, double p)
	: count{c}, name{n}, price{p} {
	}
};

export class Customer {
private:
	std::string name;
	std::vector<Order> orders;
public:
	Customer(const std::string& n)
	: name{n} {
	}
	void buy(const std::string& ordername, double price) {
		orders.push_back(Order{1, ordername, price});
	}
	void buy(int num, const std::string& ordername, double price) {
		orders.push_back(Order{num, ordername, price});
	}
	double sumPrice() const;
	double averagePrice() const;
	void print() const;
};
\end{cpp}

This time, the module starts with module; to signal that we have a module. That way we can use some preprocessor commands within modules:

\begin{cpp}
module; // start module unit with global module fragment

#include <iostream>
#include <string>
#include <vector>

export module Mod1; // module declaration
...
\end{cpp}

The area between module; and the module declaration is called the global module fragment. You can use it to place preprocessor commands like \#define and \#include. Nothing within this area is exported (no macros, no declarations, no definitions).

Nothing else can be done before we formally start the module unit with its declaration (except comments, of course):

\begin{cpp}
export module mod1; // module declaration
\end{cpp}

The things defined in this module are:

\begin{itemize}
\item 
An internal data structure Order:

\begin{cpp}
struct Order {
	...
};
\end{cpp}

This data structure is for order entries. Each entry holds information about how many items were ordered, their name, and their price. The constructor ensures that we initialize all members.

\item 
A class customer, which we export:

\begin{cpp}
export class Customer {
	...
};
\end{cpp}
\end{itemize}

As you can see, we need the header files and the internal data structure Order to define the class Customer. However, by not exporting them, they cannot be used directly by code that imports this module.

For the class Customer, the member functions averagePrice(), sumPrice(), and print() are only declared. Here, we use the feature to define them in module implementation units.

\mySamllsection{模块实现单元}

A module may have any number of implementation units. In our example, we provide two of them: one to implement numeric operations and one to implement I/O operations.

The module implementation unit for numeric operations looks as follows:

\filename{modules/mod1/mod1price.cpp}

\begin{cpp}
module Mod1; // implementation unit of module Mod1

double Customer::sumPrice() const
{
	double sum = 0.0;
	for (const Order& od : orders) {
		sum += od.count * od.price;
	}
	return sum;
}

double Customer::averagePrice() const
{
	if (orders.empty()) {
		return 0.0;
	}
	return sumPrice() / orders.size();
}
\end{cpp}

The file is a module implementation unit because it starts with a declaration stating that this is a file of module Mod1:

\begin{cpp}
module Mod1;
\end{cpp}

This declaration imports the primary interface unit of the module (but nothing else). Thus, the declarations of types Order and Customer are known and we can provide implementations of their member functions directly.

Note that a module implementation unit does not export anything. export is allowed only in interface files of modules (primary interface or interface partition), which are declared with export module (and remember that only one primary interface is allowed per module).

Again, a module implementation unit may start with a global module fragment, which we can see in the module implementation unit for I/O:

\filename{modules/mod1/mod1io.cpp}

\begin{cpp}
module; // start module unit with global module fragment

#include <iostream>
#include <format>

module Mod1; // implementation unit of module Mod1

void Customer::print() const
{
	// print name:
	std::cout << name << ":\n";
	// print order entries:
	for (const auto& od : orders) {
		std::cout << std::format("{:3} {:14} {:6.2f} {:6.2f}\n",
								  od.count, od.name, od.price, od.count * od.price);
	}
	// print sum:
	std::cout << std::format("{:25} ------\n", ' ');
	std::cout << std::format("{:25} {:6.2f}\n", " Sum:", sumPrice());
}
\end{cpp}

Here, we introduce the module with module; to have a global module fragment for the header files that we use in the implementation unit. <format> is the header file of the new formatting library.

As you can see, module implementation units use the file extension of traditional C++ translation units (most of the time .cpp). Compilers deal with them just like any other non-module C++ code.

\mySamllsection{使用模块}

The code using the module looks as follows:

\filename{modules/mod1/testmod1.cpp}

\begin{cpp}
#include <iostream>

import Mod1;

int main()
{
	Customer c1{"Kim"};
	
	c1.buy("table", 59.90);
	c1.buy(4, "chair", 9.20);
	
	c1.print();
	std::cout << " Average: " << c1.averagePrice() << '\n';
}
\end{cpp}

Here, we use the exported class Customer from the primary interface to create a customer, place some orders, print the customer with all orders, and print the value of the average order.

The program has the following output:

\begin{shell}
Kim:
  1 table        59.90   59.90
  4 chair         9.20   36.80
                        ------
    Sum:                 96.70
Average: 48.35
\end{shell}

Note that any attempt to use type Order in the code that imports the module results in a compile-time error.

Note also that the use of the module does not depend on how many implementation units we have. The number of implementation units matters only in that the linker has to use all object files generated for them.

\mySubsubsection{16.2.3}{内部分区}

In the previous example, we introduced a data structure Order that is only used within the module. It looks like we have to declare it in the primary interface to make it available to all implementation units, which of course does not really scale in large projects. With internal partitions, you can declare and define internal types and functions of a module in separate files. Note that partitions can also be used to define parts of an exported interface in a separate file, which we will discuss later.

Note that internal partitions are sometimes called partition implementation units, which is based on the fact that in the C++20 standard, they are officially called “module implementation units that are module partitions” and that sounds like they provide the implementations of interface partitions. They do not. They just act like internal header files for a module and may provide both declarations and definitions.

\mySamllsection{定义内部分区}

Using an internal partition, we can define the local type Order in its own module unit as follows:

\filename{modules/mod2/mod2order.cppp}

\begin{cpp}
module; // start module unit with global module fragment

#include <string>

module Mod2:Order; // internal partition declaration

struct Order {
	int count;
	std::string name;
	double price;
	
	Order(int c, const std::string& n, double p)
		: count{c}, name{n}, price{p} {
	}
};
\end{cpp}

As you can see, a partition has the name of the module, then a colon, and then its partition name:

\begin{cpp}
module Mod2:Order;
\end{cpp}

Sub-partitions such as Mod2:Order:Main are not supported.

You might again recognize that the file uses another new file extension: .cppp, which we will discuss later after looking at its contents.

The primary interface has to import this partition by only using the name :Order:

\filename{modules/mod2/mod2.cpp}

\begin{cpp}
module; // start module unit with global module fragment

#include <string>
#include <vector>

export module Mod2; // module declaration

import :Order; // import internal partition Order

export class Customer {
private:
	std::string name;
	std::vector<Order> orders;
public:
	Customer(const std::string& n)
	: name{n} {
	}
	void buy(const std::string& ordername, double price) {
		orders.push_back(Order{1, ordername, price});
	}
	void buy(int num, const std::string& ordername, double price) {
		orders.push_back(Order{num, ordername, price});
	}
	double sumPrice() const;
	double averagePrice() const;
};
\end{cpp}

The primary interface has to import the internal partition because it uses type Order. With that import, the partition is available in all units of the module. If the primary interface does not need type Order and does not import the internal partition, all module units that need type Order would have to import the internal partition directly.

Again, note that partitions are only an internal implementation aspect of a module. For the user of the code, it does not matter whether code is in the primary module, its implementation, or in an internal partition. However, code from internal partitions cannot be exported.

\mySubsubsection{16.2.4}{分区的接口}

You can also split the interface of a module into multiple files. In that case, you declare interface partitions, which themselves export whatever should be exported.

Interface partitions are especially useful if modules provide multiple interfaces that are maintained by different programmers and/or teams. For simplicity, let us just use the current example to demonstrate how to use this feature by defining only the Customer interface in a separate file.

To define only the Customer interface, we can provide the following file:

\filename{modules/mod3/mod3customer.cppm}

\begin{cpp}
module; // start module unit with global module fragment

#include <string>
#include <vector>

export module Mod3:Customer; // interface partition declaration

import :Order; // import internal partition to use Order

export class Customer {
private:
	std::string name;
	std::vector<Order> orders;
public:
	Customer(const std::string& n)
	: name{n} {
	}
	void buy(const std::string& ordername, double price) {
		orders.push_back(Order{1, ordername, price});
	}
	void buy(int num, const std::string& ordername, double price) {
		orders.push_back(Order{num, ordername, price});
	}
	double sumPrice() const;
	double averagePrice() const;
	void print() const;
};
\end{cpp}

The partition is more or less the former primary interface with one difference:

\begin{itemize}
\item 
As a partition, we declare its name after the module name and a colon: Mod3:Customer
\end{itemize}

Like the primary interface:

\begin{itemize}
\item 
We export this module partition:

\begin{cpp}
export module Mod3:Customer;
\end{cpp}

\item 
We use the new file extension .cppm, which we will again discuss later
\end{itemize}

The primary interface is still the only place to specify what a module exports. However, the primary module can delegate exports to the interface partition. The way to do that is to export the imported interface partition directly as a whole:

\filename{modules/mod3/mod3.cppm}

\begin{cpp}
export module Mod3; // module declaration

export import :Customer; // import and export interface partition Customer
... // import and export other interface partitions
\end{cpp}

By importing the interface partition and exporting it at the same time (yes, you have to write both keywords), the primary interface exports the interface of the partition Customer as its own interface:

\begin{cpp}
export import :Customer; // import and export partition Customer
\end{cpp}

Importing an interface partition without exporting it is not allowed.

Again, note that partitions are only an internal implementation aspect of a module. It does not matter whether interfaces and implementations are provided in partitions. Partitions do not create a new scope.

Therefore, for the implementation of the member functions of Customer, moving the declaration of the class to a partition does not matter. You implement a member function of the class Customer as part of the module Mod3:

\filename{modules/mod3/mod3io.cppm}

\begin{cpp}
module; // start module unit with global module fragment

#include <iostream>
#include <vector>
#include <format>

module Mod3; // implementation unit of module Mod3

import :Order; // import internal partition to use Order

void Customer::print() const
{
	// print name:
	std::cout << name << ":\n";
	// print order entries:
	for (const Order& od : orders) {
		std::cout << std::format("{:3} {:14} {:6.2f} {:6.2f}\n",
								   od.count, od.name, od.price, od.count * od.price);
	}
	// print sum:
	std::cout << std::format("{:25} ------\n", ' ');
	std::cout << std::format("{:25} {:6.2f}\n", " Sum:", sumPrice());
}
\end{cpp}

However, there is one difference in this implementation unit: because the primary interface no longer imports the internal partition :Order, this module has to do so because it uses type Order.

For code that imports the module, the way the code is distributed internally also does not matter. We still export the class Customer in the global scope:

\filename{modules/mod3/testmod3.cpp}

\begin{cpp}
#include <iostream>

import Mod3;

int main()
{
	Customer c1{"Kim"};
	
	c1.buy("table", 59.90);
	c1.buy(4, "chair", 9.20);
	
	c1.print();
	std::cout << " Average: " << c1.averagePrice() << '\n';
}
\end{cpp}


\mySubsubsection{16.2.5}{将模块拆分到不同文件的总结}

The examples in this section demonstrate how you can deal with modules of increasing code size so that splitting the code is helpful or even necessary to “tame the beast:”

\begin{itemize}
\item 
Module implementation units allow projects to split definitions into multiple files so that the source code can be maintained by different programmers and you do not have to recompile all code if local things change.

\item 
Internal partitions allow projects to move module-local declarations and definitions outside the primary interface. They can be imported by the primary interface or only by the module units that need them.

\item 
Interface partitions allow projects to maintain exported interfaces in different files. This usually makes sense if the exported API becomes so big that it helps to have different files (and therefore teams) to work on parts of it.
\end{itemize}

The primary interface brings everything together and specifies what is exported to the users of the module (by directly exporting symbols or exporting imported interface partitions).

The kind of module unit we have depends on the module declaration within a C++ source file (which can come after comments and a global module fragment for preprocessor commands):

\begin{itemize}
\item 
export module name; 

identifies the primary interface. For each module, it may exist only once in a C++ program.

\item 
module name; 

identifies an implementation unit providing just a definition (which might use local declarations). You can have as many of them as you like.

\item 
module name:partname; 

identifies an internal partition with declarations and definitions used only within the module. You can have multiple partitions, but for each partname, you can have only one internal partition file.

\item 
export module name:partname; 

identifies an interface partition. You can have multiple interface partitions, but for each partname, you can have only one interface partition file.
\end{itemize}

Because we have no standard suffixes for the different module units, tools have to parse the beginning of the C++ source files to detect whether and which kind of a module unit they are. Note that the module declaration might occur after comments and the global module fragment. See clmod.py in \url{http://github.com/josuttis/cppmodules} for a Python script that demonstrates how this might look.






