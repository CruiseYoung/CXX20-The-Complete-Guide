
除了在编译时使用堆内存的能力之外，编译时函数(无论是用constexpr还是consteval声明)自C++20以来还可以使用一些额外的语言特性，所以现在还可以在编译时使用一些库特性。

\mySubsubsection{18.6.1}{constexpr的语言扩展}

自C++20起，以下语言特性可以在编译时函数中使用(无论是用constexpr还是consteval声明):

\begin{itemize}
\item
现在可以在编译时使用堆内存。

\item
支持运行时多态性:

\begin{itemize}
\item
可以使用虚函数。

\item
可以使用dynamic\_cast。

\item
可以使用typeid。
\end{itemize}

\item
现在可以使用try-catch语句块了(但仍然不允许抛出异常)。

\item
现在可以更改联合的活动成员。
\end{itemize}

注意，仍然不允许在constexpr或consteval函数中使用static。

\mySubsubsection{18.6.2}{constexpr的库扩展}

C++标准库扩展了可以在编译时使用的工具。

\mySamllsection{constexpr算法和工具}

<algorithm>、<numeric>和<utility>中的大多数算法现在都是constexpr。所以，现在可以在编译时对元素进行排序和累加(参见在编译时使用vector的示例)。

然而，并行算法(具有执行策略参数的算法)仍然只能在运行时使用。

\mySamllsection{constexpr的库类型}

几种类型的C++标准库现在更好地支持constexpr，以便在编译时可以(更好地)使用对象:

\begin{itemize}
\item
vector和字符串现在可以在编译时使用。

\item
一些std::complex<>操作变成了constexpr。

\item
std::optional<>和std::variant<>中添加了两个缺失的constexpr。

\item
constexpr添加到std::invoke()，std::ref()，std::cref()，mem\_fn()，not\_fn()，std::bind()和std::bind\_front()中，

\item
pointer\_traits中，用于原始指针的pointer\_to()现在可以在编译时使用。
\end{itemize}
















