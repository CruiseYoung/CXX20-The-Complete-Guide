

This section discusses some additional aspects of modules for using them in practice.


\mySubsubsection{16.3.1}{Dealing with Module Files with Different Compilers}

In C++, extensions are not standardized. In practice, different file extensions are used (usually .cpp and .hpp, but also .cc, .cxx, .C, .hh, .hxx, .H, and even .h are used).

We also have no standard extension for modules. Even worse, we do not even agree on whether new extensions are necessary (yet). In principle, there are two approaches:

\begin{itemize}
\item 
Compilers should consider all kinds of module files as ordinary C++ source files and find out how to handle them based on their content. With this approach, all files still have the extension .cpp. gcc/g++ follows this policy.
 
\item 
Compilers treat (some) module files differently as they can be both files for declarations (traditional header files) and files with definitions (traditional source files). While there is no doubt that it helps tremendously to have different suffixes for that reason, compilers might even indirectly require different suffixes to avoid having to use different command-line options for the same extensions. Visual C++ follows this approach.
\end{itemize}

Therefore, different file extensions are recommended for module files in practice by different compilers (.cppm, .ixx, and .cpp), which is one reason why using modules in practice is still challenging.

I thought about this for a while and tried things out and discussed the situation with the people in the standards committee, but so far, there seems to be no compelling solution. Formally, the C++ standard does not standardize the way source code is handled (the code might not even be stored in files). This has the consequence that there is no easy way to write even a simple portable first example using modules.

Therefore, let me suggest something here so that you can at least try modules out on different platforms: 

There are multiple reasons why different file extensions seem to be necessary:

\begin{itemize}
\item 
Compilers require different command-line options for dealing with different types of module files.

\item 
Similar to header files, you have to provide some of the module files to customers and third-party code.

\item 
Different module files create different artifacts, which you might have to deal with (e.g., when removing the generated artifacts).
\end{itemize}

Personally, I have no final decision and recommendation for file extensions of module files yet. However, given the current situation, I recommend the following:

\begin{itemize}
\item 
For interface files (both primary interfaces and interface partitions), use the file extension .cppm. The reasons are:

\begin{itemize}
\item 
It is the best self-explanatory file extension (far better than .ixx as currently recommended by Visual C++).

\item 
This is what Clang currently requires.

\item 
It can be used by gcc.

\item 
Visual C++ requires special treatment anyway, unless you use the extension .ixx.
\end{itemize}


\item 
For module implementation files (but not partition implementation files), use the usual file extension .cpp. The reasons are:

\begin{itemize}
\item 
No special artifacts are generated.

\item 
No special command-line options are required.
\end{itemize}

\item 
For internal partition files (partition implementation files), use the file extension .cppp. The reasons are:

\begin{itemize}
\item 
Visual C++ requires the command-line option /internalPartition for these files. The file suffix does not matter. Therefore, you have to use a special suffix to have a chance of a generic rule in build systems that do not want to parse the file contents.

\item 
It can be used by gcc.

\item 
Currently, Clang does not support these files at all (September 2021)
\end{itemize}

The way Microsoft handles internal partitions is really counter-productive for the success of modules and I hope they will fix the need for a specific suffix as soon as possible.

\end{itemize}

As a consequence, you have to (pre)compile module files as follows:

\begin{itemize}
\item 
Visual C++:

Visual C++ requires specific command-line extensions and prefers a different file extension .ixx than the one I propose. For this reason:

\begin{itemize}
\item 
Compile an interface file file.cppm as follows:

\begin{shell}
cl /TP /interface /c file.cppm
\end{shell}

The option /TP specifies that all following files contain C++ source code. Alternatively, you can use /Tpfile.cppm. The option /interface specifies that all following files are interface files (having both interface and non-interface files on one command-line might not work).

If you use the file extension .ixx instead, the compiler recognizes the file automatically as an interface file.

\item 
Compile an internal partition file file.cppp as follows:


\begin{shell}
cl /Tp /internalPartition /c file.cppp
\end{shell}

The option /internalPartition specifies that all following files are internal partitions. Note that having both internal partition and interface files on one command-line is not supported. There is no specific suffix you can use instead; internal partitions always need this option.
\end{itemize}

The fact that Visual C++ currently recommends different file suffixes and requires specific commandline options for specific module units makes the use of modules both cumbersome and non-portable. To circumvent the restrictions of Visual C++ (at least when you compile via command line), I have provided the Python script clmod.py, which you can find at \url{http://github.com/josuttis/cppmodules}. I hope Microsoft will fix their flaws so that this workaround is no longer necessary.

\item 
gcc/g++:

gcc does not require any special file extension or command-line option at all. Therefore, by using special file extensions, you only have to specify that the files contain C++ code using the command-line option -xc++:

\begin{itemize}
\item 
Compile an interface file file.cppm as follows:

\begin{shell}
g++ -xc++ -c file.cppm
\end{shell}

\item
Compile an internal partition file file.cppp as follows:

\begin{shell}
g++ -xc++ -c file.cppp
\end{shell}
\end{itemize}

\item 
Clang:

Clang currently supports only interface files. As the proposed extension .cppm is required for them anyway, using it should work.

However, you cannot use internal partition files.
\end{itemize}


\mySubsubsection{16.3.2}{Dealing with Header Filess}

While in theory modules could replace all traditional header files with all their flaws, in practice this will never happen. There will be header files from code and libraries developed for C++ (and C) that do not require the use of modules. This will be the case especially because the use of a precompiler makes compiling and linking C++ programs more complex. Therefore, modules should be able to deal with traditional header files.

The basic approach for using traditional header files is to use the global module fragment.

\begin{itemize}
\item 
Start your module with module;

\item 
Then, place all necessary preprocessor commands before you come to the module declaration
\end{itemize}

In that case:

\begin{itemize}
\item 
Everything not used from the header file included will be discarded.

\item 
Everything used will get module linkage, which means that it is visible only throughout the module unit but neither in other module units nor outside the module.

\item 
A \#define before the \#include is honored.
\end{itemize}

For example:

\begin{cpp}
module;

#include <string>
#define NDEBUG
#include <cassert>

export module ModTest;
...
void foo(std::string s) {
	assert(s.empty()); // valid but not checked
	...
}
\end{cpp}

With this global module fragment, the preprocessor symbol NDEBUG and the macro assert() from <cassert> are defined within this module unit. However, due to NDEBUG, any runtime check with assert() is disabled.

Both NDEBUG and assert() are not visible in other units of this module or imported modules.

After the declaration of a module, \#include is no longer supported. Other preprocessor commands such as \#define and \#ifdef can be used.

\mySamllsection{import for Header Files}

The future goal is to have the whole C++ standard library available as modules. However, for the standard C++ header files, it is already possible to use import, which then can be used within a module. For example:

\begin{cpp}
export module ModTest;

import <chrono>;
\end{cpp}

That command is a shortcut for declaring and importing a module with everything from the corresponding header file exported. Even macros are visible within this module with this import (with all other imports, they are not).

However, constants that are defined before the import with \#define are not passed to the imported header file. That way, we can guarantee that the content of the imported header file is always the same so that the header file can be precompiled.

Note that this feature is only guaranteed to work on standard C++ headers. It also does not apply to a standard C header adopted by C++:

\begin{cpp}
export module ModTest;

import <chrono>; // OK
import <cassert>; // ERROR (or at least not portable)
\end{cpp}

Platforms are also allowed to support this feature for other header files; however, code using this feature is not portable.

\mySamllsection{Standard Modules}

C++20 just introduces the technology. It does not introduce any standard modules (one reason is that the standards committee wants to reorganize the symbols over different modules to clean up some of the historic mess with header files).

It looks like with C++23, there will be two standard modules (see \url{http://wg21.link/p2465})

\begin{itemize}
\item 
std will provide everything in the namespace std from C++ headers, including those that wrap C (e.g., std::sort(), std::ranges::sort(), std::fopen(), and ::operator new).

No macros and no feature test macros are provided. For them, you have to include <cassert> or <version> yourself.

\item 
std.compat will provide everything from the module std plus the counterparts of C symbols from C headers (e.g., ::fopen()).
\end{itemize}

Note that std and every module name starting with std is reserved by the C++ standard for its standard modules.













