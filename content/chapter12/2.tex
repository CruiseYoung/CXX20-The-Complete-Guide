
C++20 provides stop tokens not only for threads. It is a general-purpose mechanism to asynchronously request to stop with various ways to react to this request.

The basic mechanism is as follows:

C++20 provides stop tokens not only for threads. It is a general-purpose mechanism to asynchronously request to stop with various ways to react to this request.

The basic mechanism is as follows:

\begin{itemize}
\item 
The C++20 standard library allows us to establish a shared stop state. By default, a stop is not signaled.

\item 
Stop sources of type std::stop\_source can request a stop in their associated shared stop state.

\item 
Stop tokens of type std::stop\_token can be used to react to a stop request in their associated shared stop state. You can actively poll whether there is a stop requested or register a callback of type std::stop\_callback, which will be called when a stop is/was requested.

\item 
Once a stop request has been made, it cannot be withdrawn (a subsequent stop request has no effect).

\item 
Stop sources and stop tokens can be copied and moved around to allow code to signal or react to a stop at multiple locations. Copying a source or token is relatively cheap so you usually pass them by value to avoid any lifetime issues.

However, copying is not as cheap as passing an integral value or raw pointer around. It is more like passing a shared pointer. If you frequently pass them to a sub-function, it might be better to pass them by reference.

\item 
The mechanism is thread safe and can be used in concurrent situations. Stop requests, checks for requested stops, and calls to register or unregister callbacks are properly synchronized, and the associated shared stop state is automatically destroyed when the last user (stop source, stop token, or stop callback) is destroyed.
\end{itemize}

The following example shows how to establish both a stop source and a stop token:

\begin{cpp}
#include <stop_token>
...

// create stop_source and stop_token:
std::stop_source ssrc; // creates a shared stop state
std::stop_token stok{ssrc.get_token()}; // creates a token for the stop state
\end{cpp}

The first step is simply to create the stop\_source object, which provides the API to request a stop. The constructor also creates the associated shared stop state. Then, you can ask the stop source for the stop\_token object, which provides the API to react to a stop request (by polling or registering callbacks).

You can then pass the token (and/or the source) to locations/threads to establish the asynchronous communication between the places that might request a stop and those that might react to a stop.

There is no other way to create a stop token with an associated shared stop state. The default constructor of a stop token has no associated stop state.

\mySubsubsection{12.2.1}{Stop Sources and Stop Tokens in Detail}


Let us look at the APIs of stop sources, stop tokens, and stop callbacks in detail. All types are declared in the header file <stop\_token>.

\mySamllsection{Stop Sources in Detail}

Table Operations of objects of class stop\_source lists the API of std::stop\_source.

The constructor usually allocates memory on the heap for the stop state, which is used by all stop tokens and stop callbacks. There is no way to specify a different location with an allocator.

Note that there are no lifetime constraints between stop sources, stop tokens, and stop callbacks. The memory for the stop state is automatically released when the last stop source, stop token, or stop callback using this state is destroyed.

To enable you to create stop sources with no associated stop state (which might be useful because the stop state needs resources), you can create a stop source with a special constructor and assign a stop source later:

\begin{cpp}
std::stop_source ssrc{std::nostopstate}; // no associated shared stop state
...
ssrc = std::stop_source{}; // assign new shared stop state
\end{cpp}


\mySamllsection{Stop Tokens in Detail}

Table Operations of objects of class stop\_token lists the API of std::stop\_token.

Note that stop\_possible() yields false signals whether stops can still occur. It yields false in two situations:

\begin{itemize}
\item 
If there is no associated stop state

\item 
If there is a stop state, but there is no longer a stop source and a stop was never requested
\end{itemize}

This can be used to avoid defining reactions to stops that can never occur.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation}            & \textbf{Effect}                                                                     \\ \hline
\endfirsthead
%
\endhead
%
stop\_source s                & Default constructor; creates a stop source with associated stop state               \\ \hline
stop\_source s\{nostopstate\} & Creates a stop source with no associated stop state                                 \\ \hline
stop\_source s\{s2\}          & Copy constructor;creates a stop source that shares the associated stop state of s2  \\ \hline
stop\_source s\{move(s2)\} &
Move constructor;creates a stop source that gets the associated stop state of s2(s2 no longer has an associated stop state) \\ \hline
s.$\sim$stop\_source()        & Destructor;destorys the associated shared stop state if this is the last user of it \\ \hline
s = s2 &
Copy assignment;copy assigns the state of s2 so that s now also shares the stop state of s2(any former stop state of s is released) \\ \hline
s = move(s2) &
Move assignment;move assigns the state of s2 so that s now shares the stop state of s2(s2 no longer has a stop state and any former stop state of s is released) \\ \hline
s.get\_token() &
Yields a stop\_token for the associated stop state(returns a stop token with no associated stop state if there is no stop state to share) \\ \hline
s.request\_stop() &
Requests a stop on the associated stop state if any of it is not done yet(returns whether a stop was requested) \\ \hline
s.stop\_possible()            & Yields whether s has an associated stop state                                       \\ \hline
s.stop\_requested()           & Yields whether s has an associated stop state for which a stop was requested        \\ \hline
s1 == s2                      & Yields whether s1 and s2 share the same stop state (or both share none)             \\ \hline
s1 != s2                      & Yields whether s2 and s2 do not share the same stop state                           \\ \hline
s1.swap(s2)                   & Swaps the states of s1 and s2                                                       \\ \hline
swap(s1, s2)                  & Swaps the states of s1 and s2                                                       \\ \hline
\end{longtable}

\begin{center}
Table 12.2. Operations of objects of class stop\_source
\end{center}

\mySubsubsection{12.2.2}{Using Stop Callbacks}

A stop callback is an object of the RAII type std::stop\_callback. The constructor registers a callable (function, function object, or lambda) to be called when a stop is requested for a specified stop token:

\begin{cpp}
void task(std::stop_token st)
{
	// register temporary callback:
	std::stop_callback cb{st, []{
			std::cout << "stop requested\n";
			...
	}};
	...
} // unregisters callback
\end{cpp}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation}     & \textbf{Effect}                                                                          \\ \hline
\endfirsthead
%
\endhead
%
stop\_token t          & Default constructor; creates a stop token with no associated stop state                  \\ \hline
stop\_token t\{t2\}    & Copy constructor; creates a stop token that shares the associated stop state of t2       \\ \hline
stop\_token t\{move(t2)\} &
Move constructor; creates a stop token that gets the associated stop state of t2(t2 no longer has an associated stop state) \\ \hline
t.$\sim$stop\_token()  & Destructor;destroys the associated shared stop state if this is the last user of it      \\ \hline
t = t2 &
Copy assignment; copy assigns the state of t2 so that t now also shares the stop state of t2(any former stop state of t is released) \\ \hline
t = move(t2) &
Move assignment; move assigns the state of t2 so that t now shares the stop state of t2(t2 no longer has a stop state and any former stop state of t is released) \\ \hline
t.stop\_possible()     & Yields whether t has an associated stop state and a stop was or can (still) be requested \\ \hline
t.stop\_requested()    & Yields whether t has an associated stop state for which a stop was requested             \\ \hline
t1 == t2               & Yields whether t1 and t2 share the same stop state (or both share none)                  \\ \hline
t1 != t2               & Yields whether t1 and t2 do not share the same stop state                                \\ \hline
t1.swap(t2)            & Swaps the states of t1 and t2                                                            \\ \hline
swap(t1. t2)           & Swaps the states of t1 and t2                                                            \\ \hline
stop\_token cb\{t, f\} & Registers cb as stop callback of t calling f                                             \\ \hline
\end{longtable}

\begin{center}
Table 12.3. Operations of objects of class stop\_token
\end{center}

Assume we have created the shared stop state and create an asynchronous situation where one thread might request a stop and another thread might run task(). We might create this situation with code like the following:

\begin{cpp}
// create stop_source with associated stop state:
std::stop_source ssrc;

// register/start task() and pass the corresponding stop token to it:
registerOrStartInBackgound(task, ssrc.get_token());
...
\end{cpp}

The function registerOrStartInBackgound() could start task() immediately, or start task() later by calling std::async() or initializing a std::thread, call a coroutine, or register an event handler.

Now, whenever we request a stop:

\begin{cpp}
ssrc.request_stop();
\end{cpp}

one of the following things can happen:

\begin{itemize}
\item 
If task() has been started with its callback was initialized, is still running, and the destructor of the callback has not been called yet, the registered callable is called immediately in the thread where request\_stop() was called. request\_stop() blocks until all registered callables have been called. The order of the calls is not defined.

\item
If task() has not been started (or its callback has not been initialized yet), request\_stop() changes the stop state to signal that a stop was requested and returns. If task() is started later and the callback is initialized, the callable is called immediately in the thread where the callback is initialized. The constructor of the callback blocks until the callable returns.

\item
If task() has already finished (or at least the destructor of the callback has been called), the callable will never be called. The end of the lifetime of the callback signals that there is no longer a need to call the callable.
\end{itemize}

These scenarios are carefully synchronized. If we are in the middle of initializing a stop\_callback so that the callable is registered, one of the above scenarios will happen. The same applies if a stop is requested while a callable is being unregistered due to destroying a stop callback. If the callable has already been started by another thread, the destructor blocks until the callable has finished.

For your programming logic, this means that from the moment you initialize the callback until the end of its destruction, the registered callable might be called. Up to the end of the constructor, the callback runs in the thread of the initialization; afterwards it runs in the thread requesting the stop. The code that requests a stop might immediately call the registered callable, it might call it later (if the callback is initialized later), or might never call it (if it is too late to call the callback).

For example, consider the following program:

\filename{lib/stop.cpp}

\begin{cpp}
#include <iostream>
#include <stop_token>
#include <future> // for std::async()
#include <thread> // for sleep_for()
#include <syncstream> // for std::osyncstream
#include <chrono>
using namespace std::literals; // for duration literals

auto syncOut(std::ostream& strm = std::cout) {
	return std::osyncstream{strm};
}

void task(std::stop_token st, int num)
{
	auto id = std::this_thread::get_id();
	syncOut() << "call task(" << num << ")\n";
	
	// register a first callback:
	std::stop_callback cb1{st, [num, id]{
		syncOut() << "- STOP1 requested in task(" << num
			<< (id == std::this_thread::get_id() ? ")\n"
												: ") in main thread\n");
	}};
	std::this_thread::sleep_for(9ms);
	
	// register a second callback:
	std::stop_callback cb2{st, [num, id]{
		syncOut() << "- STOP2 requested in task(" << num
			<< (id == std::this_thread::get_id() ? ")\n"
												: ") in main thread\n");
	}};
	std::this_thread::sleep_for(2ms);
}
	
int main()
{
	// create stop_source and stop_token:
	std::stop_source ssrc;
	std::stop_token stok{ssrc.get_token()};
	
	// register callback:
	std::stop_callback cb{stok, []{
			syncOut() << "- STOP requested in main()\n" << std::flush;
	}};

	// in the background call task() a bunch of times:
	auto fut = std::async([stok] {
							for (int num = 1; num < 10; ++num) {
								task(stok, num);
							}
						});
	
	// after a while, request stop:
	std::this_thread::sleep_for(120ms);
	ssrc.request_stop();
}
\end{cpp}

Note that we use synchronized output streams to ensure that the print statements of the different threads are synchronized line by line.

For example, the output might be as follows:

\begin{shell}
call task(1)
call task(2)
...
call task(7)
call task(8)
- STOP2 requested in task(8) in main thread
- STOP1 requested in task(8) in main thread
- STOP requested in main()
call task(9)
- STOP1 requested in task(9)
- STOP2 requested in task(9)
\end{shell}


Or it might also be like this:

\begin{shell}
call task(1)
call task(2)
call task(3)
call task(4)
- STOP2 requested in task(4) in main thread
call task(5)
- STOP requested in main()
- STOP1 requested in task(5)
- STOP2 requested in task(5)
call task(6)
- STOP1 requested in task(6)
- STOP2 requested in task(6)
call task(7)
- STOP1 requested in task(7)
- STOP2 requested in task(7)
...
\end{shell}

Or it might look like this:

\begin{shell}
call task(1)
call task(2)
call task(3)
call task(4)
- STOP requested in main()
call task(5)
- STOP1 requested in task(5)
- STOP2 requested in task(5)
call task(6)
- STOP1 requested in task(6)
- STOP2 requested in task(6)
...
\end{shell}

It might even just be:

\begin{shell}
call task(1)
call task(2)
...
call task(8)
call task(9)
- STOP requested in main()
\end{shell}

Without using syncOut(), the output might even have interleaved characters because the output from the main thread and the thread running task() might be completely mixed.

\mySamllsection{Stop Callbacks in Detail}

The type of stop callback, stop\_callback, is a class template with a very limited API. Effectively, it only provides a constructor to register a callable for a stop token and a destructor that unregisters the callable. Copying and moving are deleted and no other member function is provided.

The template parameter is the type of the callable and is usually deduced when the constructor is initialized:

\begin{cpp}
auto func = [] { ... };

std::stop_callback cb{myToken, func}; // deduces stop_callback<decltype(func)>
\end{cpp}

The only public member besides constructor and destructor is callback\_type, which is the type of the stored callable.

The constructors accept both lvalues (objects with a name) and rvalues (temporary objects or objects marked with std::move()):

\begin{cpp}
auto func = [] { ... };

std::stop_callback cb1{myToken, func}; // copies func
std::stop_callback cb2{myToken, std::move(func)}; // moves func
std::stop_callback cb3{myToken, [] { ... }}; // moves the lambda
\end{cpp}

\mySubsubsection{12.2.3}{Constraints and Guarantees of Stop Tokens}

The feature to deal with stop requests is pretty robust regarding a couple of scenarios that might occur in asynchronous contexts. However, it cannot avoid every pitfall.

The C++20 standard library guarantees the following:

\begin{itemize}
\item 
All request\_stop(), stop\_requested(), and stop\_possible() calls are synchronized.

\item 
The callback registration is guaranteed to be performed atomically. If there is a concurrent call to request\_stop() from another thread, then either the current thread will see the request to stop and immediately invoke the callback on the current thread, or the other thread will see the callback registration and will invoke the callback before returning from request\_stop().

\item 
The callable of a stop\_callback is guaranteed not to be called after the destructor of the stop\_callback returns.

\item 
The destructor of a callback waits for its callable to finish if it is just called by another thread (it does not wait for other callables to finish).
\end{itemize}

However, note the following constraints:

\begin{itemize}
\item 
A callback should not throw. If an invocation of its callable exits via an exception, then std::terminate() is called.

\item 
Do not destroy a callback in its own callable. The destructor does not wait for the callback to finish.
\end{itemize}
