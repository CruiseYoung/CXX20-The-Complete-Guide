

Requires expressions (which are distinct from requires clauses) provide a simple but flexible syntax for specifying multiple requirements on one or multiple template parameters. You can specify:

\begin{itemize}
\item
Required type definitions

\item
Expressions that have to be valid

\item
Requirements on the types that expressions yield
\end{itemize}

A requires expression starts with requires followed by an optional parameter list and then a block of requirements (all ending with semicolons). For example:

\begin{cpp}
template<typename Coll>
... requires {
		typename Coll::value_type::first_type; // elements/values have first_type
		typename Coll::value_type::second_type; // elements/values have second_type
	}
\end{cpp}

The optional parameter list allows you to introduce a set of “dummy variables” that can be used to express requirements in the body of the requires expression:

\begin{cpp}
template<typename T>
... requires(T x, T y) {
		x + y; // supports +
		x - y; // supports -
	}
\end{cpp}

These parameters are never replaced by arguments. Therefore, it usually does not matter whether you declare them by value or by reference.

The parameters also allow us to introduce (parameters of) sub-types:

\begin{cpp}
template<typename Coll>
... requires(Coll::value_type v) {
		std::cout << v; // supports output operator
	}
\end{cpp}

This requirements checks whether Coll::value\_type is valid and whether objects of this type support the output operator.

Note that type members in this parameter list do not have to be qualified with typename.

When using this to check only whether Coll::value\_type is valid, you do not need anything in the body of the block of the requirements. However, the block cannot be empty. Therefore, you could simply use true in that case:

\begin{cpp}
template<typename Coll>
... requires(Coll::value_type v) {
		true; // dummy requirement because the block cannot be empty
	}
\end{cpp}

\subsubsection*{\zihao{3} 4.4.1\hspace{0.2cm}Simple Requirements}
\addcontentsline{toc}{subsubsection}{4.4.1\hspace{0.2cm}Simple Requirements}

Simple requirements are just expressions that have to be well-formed. This means that the calls have to compile. The calls are not performed, meaning that it does not matter what the operations yield.

For example:

\begin{cpp}
template<typename T1, typename T2>
... requires(T1 val, T2 p) {
		*p; // operator* has to be supported for T2
		p[0]; // operator[] has to be supported for int as index
		p->value(); // calling a member function value() without arguments has to be possible
		*p > val; // support the comparison of the result of operator* with T1
		p == nullptr; // support the comparison of a T2 with a nullptr
	}
\end{cpp}

The last call does not require that p is the nullptr (to require that, you have to check whether T2 is type std::nullptr\_t). Instead, we require that we can compare an object of type T2 with nullptr.

It usually does not make sense to use the operator ||. A simple requirement such as

\begin{cpp}
*p > val || p == nullptr;
\end{cpp}

does not require that either the left or the right sub-expression is possible. It formulates the requirement that we can combine the results of both sub-expressions with the operator ||.

To require either one of the two sub-expressions, you have to use:

\begin{cpp}
template<typename T1, typename T2>
... requires(T1 val, T2 p) {
		*p > val; // support the comparison of the result of operator* with T1
	}
	|| requires(T2 p) { // OR
		p == nullptr; // support the comparison of a T2 with nullptr
	}
\end{cpp}

Note also that this concept does not require that T is an integral type:

\begin{cpp}
template<typename T>
... requires {
		std::integral<T>; // OOPS: does not require T to be integral
		...
	};
\end{cpp}

The concept requires only that the expression std::integral<T> is valid, which is the case for all types. The requirements that T is integral you have to formulate as follows:

\begin{cpp}
template<typename T>
... std::integral<T> && // OK, does require T to be integral
	requires {
		...
	};
\end{cpp}

Alternatively, as follows:

\begin{cpp}
template<typename T>
... requires {
		requires std::integral<T>; // OK, does require T to be integral
		...
	};
\end{cpp}

\subsubsection*{\zihao{3} 4.4.2\hspace{0.2cm}Type Requirements}
\addcontentsline{toc}{subsubsection}{4.4.2\hspace{0.2cm}Type Requirements}

Type requirements are expressions that have to be well-formed when using a name of a type. This means that the specified name has to be defined as a valid type.

For example:

\begin{cpp}
template<typename T1, typename T2>
... requires {
	typename T1::value_type; // type member value_type required for T1
	typename std::ranges::iterator_t<T1>; // iterator type required for T1
	typename std::common_type_t<T1, T2>; // T1 and T2 have to have a common type
}
\end{cpp}

For all type requirements, if the type exists but is void, then the requirement is met.

Note that you can only check for names given to types (names of classes, enumeration types, from typedef or using). You cannot check for other type declarations using the type:

\begin{cpp}
template<typename T>
... requires {
	typename int; // ERROR: invalid type requirement
	typename T&; // ERROR: invalid type requirement
}
\end{cpp}

The way to test the latter is to declare a corresponding parameter:

\begin{cpp}
template<typename T>
... requires(T&) {
	true; // some dummy requirement
};
\end{cpp}

Again, the requirement checks whether using the passed type(s) to define another type is valid. For example:

\begin{cpp}
template<std::integral T>
class MyType1 {
	...
};

template<typename T>
requires requires {
	typename MyType1<T>; // instantiation of MyType1 for T would be valid
}
void mytype1(T) {
	...
}

mytype1(42); // OK
mytype1(7.7); // ERROR
\end{cpp}

Therefore, the following requirement does not check whether there is a standard hash function for type T:

\begin{cpp}
template<typename T>
concept StdHash = requires {
	typename std::hash<T>; // does not check whether std::hash<> is defined for T
};
\end{cpp}

The way to require a standard hash function is to try to create or use it:

\begin{cpp}
template<typename T>
concept StdHash = requires {
	std::hash<T>{}; // OK, checks whether we can create a standard hash function for T
};
\end{cpp}

Note that simple requirements check only whether a requirement is valid, not whether it is fulfilled. For this reason:

\begin{itemize}
\item
It does not make sense to use type functions that always yield a value:

\begin{cpp}
template<typename T>
... requires {
	std::is_const_v<T>; // not useful: always valid (doesn’t matter what it yields)
}
\end{cpp}

To check for constness, use:

\begin{cpp}
template<typename T>
... std::is_const_v<T> // ensure that T is const
\end{cpp}

Inside a requires expression, you can use a nested requirement (see below).

\item
It does not make sense to use type functions that always yield a type:

\begin{cpp}
template<typename T>
... requires {
	typename std::remove_const_t<T>; // not useful: always valid (yields a type)
}
\end{cpp}

The requirement checks only whether the type expression yields a type, which is always the case.
\end{itemize}

It also does not make sense to use type functions that may have undefined behavior. For example, the type trait std::make\_unsigned<> requires that the passed argument is an integral type other than bool. If the passed type is not an integral type, you get undefined behavior. Therefore, you should not use std::make\_unsigned<> as requirement without constraining the type you call it for:

\begin{cpp}
template<typename T>
... requires {
	std::make_unsigned<T>::type; // not useful as type requirement (valid or undefined behavior)
}
\end{cpp}

In this case, the requirement can only be fulfilled or results in undefined behavior (which might mean that the requirement is still fulfilled). Instead, you should also constrain the type T for which you can use a nested requirement:

\begin{cpp}
template<typename T>
... requires {
	requires (std::integral<T> && !std::same_as<T, bool>);
	std::make_unsigned<T>::type; // OK
}
\end{cpp}


\subsubsection*{\zihao{3} 4.4.3\hspace{0.2cm}Compound Requirements}
\addcontentsline{toc}{subsubsection}{4.4.3\hspace{0.2cm}Compound Requirements}

Compound requirements allow us to combine the abilities of simple and type requirements. In this case, you can specify an expression (inside a block of braces) and then add one or both of the following:

\begin{itemize}
\item
noexcept to require that the expression guarantees not to throw

\item
-> type-constraint to apply a concept on what the expression evaluates to
\end{itemize}

Here are some examples:

\begin{cpp}
template<typename T>
... requires(T x) {
	{ &x } -> std::input_or_output_iterator;
	{ x == x };
	{ x == x } -> std::convertible_to<bool>;
	{ x == x }noexcept;
	{ x == x }noexcept -> std::convertible_to<bool>;
}
\end{cpp}

Note that the type constraint after the -> takes the resulting type as its first template argument. That means:

\begin{itemize}
\item
In the first requirement, we require that the concept std::input\_or\_output\_iterator is satisfied when using operator\& for an object of type T (std::input\_or\_output\_iterator<decltype(\&x)> yields true).

You could also specify this as follows:

\begin{cpp}
{ &x } -> std::is_pointer_v<>;
\end{cpp}

\item
In the last requirement, we require that we can use the result of operator== for two objects of type T as bool (the concept std::convertible\_to is satisfied when passing the result of operator== for two objects of type T and bool as arguments).
\end{itemize}

Requires expressions can also express the need for associated types. For example:

\begin{cpp}
template<typename T>
... requires(T coll) {
	{ *coll.begin() } -> std::convertible_to<T::value_type>;
}
\end{cpp}

However, you cannot specify type requirements using nested types. For example, you cannot use them to require that the return value of calling the operator * yields an integral value. The problem is that the return value is a reference that you have to dereference first:

\begin{cpp}
std::integral<std::remove_reference_t<T>>
\end{cpp}

and you cannot use such a nested expression with a type trait in a result of a requires expression:

\begin{cpp}
template<typename T>
concept Check = requires(T p) {
	{ *p } -> std::integral<std::remove_reference_t<>>; // ERROR
	{ *p } -> std::integral<std::remove_reference_t>; // ERROR
};
\end{cpp}

You either have to define a corresponding concept first:

\begin{cpp}
template<typename T>
concept UnrefIntegral = std::integral<std::remove_reference_t<T>>;

template<typename T>
concept Check = requires(T p) {
	{ *p } -> UnrefIntegral; // OK
};
\end{cpp}

Alternatively, you have to use a nested requirement.

\subsubsection*{\zihao{3} 4.4.4\hspace{0.2cm}Nested Requirements}
\addcontentsline{toc}{subsubsection}{4.4.4\hspace{0.2cm}Nested Requirements}

Nested requirements can be used to specify additional constraints inside a requires expression. They start with requires followed by a compile-time Boolean expression, which might itself again be or use a requires expression. The benefit of nested requirements is that we can ensure that a compile-time expression (that uses parameters or sub-expressions of the requires expression) yields a certain result instead of ensuring only that the expression is valid.

For example, consider a concept that has to ensure that both the operator * and the operator [] yield the same type for a given type. By using nested requirements, we can specify this as follows:

\begin{cpp}
template<typename T>
concept DerefAndIndexMatch = requires (T p) {
								requires std::same_as<decltype(*p),
										decltype(p[0])>;
							};
\end{cpp}

The good thing is that we have an easy syntax here for “assume we have an object of type T.” We do not have to use a requires expression here; however, the code then has to use std::declval<>():

\begin{cpp}
template<typename T>
concept DerefAndIndexMatch = std::same_as<decltype(*std::declval<T>()),
			 decltype(std::declval<T>()[0])>;
\end{cpp}

As another example, we can use a nested requirement to solve the problem just introduced to specify a complex type requirement on an expression:

\begin{cpp}
template<typename T>
concept Check = requires(T p) {
	requires std::integral<std::remove_cvref_t<decltype(*p)>>;
};
\end{cpp}

Note the following difference inside a requires expression:

\begin{cpp}
template<typename T>
... requires {
	!std::is_const_v<T>; // OOPS: checks whether we can call is_const_v<>
	requires !std::is_const_v<T>; // OK: checks whether T is not const
}
\end{cpp}

Here, we use the type trait is\_const\_v<> without and with requires. However, only the second requirement is useful:

\begin{itemize}
\item
The first expression requires only that checking for constness and negating the result is valid. This requirement is always met (even if T is const int) because doing this check is always valid. This requirement is worthless.

\item
The second expression with requires has to be fulfilled. The requirement is met if T is int but not if T is const int.
\end{itemize}

