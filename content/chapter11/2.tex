chrono库的设计是为了能够处理计时器和时钟在不同系统上可能不同的事实，并随着时间的推移提高精度。为了避免每10年左右引入一个新的时间类型，C++11建立的基本目标是通过分离时间段和时间点(“时间点”)来提供一个精度中立的概念。C++20扩展了这些基本概念，支持日期和时区，以及其他的一些扩展。

因此，chrono库的核心由以下类型或概念组成:

\begin{itemize}
\item 
时间段定义为一个时间单位上的特定时标的数量。一个例子是时间段，如“3分钟”(“分钟”的3个刻度)。其他例子是“42毫秒”或“86400秒”，表示1天的时间段。这种方法还允许指定类似于“1.5乘以三分之一秒”的内容，其中1.5是时标的数量，“三分之一秒”是所用的时间单位。

\item
时间点定义为时间段和时间开始的组合(所谓的epoch)。

一个典型的例子是表示2000年12月31日午夜的系统时间点。因为系统纪元被指定为Unix/POSIX出生，所以时间点将被定义为“自1970年1月1日以来的946,684,800秒”(或者在考虑闰秒时为946,684,822秒，有些时间点会考虑闰秒)。

注意，epoch可能是未指定的或伪epoch。例如，本地时间点与本地时间相关联，仍然需要一个特定的epoch值，但是它所代表的确切时间点不清楚，直到将这个时间点应用到特定的时区。12月31日的午夜就是一个很好的例子:庆祝活动和烟花在世界上不同的时间开始，这取决于我们所在的时区。

\item
时钟是定义时间点的历元的对象，所以不同的时钟有不同的epoch。

每个时间点由时钟参数化。C++11引入了两个基本时钟(一个用于处理系统时间的系统时钟和一个用于测量和计时器的稳定时钟，不应受系统时钟变化的影响)。C++20增加了新的时钟来处理UTC时间点(支持闰秒)、GPS时间点、TAI(国际原子时间)时间点和文件系统时间点。

为了处理本地时间点，C++20还添加了一个伪时钟local\_t，不绑定到特定的epoch/origin。

处理多个时间点的操作，例如处理两个时间点之间的时间段/差值，通常需要使用相同的epoch/clock。然而，不同时钟之间的转换是可能的。

时钟(若不是本地的)提供了一个函数now()来生成当前时间点。

\item
日历类型(C++20中引入)允许使用日、月和年等常用术语来处理日历的属性。这些类型可用于表示日期的单个属性(日、月、年和工作日)，以及它们的组合(完整日期的year\_month或year\_month\_day)。

不同的符号(例如Wednesday、November和last)允许我们使用通用术语表示部分日期和完整日期，例如“十一月的最后一个星期三”。

可以使用系统时钟或本地时间的伪时钟，将完全指定的日历日期(具有年、月、日或月中的特定工作日)转换为时间点或从伪时间点转换为时间点。

\item
时区(C++20中引入)可以处理这样情况，当不同的时区起作用时，同时发生的事件会导致不同的时间。如果在世界标准时间18:30在线会面，会议的当地时间在亚洲将明显晚于美国，而在美国则明显早于亚洲。

因此，时区通过将时间点应用或转换为不同的本地时间来赋予时间点(不同的)含义。

\item
时区时间(C++20引入)是时间点和时区的组合，可用于将本地时间点应用于特定的时区(可能是“当前”时区)或将时间点转换为不同的时区。

时区时间可以看作是一个日期和时间对象，是epoch(时间点的origin)、duration(到origin的距离)和timezone(用于调整结果时间)的组合。
\end{itemize}

对于所有这些概念和类型，C++20增加了对输出(甚至格式化)和解析的支持。这样，就可以决定是否以如下格式输出日期/时间值:

\begin{shell}
Nov/24/2011
24.11.2011
2011-11-24 16:30:00 UTC
Thursday, November 11, 2011
\end{shell}