The basic way to formulate constraints for templates is to use a requires clause: requires followed by a Boolean expression. After requires, the constraint can use any compile-time Boolean expressions, not just concepts or requires expressions. These expressions may especially use:

\begin{itemize}
\item
Type predicates, such as type traits

\item
Compile-time variables (defined with constexpr or constinit)

\item
Compile-time functions (defined with constexpr or consteval)
\end{itemize}

Let us look at some examples of using ad-hoc Boolean expressions to restrict the availability of a template:

\begin{itemize}
\item
Available only if int and long have a different size:

\begin{cpp}
template<typename T>
requires (sizeof(int) != sizeof(long))
...
\end{cpp}

\item
Available only if sizeof(T) is not too large:

\begin{cpp}
template<typename T>
requires (sizeof(T) <= 64)
...
\end{cpp}

\item
Available only if the non-type template parameter Sz is greater than zero:

\begin{cpp}
template<typename T, std::size_t Sz>
requires (Sz > 0)
...
\end{cpp}

\item
Available only for raw pointers and the nullptr:

\begin{cpp}
template<typename T>
requires (std::is_pointer_v<T> || std::same_as<T, std::nullptr_t>)
...
\end{cpp}

std::same\_as is a new standard concept. Instead, you could also use the standard type trait std::is\_same\_v<>:

\begin{cpp}
template<typename T>
requires (std::is_pointer_v<T> || std::is_same_v<T, std::nullptr_t>)
...
\end{cpp}

\item
Available only if the argument cannot be used as a string:

\begin{cpp}
template<typename T>
requires (!std::convertible_to<T, std::string>)
...
\end{cpp}

std::convertible\_to is a new standard concept. You could also use the standard type trait std::is\_convertible\_v<>:

\begin{cpp}
template<typename T>
requires (!std::is_convertible_v<T, std::string>)
...
\end{cpp}

\item
Available only if the argument is a pointer (or pointer-like object) to an integral value:

\begin{cpp}
template<typename T>
requires std::integral<std::remove_reference_t<decltype(*std::declval<T>())>>
...
\end{cpp}

Note that operator* usually yields a reference that is not an integral type. Therefore, we do the following:

\begin{itemize}
\item
Assume we have an object of type T: std::declval<T>()

\item
Call operator* for the object: *

\item
Ask for its type: decltype()

\item
Remove referenceness: std::remove\_reference\_v<>

\item
Check whether it is an integral type: std::integral<>
\end{itemize}

This constraint would also be satisfied by a std::optional<int>.

std::integral is a new standard concept. You could also use the standard type trait std::is\_integral\_v<>.

\item
Available only if the non-type template parameters Min and Max have a greatest common divisor (GCD) that is greater than one:

\begin{cpp}
template<typename T>
constexpr bool gcd(T a, T b); // greatest common divisor (forward declaration)

template<typename T, int Min, int Max>
requires (gcd(Min, Max) > 1) // available if there is a GCD greater than 1
...
\end{cpp}

\item
Disable a template (temporarily):

\begin{cpp}
template<typename T>
requires false // disable the template
...
\end{cpp}
\end{itemize}

In non-trivial cases, you need parentheses around the whole requires expression or parts of it. You can only skip parentheses if you use only identifiers, ::, and <...> optionally combined with \&\& and ||. For example:

\begin{cpp}
requires std::convertible_to<T, int> // no parentheses needed here
		&&
		(!std::convertible_to<int, T>) // ! forces the need for parentheses
\end{cpp}


























