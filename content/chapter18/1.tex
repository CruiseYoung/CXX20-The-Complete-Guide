
One new keyword C++20 introduces is constinit. It can be used to force and ensure that a mutable static or global variable is initialized at compile time. Roughly speaking, the effect is described as:

\begin{cpp}
constinit = constexpr - const
\end{cpp}

Yes, a constinit variable is not const (it would have better to name the keyword compiletimeinit). The name comes from the fact that these initializations usually happen when compile-time constants are initialized.

You can use constinit whenever you declare a static or global variable. For example:

\begin{cpp}
// outside any function:
constinit auto i = 42;
int getNextClassId() {
	static constinit int maxId = 0;
	return ++maxId;
}

class MyType {
	static constinit long max = sizeof(int) * 1000;
	...
};

constexpr std::array<int, 5> getColl() {
	return {1, 2, 3, 4, 5};
}
constinit auto globalColl = getColl();
\end{cpp}

As written, you can still modify the declared values. The following code using the declarations above for the first time:

\begin{cpp}
std::cout << i << " " << coll[0] << '\n'; // prints 42 1
i *= 2;
coll = {};
std::cout << i << " " << coll[0] << '\n'; // prints 84 0
\end{cpp}

has the following output:

\begin{shell}
42 1
84 0
\end{shell}

The effect of using constinit is that the initialization compiles only if the initial value is a constant value known at compile time. This means that in contrast to a declaration such as:

\begin{cpp}
auto x = f(); // f() might be a runtime function
\end{cpp}

the corresponding declaration with constinit requires a compile-time initialization, meaning that it must be possible to call f() at compile time (which means f() must be constexpr or consteval).

\begin{cpp}
constinit auto x = f(); // f() must be a compile-time function
\end{cpp}

If you initialize an object with constinit, it must be possible to use the constructor at compile time:

\begin{cpp}
constinit std::pair p{42, "ok"}; // OK constinit std::list l; // ERROR: default constructor not constexpr
\end{cpp}

The reasons for using constinit are as follows:

\begin{itemize}
\item 
You can require initialization of mutable global/static objects at compile time. That way, you can avoid the initialization using runtime. In particular, this can improve performance when using thread\_local variables.

\item 
You can ensure that a global/static object is always initialized when it is used. In fact, constinit can be used to fix the static initialization order fiasco, which can occur when an initial value of a static/global object depends on another static/global object.
\end{itemize}

Note that using constinit never changes the functional behavior of a program (unless we have the static initialization order fiasco). It can only lead to the consequence that code no longer compiles.

\mySubsubsection{18.1.1}{Using constinit in Practice}

There are couple of thing to respect when using constinit.

First, you cannot initialize a constinit value with another constinit value:

\begin{cpp}
constinit auto x = f(); // f() must be a compile-time function
constinit auto y = x; // ERROR: x is not a constant initializer
\end{cpp}

The reason is that the initial value must be a constant value known at compile time, but constinit values are not constant. Only the following compiles:

\begin{cpp}
constexpr auto x = f(); // f() must be a compile-time function
constinit auto y = x; // OK
\end{cpp}

When initializing objects, a compile-time constructor is required. However, a compile-time destructor is not required. For this reason, you can use constinit for smart pointers:

\begin{cpp}
constinit std::unique_ptr<int> up; // OK
constinit std::shared_ptr<int> sp; // OK
\end{cpp}

constinit does not imply inline (this is different from constexpr). For example:

\begin{cpp}
class Type {
	constinit static int val1 = 42; // ERROR
	inline static constinit int val2 = 42; // OK
	...
};
\end{cpp}

You can use constinit together with extern:

\begin{cpp}
// header:
extern constinit int max;

// translation unit:
constinit int max = 42;
\end{cpp}

For the same effect, you can also skip constinit in the declaration. However, skipping constinit in the definition would no longer force compile-time initialization.

You can use constinit together with static and thread\_local:

\begin{cpp}
static thread_local constinit int numCalls = 0;
\end{cpp}

Any order of constinit, static, and thread\_local is fine.

Note that for thread\_local variables, using constinit might create a performance improvement, because it might avoid that the generated code needs an internal guard to signal whether the variable is already initialized:

\begin{cpp}
extern thread_local int x1 = 0;
extern thread_local constinit int x2 = 0; // better (might avoid an internal guard)
\end{cpp}

Using constinit to declare references is possible but makes no sense because the reference refers to a constant object. You should use constexpr instead.


\mySubsubsection{18.1.2}{How constinit Solves the Static Initialization Order Fiasco}

In C++, there is a problem called static initialization order fiasco, which constinit can solve. The problem is that the order of static and global initializations in different translation units is not defined. For that reason, the following code can be a problem:

\begin{itemize}
\item 
Assume we have a type with a constructor to initialize the objects and introduce an extern global object of this type:

\filename{comptime/truth.hpp}

\begin{cpp}
#ifndef TRUTH_HPP
#define TRUTH_HPP

struct Truth {
	int value;
	Truth() : value{42} { // ensure all objects are initialized with 42
	}
};
extern Truth theTruth; // declare global object

#endif // TRUTH_HPP
\end{cpp}

\item
We initialize the object in its own translation unit:

\filename{comptime/truth.cpp}

\begin{cpp}
#include "truth.hpp"

Truth theTruth; // define global object (should have value 42)
\end{cpp}

\item
And then in another translation unit, we initialize another global/static object with theTruth:

\filename{comptime/fiasco.cpp}

\begin{cpp}
#include "truth.hpp"
#include <iostream>

int val = theTruth.value; // may be initialized before theTruth is initialized

int main()
{
	std::cout << val << '\n'; // OOPS: may be 0 or 42
	++val;
	std::cout << val << '\n'; // OOPS: may be 1 or 43
}
\end{cpp}
\end{itemize}

There is a good chance that val is initialized with theTruth before theTruth itself was initialized. As a result, the program might have the following output: [For example, when using the gcc compiler, you get this effect if you pass truth.o before fiasco.o to the linker.]

\begin{shell}
0 
1
\end{shell}

When using constinit to declare val, that problem cannot occur. constinit ensures that an object is always initialized before it is used because the initialization happens at compile time. If the guarantee cannot be given, the code does not compile. Note that an initialization would also be guaranteed if val was declared with constexpr; however, in that case, you would not be able to modify the value anymore.

In our example, just using constinit would first result in a compile-time error (signaling that initialization cannot be guaranteed at compile time):

\begin{cpp}
// truth.hpp:
struct Truth {
	int value;
	Truth() : value{42} {
	}
};

extern Truth theTruth;
// main translation unit:
constinit int val = theTruth.value ; // ERROR: no constant initializer
\end{cpp}

That error message signals now at compile time that val cannot be initialized at compile time. To make the initialization valid, you have to modify the declaration of class Truth and theTruth so that theTruth can be used at compile time:

\filename{comptime/truthc.hpp}

\begin{cpp}
#ifndef TRUTH_HPP
#define TRUTH_HPP

struct Truth {
	int value;
	constexpr Truth() : value{42} { // enable compile-time initialization
	}
};

constexpr Truth theTruth; // force compile-time initialization

#endif // TRUTH_HPP
\end{cpp}

Now, the program compiles and val is guaranteed to be initialized with the initialized value of theTruth:

\filename{comptime/constinit.hpp}

\begin{cpp}
#include "truthc.hpp"
#include <iostream>

constinit int val = theTruth.value ; // initialized after theTruth is initialized

int main()
{
	std::cout << val << '\n'; // guaranteed to be 42
	++val;
	std::cout << val << '\n'; // guaranteed to be 43
}
\end{cpp}

Therefore, the output of the program is now guaranteed to be:

\begin{shell}
42
43
\end{shell}

There are other ways to solve the static initialization order fiasco (using a static function to get the value or using inline). Nevertheless, you might think carefully about following a programming style that always declares global and static variables with constinit, provided the initialization does not need any runtime value/feature. Using it in a function like this at least does not hurt:

\begin{cpp}
long nextId()
{
	constinit static long id = 0;
	return ++id;
}
\end{cpp}








