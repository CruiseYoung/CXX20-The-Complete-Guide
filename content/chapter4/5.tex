
By defining a concept, you can introduce a name for one or more constraints.

Templates (function, class, variable, and alias templates) can use concepts to constrain their ability (via a requires clause or as a direct type constraint for a template parameter). However, concepts are also Boolean compile-time expressions (type predicates) that you can use wherever you have to check something for a type (such as in an if constexpr condition).

\mySubsubsection{4.5.1}{Defining Conceptss}

Concepts are defined as follows:

\begin{cpp}
template< ... >
concept name = ... ;
\end{cpp}

The equal sign is required (you cannot declare a concept without defining it and you cannot use braces here).
After the equal sign, you can specify any compile-time expression that converts to true or false.

Concepts are much like constexpr variable templates of type bool, but the type is not explicitly specified:

\begin{cpp}
template<typename T>
concept MyConcept = ... ;

std::is_same<MyConcept< ... >, bool> // yields true
\end{cpp}

This means that both at compile time and at runtime you can always use a concept where the value of a Boolean expression is needed. However, you cannot take the address because there is no object behind it (it is a prvalue).

The template parameters may not have constraints (you cannot use a concept to define a concept).

You cannot define concepts inside a function (as is the case for all templates).

\mySubsubsection{4.5.2}{Special Abilities of Concepts}

Concepts have special abilities.

Consider, for example, the following concept:

\begin{cpp}
template<typename T>
concept IsOrHasThisOrThat = ... ;
\end{cpp}

Compared to a definition of a Boolean variable template (which is the usual way type traits are defined):

\begin{cpp}
template<typename T>
inline constexpr bool IsOrHasThisOrThat = ... ;
\end{cpp}

we have the following differences:

\begin{itemize}
\item
Concepts do not represent code. They have no type, storage, lifetime, or any other properties associated with objects.

By instantiating them at compile time for specific template parameters, their instantiation just becomes true or false. Therefore, you can use them wherever you can use true or false and you get all properties of these literals.

\item
Concepts do not have to be declared as inline. They implicitly are inline.

\item
Concepts can be used as type constraints:

\begin{cpp}
template<IsOrHasThisOrThat T>
...
\end{cpp}

Variable templates cannot be used that way.

\item
Concepts are the only way to give constraints a name, which means that you need them to decide whether a constraint is a special case of another constraint.

\item
Concepts subsume. To let the compiler decide whether a constraint implies another constraint (and is therefore special), the constraints have to be formulated as concepts.
\end{itemize}

\mySubsubsection{4.5.3}{Concepts for Non-Type Template Parameters}

Concepts can also be applied to non-type template parameters (NTTP). For example:

\begin{cpp}
template<auto Val>
concept LessThan10 = Val < 10;

template<int Val>
requires LessThan10<Val>
class MyType {
	...
};
\end{cpp}

As a more useful example, we can use a concept to constrain the value of a non-type template parameter to be a power of two:

\filename{lang/conceptnttp.cpp}

\begin{cpp}
#include <bit>

template<auto Val>
concept PowerOf2 = std::has_single_bit(static_cast<unsigned>(Val));

template<typename T, auto Val>
requires PowerOf2<Val>
class Memory {
	...
};

int main()
{
	Memory<int, 8> m1; // OK
	Memory<int, 9> m2; // ERROR
	Memory<int, 32> m3; // OK
	Memory<int, true> m4; // OK
	...
}
\end{cpp}

The concept PowerOf2 takes a value instead of a type as a template parameter (here, using auto to not require a specific type):

\begin{cpp}
template<auto Val>
concept PowerOf2 = std::has_single_bit(static_cast<unsigned>(Val));
\end{cpp}

The concept is satisfied when the new standard function std::has\_single\_bit() yields true for the passed value (having only one bit set means that a value is a power of two). Note that std::has\_single\_bit() requires that we have an unsigned integral value. By casting to unsigned, programmers can pass signed integral values and reject types that cannot be converted to an unsigned integral value.

The concept is then used to require that a class Memory, taking a type and a size, accepts only sizes that are a power of two:

\begin{cpp}
template<typename T, auto Val>
requires PowerOf2<Val>
class Memory {
	...
};
\end{cpp}

Note that you cannot write the following:


\begin{cpp}
template<typename T, PowerOf2 auto Val>
class Memory {
	...
};
\end{cpp}

This puts the requirement on the type of Val; however, the concept PowerOf2 does not constrain a type; it constrains the value.








