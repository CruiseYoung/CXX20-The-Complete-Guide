正如本章所述，使用容器时可以依赖的一些习惯用法会被视图打破了。这里有一个总结，当在容器和视图中使用泛型代码时，应该考虑到:

\begin{itemize}
\item
当标准视图为const时，可能无法遍历其元素。

因此，所有类型范围(容器和视图)的泛型代码必须将参数声明为通用/转发引用。

但当有并发迭代时，不要使用通用/转发引用，则const很友好。

\item
左值范围的标准视图不传播常量。

将这样的视图声明为const并没有将元素声明为const。

\item
标准视图上的并发迭代可能导致数据争用(由于未定义行为导致的运行时错误)，即使它们只读取。

\item
读取迭代可能会影响以后的功能行为，甚至使以后的迭代无效。

临时使用标准视图。

\item
复制视图可能会创建一个与源视图具有不同状态和行为的视图。

避免复制标准视图。

\item
cbegin()和cend()不能使元素为const。

C++23将通过提供cbegin()和cend()成员函数，以及修复std::ranges::cbegin()和std::ranges::cend()来部分修复这个问题。不幸的是，仍然会破坏std::cbegin()和std::cend()。

\item
类型const\_iterator通常不可用。

\item
对于C++23，可能会有以下破坏:对于某些标准视图，将元素声明为const可能没有影响，可能能够修改视图的const元素的成员。
\end{itemize}

所以标准视图并不总是一个限制或处理范围元素的纯子集，其可能提供在使用整个范围时不允许的选项和操作。

因此，要特别小心地使用视图，不要考虑任何临时的常量。最好避免使用标准视图，而使用具有更安全设计的视图。