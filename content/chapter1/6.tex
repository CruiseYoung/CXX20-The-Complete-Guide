
After introducing the new rules for comparisons, it turned out that C++20 introduces some issues that may be a problem when switching from older C++ versions.

\mySubsubsection{1.6.1}{Delegating Free-Standing Comparison Operators}

The following example demonstrates the essence of the most typical problem:

\filename{lang/spacecompat.cpp}

\begin{cpp}
#include <iostream>

class MyType {
private:
	int value;
public:
	MyType(int i) // implicit constructor from int:
		: value{i} {
	}
	bool operator==(const MyType& rhs) const {
		return value == rhs.value;
	}
};

bool operator==(int i, const MyType& t) {
	return t == i; // OK with C++17
}
int main()
{
	MyType x = 42;
	if (0 == x) {
		std::cout << "'0 == MyType{42}' works\n";
	}
}
\end{cpp}

We have a trivial class that stores an integral value and has an implicit constructor to initialize the object (the implicit constructor is necessary to support initialization with =):

\begin{cpp}
class MyType {
	public:
	MyType(int i); // implicit constructor from int
	...
};

MyType x = 42; // OK
\end{cpp}

The class also declares a member function to compare objects:

\begin{cpp}
class MyType {
	...
	bool operator==(const MyType& rhs) const;
	...
};
\end{cpp}

However, before C++20, this does only enable implicit type conversions for the second operand. Therefore, the class or some other code introduces a global operator that swaps the order of the arguments:

\begin{cpp}
bool operator==(int i, const MyType& t) {
	return t == i; // OK until C++17
}
\end{cpp}

It would be better for the class to define the operator==() as a “hidden friend” (define it with friend inside the class structure so that both operators become parameters, you have direct access to members, and implicit type conversions are only performed if at least one parameter type fits). However, the code above had pretty much the same effect before C++20.

Unfortunately, this code no longer works in C++20.[Thanks to Peter Dimov and Barry Revzin for pointing out the problem and discussing it in \url{http://stackoverflow.com/questions/65648897}.] It results in an endless recursion. This is because inside the global function, the expression t == i can also call the global operator==() itself, because the compiler also tries to rewrite the call as i == t:

\begin{cpp}
bool operator==(int i, const MyType& t) {
	return t == i; // finds operator==(i,t) in addition to t.operator(MyType{i})
}
\end{cpp}

Unfortunately, the rewritten statement is a better match because it does not need the implicit type conversion. We have no solution yet to support backward compatibility here; however, compilers are already starting to warn about code like this.

If your code only has to work with C++20, you can simply remove the free-standing function. Otherwise you have two options:

\begin{itemize}
\item
Use an explicit conversion:

\begin{cpp}
bool operator==(int i, const MyType& t) {
	return t == MyType{i}; // OK until C++17 and with C++20
}
\end{cpp}

\item
Use a feature test macro to disable the code as soon as the new feature is available:
\end{itemize}

\mySubsubsection{1.6.2}{Inheritance with Protected Members}

For derived classes with defaulted comparison operators, there might be problems if the base class has the operators as protected members.

Note that the defaulted comparison operators require the support of comparisons in the base class. Therefore, the following does not work:

\begin{cpp}
struct Base {
};

struct Child : Base {
	int i;
	bool operator==(const Child& other) const = default;
};

Child c1, c2;
...
c1 == c2; // ERROR
\end{cpp}

As a consequence, you also have to provide a defaulted operator == in the base class. However, if you do not want the base class to provide operator == for the public, the obvious approach is to add a protected defaulted operator == in the base class:

\begin{cpp}
struct Base {
	protected:
	bool operator==(const Base& other) const = default;
};
struct 
Child : Base {
	int i;
	bool operator==(const Child& other) const = default;
};
\end{cpp}

However, in this case, the defaulted comparisons for the derived class does not work. It is rejected by the current compilers implementing the specified behavior of defaulted operators that is too strict here. This hopefully will be fixed soon (see \url{http://wg21.link/cwg2568}).

As a workaround, you have to implement the derived operator yourself.




