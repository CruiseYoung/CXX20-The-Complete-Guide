
Table Special member functions of coroutine promises lists all operations that are provided for coroutine handles in their promise type.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation}       & \textbf{Effect}                                          \\ \hline
\endfirsthead
%
\endhead
%
Constructor              & Initializes the promise                                  \\ \hline
get\_return\_object() &
Defines the object that the coroutine returns(usually of the coroutine interface type) \\ \hline
initial\_suspend()       & Initial supend point (to let the coroutine start lazily) \\ \hline
yield\_value(val)        & Deals with a value from co\_yield                        \\ \hline
unhandled\_exception()   & Reaction to an unhandled exception inside the coroutine  \\ \hline
return\_void()           & Deals with the end or a co\_return that returns nothing  \\ \hline
return\_value(val)       & Deals with a return value from co\_return                \\ \hline
final\_suspend()         & Final suspend point(to let the coroutine end lazily)     \\ \hline
await\_transform(...)    & Maps values from co\_await to awaiters                   \\ \hline
operator new(sz)         & Defines the way the coroutine allocates memory           \\ \hline
operator delete(ptr, sz) & Defines the way the coroutine frees memory               \\ \hline
\begin{tabular}[c]{@{}l@{}}get\_return\_object\_on\_...\\ ...allocation\_failure()\end{tabular} &
Defines the reaction if memory allocation failed \\ \hline
\end{longtable}

\begin{center}
Table 15.1. Special member functions of coroutine promises
\end{center}

Some of these functions are mandatory, some of them depend on whether the coroutine yields intermediate or final results, and some of the are optional.

\mySubsubsection{15.3.1}{Mandatory Promise Operations}

For coroutine promises, the following member functions are required. Without them, the code does not compile or runs into undefined behavior.

\mySamllsection{Constructor}

The constructor of coroutine promises is called by the coroutine framework when a coroutine is initialized.

The constructor can be used by the compiler to initialize the coroutine state with some arguments. For this, the signature of the constructor has to match the arguments passed to the coroutine when it is called. This technique is especially used by coroutine traits.

\mySamllsection{get\_return\_object()}

get\_return\_object() is used by the coroutine frame to create the return value of the coroutine.

The function usually has to return the coroutine interface, which is initialized with the coroutine handle, which is usually initialized with the static coroutine handle member function from\_promise(), which itself is initialized with the promise.

For example:

\begin{cpp}
class CoroTask {
	public:
	// native coroutine handle and its promise type:
	struct promise_type;
	using CoroHdl = std::coroutine_handle<promise_type>;
	CoroHdl hdl;
	
	struct promise_type {
		auto get_return_object() { // init and return the coroutine interface
			return CoroTask{CoroHdl::from_promise(*this)};
		}
		...
	}
	...
};
\end{cpp}

In principle, get\_return\_object() may have different return types:

\begin{itemize}
\item 
The typical approach is that get\_return\_object() returns the coroutine interface by explicitly initializing it with the coroutine handle (as above).

\item
Instead, get\_return\_object() can also return the coroutine handle. In that case, the coroutine interface is implicitly created. This requires that the interface constructor is not explicit.

It is currently not clear when exactly the coroutine interface is created in this case (see \url{http://wg21.link/cwg2563}). Therefore, the coroutine interface object might or might not exist when initial\_suspend() is called, which can create trouble if something goes wrong.

Therefore, you should better avoid to use this approach.

\item
In rare cases, it might even be useful to not return anything, and specify the return type to be void. Using coroutine traits can be one example.
\end{itemize}

\mySamllsection{initial\_suspend()}

initial\_suspend() defines the initial suspend point of the coroutine, which is used primarily to specify whether the coroutine should automatically suspend after its initialization (start lazily) or start immediately (start eagerly).

The function is called for the promise prm of the coroutine as follows:

\begin{cpp}
co_await prm.initial_suspend();
\end{cpp}

Therefore, initial\_suspend() should return an awaiter.

Usually, initial\_suspend() returns

\begin{itemize}
\item 
std::suspend\_always\{\}, if the coroutine body is started later/lazily, or

\item
std::suspend\_never\{\}, if the coroutine body is started immediately/eagerly
\end{itemize}

For example:

\begin{cpp}
class CoroTask {
	public:
	...
	struct promise_type {
		...
		auto initial_suspend() { // suspend immediately
			return std::suspend_always{}; // - yes, always
		}
		...
	}
	...
};
\end{cpp}

However, you can also let the decision of an eager or lazy start depend on some business logic or use this function to perform some initialization for the scope of the coroutine body.

\mySamllsection{final\_suspend() noexcept}

final\_suspend() defines the final suspend point of the coroutine and is called like initial\_suspend() for the promise prm of the coroutine as follows:

\begin{cpp}
co_await prm.final_suspend();
\end{cpp}

This function is called by the coroutine frame outside the try block that encloses the coroutine body after return\_void(), return\_value(), or unhandled\_exception() is called. Because final\_suspend() is outside the try block, it has to be noexcept.

The name of this member function is a little misleading because it gives the impression that you could also return std::suspend\_never\{\} here to force one more resumption after reaching the end of the coroutine. However, it is undefined behavior to resume a coroutine that is really suspended at the final suspend point. The only thing you can do with a coroutine suspended here is destroy it.

Therefore, the real purpose of this member function is to execute some logic, such as publishing a result, signaling completion, or resuming a continuation somewhere else.

Instead, the recommendation is to structure your coroutines so that they do suspend here where possible. One reason is that it makes it much easier for the compiler to determine when the lifetime of the coroutine frame is nested inside the caller of the coroutine, which makes it more likely that the compiler can elide heap memory allocation of the coroutine frame.

Therefore, unless you have a good reason not to do so, final\_suspend() should always return std::suspend\_always\{\}. For example:

\begin{cpp}
class CoroTask {
	public:
	...
	struct promise_type {
		...
		auto final_suspend() noexcept { // suspend at the end
			...
			return std::suspend_always{}; // - yes, always
		}
		...
	}
	...
};
\end{cpp}

\mySamllsection{unhandled\_exception()}

unhandled\_exception() defines the reaction when the coroutine body throws an exception. The function is called inside the catch clause of the coroutine frame.

Possible reactions to an exception here are:

\begin{itemize}
\item 
Ignoring the exception

\item 
Processing the exception locally

\item 
Ending or aborting the program (e.g., by calling std::terminate())

\item 
Storing the exception for later use with std::current\_exception()
\end{itemize}

The way to implement these reactions is discussed later in a separate subsection.

In any case, after this function is called without ending the program, final\_suspend() is called directly and the coroutine is suspended.

The coroutine is also suspended if you throw or rethrow an exception in unhandled\_exception(). Any exception thrown from unhandled\_exception() is ignored.

\mySubsubsection{15.3.2}{Promise Operations to Return or Yield Values}

Depending on whether and how co\_yield or co\_return is used, you also need some of the following promise operations.

\mySamllsection{return\_void() or return\_value()}

You have to implement exactly one the two member functions provided to deal with return statements and the end of the coroutine.:

\begin{itemize}
\item 
\textbf{return\_void()}

is called if the coroutine reaches the end (either by reaching the end of its body or by reaching a co\_return statement without argument).

See the first coroutine example for details.

\item 
\textbf{return\_value(Type)}

is called if the coroutine reaches a co\_return statement with an argument. The passed argument has to be or must convert to the specified type.

See the coroutine example with co\_return for details.
\end{itemize}

It is undefined behavior if coroutines are implemented in a way that they sometimes may and sometimes may not return a value. Consider this example:

\begin{cpp}
ResultTask<int> coroUB( ... )
{
	if ( ... ) {
		co_return 42;
	}
}
\end{cpp}

This coroutine is not valid. Having both return\_void() and return\_value() is not permitted.[There is an ongoing discussion about whether to allow promises to have both return\_void() and return\_value() in a future C++ standard.]

Unfortunately, if you provide a return\_value(int) member function only, this code might even compile and run and compilers might not even warn about it. This will hopefully change soon.

Note that you can overload return\_value() for different types (except void) or make it generic:

\begin{cpp}
struct promise_type {
	...
	void return_value(int val) { // reaction to co_yield for int
		... // - process returned int
	}
	void return_value(std::string val) { // reaction to co_yield for string
		... // - process returned string
	}
};
\end{cpp}

In that case, a coroutine can co\_return values of different types.

\begin{cpp}
CoroGen coro()
{
	int value = 0;
	...
	if ( ... ) {
		co_return "ERROR: can't compute value";
	}
	...
	co_return value;
}
\end{cpp}

\mySamllsection{yield\_value(Type)}

yield\_value(Type) is called if the coroutine reaches a co\_yield statement.

For basic details, see the coroutine example with co\_yield.

You can overload yield\_value() for different types or make it generic:

\begin{cpp}
struct promise_type {
	...
	auto yield_value(int val) { // reaction to co_yield for int
		... // - process yielded int
		return std::suspend_always{}; // - suspend coroutine
	}
	auto yield_value(std::string val) { // reaction to co_yield for string
		... // - process yielded string
		return std::suspend_always{}; // - suspend coroutine
	}
};
\end{cpp}

In that case, a coroutine can co\_yield values of different types:

\begin{cpp}
CoroGen coro()
{
	while ( ... ) {
		if ( ... ) {
			co_yield "ERROR: can't compute value";
		}
		int value = 0;
		...
		co_yield value;
	}
}
\end{cpp}

\mySubsubsection{15.3.3}{Optional Promise Operations}

Promises can also be used to define some optional operations that define special behavior of coroutines, where normally some default behavior is used.

\mySamllsection{await\_transform()}

await\_transform() can be defined to map values from co\_await to awaiters.

\mySamllsection{operator new() and operator delete()}

operator new() and operator delete() allow programmers to define a different way memory is allocated for the coroutine state.

These functions may also be used to ensure that coroutines do not accidentally use heap memory.

\mySamllsection{get\_return\_object\_on\_allocation\_failure()}

get\_return\_object\_on\_allocation\_failure() allows programmers to define how to react to exceptionless failures of memory allocation for coroutines.








