
This section discusses all features of C++20 that create views that refer to existing external values (usually passed as a single range parameter, as begin iterator and a sentinel, or as a begin iterator and a count).

\subsubsection*{\zihao{3} 8.3.1\hspace{0.2cm}Subrange}
\addcontentsline{toc}{subsubsection}{8.3.1\hspace{0.2cm}Subrange}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
	\hline
	\textbf{Type:}                 & std::ranges::subrange\textless{}\textgreater{} \\ \hline
	\textbf{Content:}              & All elements from passed begin to passed end   \\ \hline
	\textbf{Factories:}      & \begin{tabular}[c]{@{}l@{}}std::views::counted()\\ std::views::reverse() on reversed subrange\end{tabular} \\ \hline
	\textbf{Element type:}         & Value type of passed iterators                 \\ \hline
	\textbf{Requires:}             & At least input iterators                       \\ \hline
	\textbf{Category:}             & Same as passed                                 \\ \hline
	\textbf{Is sized range:} & If common random-access iterators or a size hint are passed                                                \\ \hline
	\textbf{Is common range:}      & If on common iterators                         \\ \hline
	\textbf{Is borrowed range:}    & Always                                         \\ \hline
	\textbf{Caches:}               & Nothing                                        \\ \hline
	\textbf{Const iterable:}       & If passed iterators are copyable               \\ \hline
	\textbf{Propagates constness:} & Never                                          \\ \hline
\end{tabular}
\end{table}

The class template std::ranges::subrange<> defines a view to the elements of a range that is usually passed as a pair of begin iterator and sentinel (end iterator). However, you can also pass a single range object and indirectly, a begin iterator and a count. Internally, the view itself represents the elements by storing begin (iterator) and end (sentinel).

The major use case of the subrange view is to convert a pair of begin iterator and sentinel (end iterator) into one object. For example:

\begin{cpp}
std::vector<int> coll{0, 8, 15, 47, 11, -1, 13};

std::ranges::subrange s1{std::ranges::find(coll, 15),
						std::ranges::find(coll, -1)};
print(coll); // 15 47 11
\end{cpp}

You can initialize the subrange with a special sentinel for the end value:

\begin{cpp}
std::ranges::subrange s2{coll.begin() + 1, EndValue<-1>{}};
print(s2); // 8 15 47 11
\end{cpp}

Both are especially helpful for converting a pair of iterators into a range/view so that, for example, range adaptors can process the elements:

\begin{cpp}
void foo(auto beg, auto end)
{
	// init view for all but the first five elements (if there are any):
	auto v = std::ranges::subrange{beg, end} | std::views::drop(5);
	...
}
\end{cpp}

Here is a complete example that demonstrates the use of a subrange:

\noindent
\hspace*{\fill} \\ %插入空行
\textit{ranges/subrange.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <unordered_map>
#include <ranges>

void printPairs(auto&& rg)
{
	for (const auto& [key, val] : rg) {
		std::cout << key << ':' << val << ' ';
	}
	std::cout << '\n';
}

int main()
{
	// English/German dictionary:
	std::unordered_multimap<std::string,std::string> dict = {
		{"strange", "fremd"},
		{"smart", "klug"},
		{"car", "Auto"},
		{"smart","raffiniert"},
		{"trait", "Merkmal"},
		{"smart", "elegant"},
	};
	
	// get begin and end of all elements with translation of "smart":
	auto [beg, end] = dict.equal_range("smart");
	
	// create subrange view to print all translations:
	printPairs(std::ranges::subrange(beg, end));
}
\end{cpp}

The program has the following output:

{\footnotesize
\begin{shell}
smart:klug smart:elegant smart:raffiniert
\end{shell}
}

After equal\_range() gives us a pair of the beginning and the end of all elements in dict that have the key "smart", we use a subrange to convert these two iterators into a view (here, a view of elements that are pairs of strings):

\begin{cpp}
std::ranges::subrange(beg, end)
\end{cpp}

We then can pass the view to printPairs() to iterate over the elements and print them out.

Note that a subrange might change its size so that elements are inserted or deleted between begin and end as long as both begin and end remain valid:

\begin{cpp}
std::list coll{1, 2, 3, 4, 5, 6, 7, 8};

auto v1 = std::ranges::subrange(coll.begin(), coll.end());
print(v1); // 1 2 3 4 5 6 7 8

coll.insert(++coll.begin(), 0);
coll.push_back(9);
print(v2); // 1 0 2 3 4 5 6 7 8 9
\end{cpp}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Range Factories for Subranges}

There is no range factory for initializing a subrange from a begin (iterator) and an end (sentinel). However, there is a range factory that might create a subrange from begin and a count:[C++20 originally stated that all() might also yield a subrange. However, that option was removed later when owning views were introduced (see \url{http://wg21.link/p2415})]

\begin{cpp}
std::views::counted(beg, sz)
\end{cpp}

std::views::counted() creates a subrange with the first sz elements of the non-contiguous range, starting with the element that the iterator beg refers to (for a contiguous range, counted() creates a span view).

When std::views::counted() creates a subrange, the subrange gets a std::counted\_iterator as the begin and a dummy sentinel of type std::default\_sentinel\_t as the end. This means that:

\begin{cpp}
std::views::counted(rg.begin(), 5);
\end{cpp}

is equivalent to:


\begin{cpp}
std::ranges::subrange{std::counted_iterator{rg.begin(), 5},
	std::default_sentinel};
\end{cpp}

This has the effect that the count in this subrange remains stable even if elements are inserted or removed:

\begin{cpp}
std::list coll{1, 2, 3, 4, 5, 6, 7, 8};

auto v2 = std::views::counted(coll.begin(), coll.size());
print(v2); // 1 2 3 4 5 6 7 8

coll.insert(++coll.begin(), 0);
coll.push_back(9);
print(v2); // 1 0 2 3 4 5 6 7
\end{cpp}

For more details, see the description of std::views::counted() and type std::counted\_iterator.

Here is a complete example that demonstrates the use of a subrange via counted():

\noindent
\hspace*{\fill} \\ %插入空行
\textit{ranges/subrangecounted.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <unordered_map>
#include <ranges>

void printPairs(auto&& rg)
{
	for (const auto& [key, val] : rg) {
		std::cout << key << ':' << val << ' ';
	}
	std::cout << '\n';
}

int main()
{
	// English/German dictionary:
	std::unordered_multimap<std::string,std::string> dict = {
		{"strange", "fremd"},
		{"smart", "klug"},
		{"car", "Auto"},
		{"smart","raffiniert"},
		{"trait", "Merkmal"},
		{"smart", "elegant"},
	};
	
	printPairs(dict);
	printPairs(std::views::counted(dict.begin(), 3));
}
\end{cpp}

The program has the following output:

{\footnotesize
\begin{shell}
trait:Merkmal car:Auto smart:klug smart:elegant smart:raffiniert strange:fremd
trait:Merkmal car:Auto smart:klug
\end{shell}
}

Note that in rare cases, std::views::reverse() might also yield a subrange. This happens when you reverse a reversed subrange. In that case, you get back the original subrange.


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Special Characteristics of Subranges}

A subrange may or may not be a sized range. The way this is implemented is that a subrange has a third template parameter of the enumeration type std::ranges::subrange\_kind, which can have the values std::ranges::unsized or std::ranges::sized. That value of this template parameter can be specified or is derived from the concept std::sized\_sentinel\_for called for the iterator and sentinel type.

This has the following consequences:

\begin{itemize}
\item
If you pass contiguous or random-access iterators of the same type, the subrange is sized:

\begin{cpp}
std::vector vec{1, 2, 3, 4, 5}; // has random access
...
std::ranges::subrange sv{vec.begin()+1, vec.end()-1}; // sized
std::cout << std::ranges::sized_range<decltype(sv)>; // true
\end{cpp}

\item
If you pass iterators that do not support random access or that are not common, the subrange is not sized:

\begin{cpp}
std::list lst{1, 2, 3, 4, 5}; // no random access
...
std::ranges::subrange sl{++lst.begin(), --lst.end()}; // unsized
std::cout << std::ranges::sized_range<decltype(sl)>; // false
\end{cpp}

\item
In the latter case, you can pass a size to make a subrange a sized range:

\begin{cpp}
std::list lst{1, 2, 3, 4, 5}; // no random access
...
std::ranges::subrange sl2{++lst.begin(), --lst.end(), lst.size()-2}; // sized
std::cout << std::ranges::sized_range<decltype(sl2)>; // true
\end{cpp}

It is undefined behavior if you initialize the view with the wrong size or use the view after elements have been inserted or deleted between the begin and end.
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Interface of Subranges}

Table Operations of the class std::ranges::subrange<> lists the API of a subrange.

The default constructor is provided only if the iterator is default initializable.

The constructors taking a szHint allow programmers to convert an unsized range into a sized subrange as shown above.

Iterators of a subrange refer to the underlying (or temporarily created) range. Therefore, a subrange is a borrowed range. However, note that iterators can still dangle when the underlying range is no longer there.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Tuple-Like Interface of Subranges}

std::ranges::subrange also has a tuple-like interface to support structured bindings (introduced to C++ with C++17). Thus, you can easily initialize a begin iterator and a sentinel (end iterator) doing something like the following:

\begin{cpp}
auto [beg, end] = std::ranges::subrange{coll};
\end{cpp}

For this, the class std::ranges::subrange provides;

\begin{itemize}
\item
A specialization of std::tuple\_size<>

\item
Specializations of std::tuple\_element<>

\item
get<>() functions for the indexes 0 and 1
\end{itemize}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
	\hline
	\textbf{Operation}      & \textbf{Effect}                                                           \\ \hline
	subrange r\{\}          & Creates an empty subrange                                                 \\ \hline
	subrange r\{rg\}        & Creates a subrange with the elements of range rg                          \\ \hline
	subrange r\{rg, szHint\}       & Creates a subrange with the elements of range rg specifying that the range has szHint elements           \\ \hline
	subrange r\{beg, end\}  & Creates a subrange with the elements of range {[}beg, end)                \\ \hline
	subrange r\{beg, end, szHint\} & Creates a subrange with the elements of range {[}beg, end) specifying that the range has szHint elements \\ \hline
	r.begin()               & Yields the begin iterator                                                 \\ \hline
	r.end()                 & Yields the sentinel (end iterator)                                        \\ \hline
	r.empty()               & Yields whether r is empty                                                 \\ \hline
	if (r)                  & true if r is not empty                                                    \\ \hline
	r.size()                & Yields the number of elements(available if sized)                         \\ \hline
	r.front()               & Yields the first element(available if forwarding)                         \\ \hline
	r.back()                & Yields the last element (available if bidirectional and common)           \\ \hline
	r{[}idx{]}              & Yields the n-th element (available if random access)                      \\ \hline
	r.data()                       & Yields a raw pointer to the memory of the elements(available if elements are in contiguous memory)       \\ \hline
	r.next()                & Yields a subrange starting with the second element                        \\ \hline
	r.next(n)               & Yields a subrange starting with the n-th element                          \\ \hline
	r.prev()                & Yields a subrange starting with the element before the first element      \\ \hline
	r.prev(n)               & Yields a subrange starting with the n-th element before the first element \\ \hline
	r.advance(dist)                & Modifies r so that it starts num elements later (starts earlier with negative num)                       \\ \hline
	auto {[}beg, end{]} = r & initializes beg and end with begin and end/sentinel of r                  \\ \hline
\end{tabular}
\end{table}

\begin{center}
Table 8.4. Operations of the class std::ranges::subrange<>
\end{center}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Using Subranges to Harmonize Raw Array Types}

The type of subranges depends only on the type of the iterators (and whether or not size() is provided).
This can be used to harmonize the type of raw arrays.

Consider the following example:

\begin{cpp}
int a1[5] = { ... };
int a2[10] = { ... };

std::same_as<decltype(a1), decltype(a2)> // false

std::same_as<decltype(std::ranges::subrange{a1}),
			 decltype(std::ranges::subrange{a2})> // true
\end{cpp}

Note that this works only for raw arrays. For std::array<> and other containers, iterators (may) have different types, meaning that a harmonization of the types with a subrange is at least not portable.

\subsubsection*{\zihao{3} 8.3.2\hspace{0.2cm}Ref View}
\addcontentsline{toc}{subsubsection}{8.3.2\hspace{0.2cm}Ref View}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
	\hline
	\textbf{Type:}                 & std::ranges::ref\_view\textless{}\textgreater{} \\ \hline
	\textbf{Content:}              & All elements of a range   \\ \hline
	\textbf{Factories:}      & \begin{tabular}[c]{@{}l@{}}std::views::all() and all other adaptors on lvalues\end{tabular} \\ \hline
	\textbf{Element type:}         & Same type as passed range                 \\ \hline
	\textbf{Requires:}             & At least input range                       \\ \hline
	\textbf{Category:}             & Same as passed                                 \\ \hline
	\textbf{Is sized range:} & If on sized range                                                \\ \hline
	\textbf{Is common range:}      & If on common range                         \\ \hline
	\textbf{Is borrowed range:}    & Always                                         \\ \hline
	\textbf{Caches:}               & Nothing                                        \\ \hline
	\textbf{Const iterable:}       & If on const-iterable range               \\ \hline
	\textbf{Propagates constness:} & Never                                          \\ \hline
\end{tabular}
\end{table}

The class template std::ranges::ref\_view<> defines a view that simply refers to a range. That way, passing the view by value has an effect like passing the range by reference.

The effect is similar to type std::reference\_wrapper<> (introduced with C++11), which makes references to first-class objects created with std::ref() and std::cref(). However, this wrapper has the benefit that it can still be used directly as a range.

The major use case of the ref\_view is to convert a container into a lightweight object that is cheap to copy. For example:

\begin{cpp}
void foo(std::ranges::input_range auto coll) // NOTE: takes range by value
{
	for (const auto& elem : coll) {
		...
	}
}

std::vector<std::string> coll{ ... };

foo(coll); // copies coll
foo(std::ranges::ref_view{coll}); // pass coll by reference
\end{cpp}

Passing a container to a coroutine, which usually has to take parameters by value, may be one application of this technique.

Note that you can only create a ref view to an lvalue (a range that has a name):

\begin{cpp}
std::vector coll{0, 8, 15};
...
std::ranges::ref_view v1{coll}; // OK, refers to coll
std::ranges::ref_view v2{std::move(coll)}; // ERROR
std::ranges::ref_view v3{std::vector{0, 8, 15}}; // ERROR
\end{cpp}

For an rvalue, you have to use an owning view.

Here is a complete example using a ref view:

\noindent
\hspace*{\fill} \\ %插入空行
\textit{ranges/refview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <vector>
#include <ranges>

void printByVal(std::ranges::input_range auto coll) // NOTE: takes range by value
{
	for (const auto& elem : coll) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}

int main()
{
	std::vector<std::string> coll{"love", "of", "my", "life"};
	
	printByVal(coll); // copies coll
	printByVal(std::ranges::ref_view{coll}); // pass coll by reference
	printByVal(std::views::all(coll)); // ditto (using a range adaptor)
}
\end{cpp}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Range Adaptors for Ref Views}

Ref views can also (and usually should) be created with a range factory:

\begin{cpp}
std::views::all(rg)
\end{cpp}

std::views::all() creates a ref\_view to the passed range rg provided rg is an lvalue and not a view yet (all() yields rg if it is already a view and an owning view if otherwise an rvalue is passed).

In addition, almost all other range adaptors also create a ref view if an lvalue is passed that is not a view yet.

The example program above uses this indirect way for creating a ref view with the last call of printByVal(). It passes a std::ranges::ref\_view<std::vector<std::string>{}>{}>:

\begin{cpp}
std::vector<std::string> coll{"love", "of", "my", "life"};
...
printByVal(std::views::all(coll));
\end{cpp}

Note that all other views that take a range indirectly call all() for that passed range (by using std::views::all\_t<>). For that reason, a ref view is almost always created automatically if you pass an lvalue that is not a view to one of the views. For example, calling:

\begin{cpp}
std::views::take(coll, 3)
\end{cpp}

basically has the same effect as calling the following:

\begin{cpp}
std::ranges::take_view{std::ranges::ref_view{coll}, 3};
\end{cpp}

However, using the adaptor, some optimizations might apply.

For more details, see the description of std::views::all().

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Special Characteristics of Ref Views}

The ref view stores a reference to the underlying range. Therefore, the ref view is a borrowed range. It can be used as long as the referred view is valid. For example, if the underlying view is a vector, a reallocation does not invalidate this view. However, note that iterators can still dangle when the underlying range is no longer there.


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Interface of Ref Views}

Table Operations of the class std::ranges::ref\_view<> lists the API of a ref\_view.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
	\hline
	\textbf{Operation} & \textbf{Effect}                                                \\ \hline
	\endfirsthead
	%
	\endhead
	%
	ref\_view r\{rg\}  & Creates a ref\_view that refers to range rg                    \\ \hline
	r.begin()          & Yields the begin iterator                                      \\ \hline
	r.end()            & Yields the sentinel (end iterator)                             \\ \hline
	r.empty()          & Yields whether r is empty (available if the range supports it) \\ \hline
	if(r)              & true if r is not empty(available if empty() is defined)        \\ \hline
	r.size() & Yields the number of elements (available if it refers to a sized range)                            \\ \hline
	r.front()          & Yields the first element(available if forwarding)              \\ \hline
	r.back()           & Yields the last element(available if bidirectional and common) \\ \hline
	r{[}idx{]}         & Yields the n-th element(available if random access)            \\ \hline
	r.data() & Yields a raw pointer to the memory of the elements(available if elements are in contiguous memory) \\ \hline
	r.base()           & Yields a reference to the range that r refers to               \\ \hline
\end{longtable}

\begin{center}
Table 8.5. Operations of the class std::ranges::ref\_view<>
\end{center}

Note that there is no default constructor provided for this view.

\subsubsection*{\zihao{3} 8.3.3\hspace{0.2cm}Owning View}
\addcontentsline{toc}{subsubsection}{8.3.3\hspace{0.2cm}Owning View}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:}                 & std::ranges::owning\_view\textless{}\textgreater{}  \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}              & All elements of a moved range                       \\ \hline
\textbf{Adaptors:}             & std::views::all() and all other adaptors on rvalues \\ \hline
\textbf{Element type:}         & Same type as passed range                           \\ \hline
\textbf{Requires:}             & At least input range                                \\ \hline
\textbf{Category:}             & Same as passed                                      \\ \hline
\textbf{Is sized range:}       & If on sized range                                   \\ \hline
\textbf{Is common range:}      & If on common range                                  \\ \hline
\textbf{Is borrowed range:}    & If on borrowed range                                \\ \hline
\textbf{Caches:}               & Nothing                                             \\ \hline
\textbf{Const iterable:}       & If on const-iterable range                          \\ \hline
\textbf{Propagates constness:} & Always                                              \\ \hline
\end{longtable}

The class template std::ranges::owning\_view<> defines a view that takes ownership of the elements of another range.[Originally, C++20 did not have an owning view. The view was introduced with a later fix (see \url{http://wg21.link/p2415}).]

This is the only view (so far) that might own multiple elements. However, construction is still cheap, because an initial range has to be an rvalue (temporary object or object marked with std::move()). The constructor will then move the range to an internal member of the view.

For example:

\begin{cpp}
std::vector vec{0, 8, 15};
std::ranges::owning_view v0{vec}; // ERROR
std::ranges::owning_view v1{std::move(vec)}; // OK
print(v1); // 0 8 15
print(vec); // unspecified value (was moved away)

std::array<std::string, 3> arr{"tic", "tac", "toe"};
std::ranges::owning_view v2{arr}; // ERROR
std::ranges::owning_view v2{std::move(arr)}; // OK
print(v2); // "tic" "tac" "toe"
print(arr); // "" "" ""
\end{cpp}

This is the only standard view of C++20 that does not support copying at all. You can only move it. For example:

\begin{cpp}
std::vector coll{0, 8, 15};
std::ranges::owning_view v0{std::move(coll)};

auto v3 = v0; // ERROR
auto v4 = std::move(v0); // OK (range in v0 moved to v4)
\end{cpp}

The major use case of the owning\_view is to create a view from a range without depending on the lifetime of the range anymore. For example:

\begin{cpp}
void foo(std::ranges::view auto coll) // NOTE: takes range by value
{
	for (const auto& elem : coll) {
		...
	}
}

std::vector<std::string> coll{ ... };

foo(coll); // ERROR: no view
foo(std::move(coll)); // ERROR: no view
foo(std::ranges::owning_view{coll}); // ERROR: must pass rvalue
foo(std::ranges::owning_view{std::move(coll)}); // OK: move coll as view
\end{cpp}

Converting a range to an owning view is usually done implicitly by passing a temporary container to a range adaptor (see below).

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Range Adaptors for Owning Views}

Owning views can also (and usually should) be created with a range factory:

\begin{cpp}
std::views::all(rg)
\end{cpp}

std::views::all() creates an owning\_view to the passed range rg provided rg is an rvalue and not a view yet (all() yields rg if it is already a view and a ref view if otherwise an lvalue is passed).

In addition, almost all other range adaptors also create an owning view if an rvalue is passed that is not a view yet.

The example above can therefore implement the call of foo() as follows:

\begin{cpp}
foo(std::views::all(std::move(coll))); // move coll as view
\end{cpp}

To create an owning view, the adaptor all() requires an rvalue (for an lvalue, all() creates a ref view). This means that you have to pass a temporary range or a named range marked with std::move() (all() yields a ref view if an lvalue is passed).

Here is a complete example:

\noindent
\hspace*{\fill} \\ %插入空行
\textit{ranges/owningview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <vector>
#include <ranges>

auto getColl()
{
	return std::vector<std::string>{"you", "don't", "fool", "me"};
}

int main()
{
	std::ranges::owning_view v1 = getColl(); // view owning a vector of strings
	auto v2 = std::views::all(getColl()); // ditto
	static_assert(std::same_as<decltype(v1), decltype(v2)>);
	
	// iterate over drop view of owning view of vector<string>:
	for (const auto& elem : getColl() | std::views::drop(1)) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}
\end{cpp}

Here, v1 and v2 both have type std::ranges::owning\_view<std::vector<std::string>>>. However, the usual way to create an owning view is demonstrated the range-based for loop at the end of the program: it creates an owning view indirectly when we pass the a temporary container to a range adaptor.

The expression

\begin{cpp}
getColl() | std::views::drop(1)
\end{cpp}

creates a

\begin{cpp}
std::ranges::drop_view<std::ranges::owning_view<std::vector<std::string>>>
\end{cpp}

The way this happens is that the drop view indirectly calls all() for the passed temporary range (by using std::views::all\_t<>).

For more details, see the description of std::views::all().


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Special Characteristics of Owning Views}

The owning view moves the passed range into itself. Therefore, the owning view is a borrowed range if the range it owns is a borrowed range.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Interface of Owning Views}

Table Operations of the class std::ranges::owning\_view<> lists the API of an owning\_view.

The default constructor is provided only if the iterator is default initializable.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
	\hline
	\textbf{Operation}   & \textbf{Effect}                                                \\ \hline
	\endfirsthead
	%
	\endhead
	%
	owning\_view r\{\}   & Creates an owning\_view that is empty                          \\ \hline
	owning\_view r\{rg\} & Craetes an owning\_view that owns the elements of rg           \\ \hline
	r.begin()            & Yields the begin iterator                                      \\ \hline
	r.end()              & Yields the sentinel(end iterator)                              \\ \hline
	r.empty()            & Yields whether r is empty(available if the range supports it)  \\ \hline
	if(r)                & true if r is not empty (available if empty() is defined)       \\ \hline
	r.size() & Yields the number of elements(available if it refers to a sized range)                             \\ \hline
	r.front()            & Yields the first element(available if forwarfing)              \\ \hline
	r.back()             & Yields the last element(available if bidirectional and common) \\ \hline
	r{[}idx{]}           & Yields the n-th element(available if random access)            \\ \hline
	r.data() & Yields a raw pointer to the memory of the elements(available if elements are in contiguous memory) \\ \hline
	r.base()             & Yields a reference to the range that r owns                    \\ \hline
\end{longtable}

\begin{center}
Table 8.6. Operations of the class std::ranges::owning\_view<>
\end{center}


\subsubsection*{\zihao{3} 8.3.4\hspace{0.2cm}Common View}
\addcontentsline{toc}{subsubsection}{8.3.4\hspace{0.2cm}Common View}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:}     & std::ranges::common\_view\textless{}\textgreater{}                \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}  & All elements of a range with harmonized iterator types            \\ \hline
\textbf{Adaptor:}              & std::views::common()        \\ \hline
\textbf{Element type:}         & Same type a as passed range \\ \hline
\textbf{Requires:} & Non-common at least forward range (adaptor accepts common ranges) \\ \hline
\textbf{Category:} & Usually forward(contiguous if on a sized contiguous range)        \\ \hline
\textbf{Is sized range:}       & If on sized range           \\ \hline
\textbf{Is common range:}      & Always                      \\ \hline
\textbf{Is borrowed ranges:}   & If on borrowed range        \\ \hline
\textbf{Caches:}               & Nothing                     \\ \hline
\textbf{Const iterable:}       & If on const-iterable range  \\ \hline
\textbf{Progagates constness:} & Only if on rvalue range     \\ \hline
\end{longtable}

The class template std::ranges::common\_view<> is a view that harmonizes the begin and end iterator types of a range to be able to pass them to code where the same iterator type is required (such as to constructors of containers or traditional algorithms).

Note that the constructor of the view requires that the passed range is not a common range (iterators have different types). For example:

\begin{cpp}
std::list<int> lst{1, 2, 3, 4, 5, 6, 7, 8, 9};

auto v1 = std::ranges::common_view{lst}; // ERROR: is already common

auto take5 = std::ranges::take_view{lst, 5}; // yields no common view
auto v2 = std::ranges::common_view{take5}; // OK
\end{cpp}

The corresponding range adaptor can also deal with ranges that already are common. Therefore, it is better to use the range adaptor std::views::common() to create a common view.

\samllsection{Range Adaptors for Common Views}

Common views can also (and usually should) be created with a range adaptor:

\begin{cpp}
std::views::common(rg)
\end{cpp}

std::views::common() creates a view that refers to rg as a common range. If rg is already common, it returns std::views::all(rg).

The examples above can therefore be made to always compile as follows:

\begin{cpp}
std::list<int> lst{1, 2, 3, 4, 5, 6, 7, 8, 9};

auto v1 = std::views::common(lst); // OK

auto take5 = std::ranges::take_view{lst, 5}; // yields no common view
auto v2 = std::views::common(take5); // v2 is common view
std::vector<int> coll{v2.begin(), v2.end()}; // OK
\end{cpp}

Note that by using the adaptor, it is not a compile-time error to create a common view from a range that is already common. This is the key reason to prefer the adaptor over directly initializing the view.

Here is a full example program for using common views:

\filename{ranges/commonview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <list>
#include <vector>
#include <ranges>

void print(std::ranges::input_range auto&& coll)
{
	for (const auto& elem : coll) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}

int main()
{
	std::list<std::string> coll{"You're", "my", "best", "friend"};
	
	auto tv = coll | std::views::take(3);
	static_assert(!std::ranges::common_range<decltype(tv)>);
	// could not initialize a container by passing begin and end of the view
	
	std::ranges::common_view vCommon1{tv};
	static_assert(std::ranges::common_range<decltype(vCommon1)>);
	
	auto tvCommon = coll | std::views::take(3) | std::views::common;
	static_assert(std::ranges::common_range<decltype(tvCommon)>);
	
	std::vector<std::string> coll2{tvCommon.begin(), tvCommon.end()}; // OK
	print(coll);
	print(coll2);
}
\end{cpp}

Here, we first create a take view, which is not common if it is not a random-access range. Because it is not common, we cannot use it to initialize a container with its elements:

\begin{cpp}
std::vector<std::string> coll2{tv.begin(), tv.end()}; // ERROR: begin/end types differ
\end{cpp}

Using the common view, the initialization works fine. Use std::views::common() if you do not know whether the range you want to harmonize is already common.

The major use case of the common view is to pass ranges or views that have different types for the begin and end iterators to generic code that requires begin and end to have the same type. A typical example is to pass the begin and end of a range to a constructor of a container or to a traditional algorithm. For example:

\begin{cpp}
std::list<int> lst {1, 2, 3, 4, 5, 6, 7, 8, 9};

auto v1 = std::views::take(lst, 5); // Note: types of begin() and end() differ
std::vector<int> coll{v1.begin(), v1.end()}; // ERROR: containers require the same type

auto v2 = std::views::common(std::views::take(lst, 5)); // same type now
std::vector<int> coll{v2.begin(), v2.end()}; // OK
\end{cpp}

\samllsection{Interface of Common Views}

Table Operations of the class std::ranges::common\_view<> lists the API of a common view.


% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation}   & \textbf{Effect}                                                \\ \hline
\endfirsthead
%
\endhead
%
common\_view r\{\} & Creates a common\_view that refers to a default constrcted range                                   \\ \hline
common\_view r\{rg\} & Creates a common\_view that refers to range rg                 \\ \hline
r.begin()            & Yields the begin iterator                                      \\ \hline
r.end()              & Yields the sentinel(end iterator)                              \\ \hline
r.empty()            & Yields whether r is empty(available if the range supportes it) \\ \hline
if (r)               & true if r is not empty(available if empty() is defined)        \\ \hline
r.size()           & Yields the number of elements (available if it refers to a sized range)                            \\ \hline
r.front()            & Yields the first element(available if forwarding)              \\ \hline
r.back()             & Yields the last element(available if bidrectional and common)  \\ \hline
r{[}idx{]}           & Yields the n-th element(available if random access)            \\ \hline
r.data()           & Yields a raw pointer to the memory of the elements(available if elements are in contiguous memory) \\ \hline
r.base()             & Yields a reference to the range that r refers to               \\ \hline
\end{longtable}

\begin{center}
Table 8.7. Operations of the class std::ranges::common\_view<>
\end{center}

The default constructor is provided only if the iterator is default initializable. Internally, common\_view uses iterators of type std::common\_iterator.

