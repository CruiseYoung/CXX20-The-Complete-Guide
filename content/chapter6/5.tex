
When using views (and the ranges library in general), there are a few things that are surprising or even broken regarding constness:

\begin{itemize}
\item
For some views, it is not possible to iterate over the elements when the view is const.

\item
Views remove the propagation of constness to elements.

\item
Functions like cbegin() and cend(), which have the goal of ensuring that elements are const while iterating over them, are either not provided or are actually broken.
\end{itemize}

There are more or less good reasons for these problems. Some of them have to do with the nature of views and some basic design decisions that were made. I consider this all as a severe design mistake. However, others in the C++ standards committee have different opinions.

There are fixes under way that at least fix the broken constness of cbegin() and cend(). Unfortunately, the C++ standards committee decided not to apply them to C++20. These will come (and change behavior) with C++23. See \url{http://wg21.link/p2278r4} for details.

\subsubsection*{\zihao{3} 6.5.1\hspace{0.2cm}Lifetime Dependencies Between Views and Their Ranges}
\addcontentsline{toc}{subsubsection}{6.5.1\hspace{0.2cm}Lifetime Dependencies Between Views and Their Ranges}

It is surprisingly complicated to implement a generic function that can iterate over the elements of every type of containers and views with good performance. For example, declaring a function that shall print all elements as follows does not always work:

\begin{cpp}
template<typename T>
void print(const T& coll); // OOPS: might not work for some views
\end{cpp}

Consider the following concrete example:

\noindent
\hspace*{\fill} \\ %插入空行
\textit{ranges/printconst.cpp}

\begin{cpp}
#include <iostream>
#include <vector>
#include <list>
#include <ranges>

void print(const auto& rg)
{
	for (const auto& elem : rg) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}

int main()
{
	std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9};
	std::list lst{1, 2, 3, 4, 5, 6, 7, 8, 9};
	
	print(vec | std::views::take(3)); // OK
	print(vec | std::views::drop(3)); // OK
	
	print(lst | std::views::take(3)); // OK
	print(lst | std::views::drop(3)); // ERROR
	for (const auto& elem : lst | std::views::drop(3)) { // OK
		std::cout << elem << ' ';
	}
	std::cout << '\n';
	
	auto isEven = [] (const auto& val) {
		return val % 2 == 0;
	};
	print(vec | std::views::filter(isEven)); // ERROR
}
\end{cpp}

First, we declare a very trivial generic function print(), which prints all elements of a range passed as a const reference:

\begin{cpp}
void print(const auto& rg)
{
	...
}
\end{cpp}

Then, we call print() for a couple of views and run into surprising behavior:


\begin{itemize}
\item
Passing take views and a drop view to a vector works fine:

\begin{cpp}
print(vec | std::views::take(3)); // OK
print(vec | std::views::drop(3)); // OK

print(lst | std::views::take(3)); // OK
\end{cpp}

\item
Passing a drop view to a list does not compile:

\begin{cpp}
print(vec | std::views::take(3)); // OK
print(vec | std::views::drop(3)); // OK

print(lst | std::views::take(3)); // OK
print(lst | std::views::drop(3)); // ERROR
\end{cpp}

\item
However, iterating over the drop view directly works fine:

\begin{cpp}
for (const auto& elem : lst | std::views::drop(3)) { // OK
	std::cout << elem << ' ';
}
\end{cpp}
\end{itemize}

This does not mean that vectors always work fine. If, for example, we pass a filter view, we get an error for all ranges:

\begin{cpp}
print(vec | std::views::filter(isEven)); // ERROR
\end{cpp}


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{const\& Does Not Work for All Views}

The reason for this very strange and unexpected behavior is that some views do not always support iterating over elements when the view is const. It is a consequence of the fact that iterating over the elements of these views sometimes needs the ability to modify the state of the view (e.g., due to caching). For some views (such as the filter view), it never works; for some views (such as the drop view), it only works sometimes.

In fact, you cannot iterate over the elements of the following standard views if they are declared with const:

\begin{itemize}
\item
const views that you can never iterate over:

\begin{itemize}
\item
Filter view

\item
Drop-while view

\item
Split view

\item
IStream view
\end{itemize}

\item
const views that you can only sometimes iterate over:

\begin{itemize}
\item
Drop view, if it refers to a range that has no random access or no size()

\item
Reverse view, if it refers to a range that has different types for the begin iterator and the sentinel (end iterator)

\item
Join view, if it refers to a range that generates values instead of references

\item
All views that refer to other ranges if the referred ranges themselves are not const iterable
\end{itemize}
\end{itemize}

For these views, begin() and end() as const member functions are provided only conditionally or are not provided at all. For example, for drop views, begin() for const objects is provided only if the passed ranges fulfill the requirement of a random-access range and sized range:[You might be surprised by the fact that the template parameter V is constrained to be a view. However, it may be a ref view implicitly created from a passed container that is not a view]


\begin{cpp}
namespace std::ranges {
	template<view V>
	class drop_view : public view_interface<drop_view<V>> {
		public:
		...
		constexpr auto begin() const requires random_access_range<const V>
		&& sized_range<const V>;
		...
	};
}
\end{cpp}

Here, we use the new feature to constrain member functions.

This means that you cannot provide a generic function that can deal with the elements of all ranges and views if you declare the parameter to be a const reference.

\begin{cpp}
void print(const auto& coll); // not callable for all views

template<typename T>
void foo(const T& coll); // not callable for all views
\end{cpp}

It does not matter whether you have constraints for the type of the range parameter:

\begin{cpp}
void print(const std::ranges::input_range auto& coll); // not callable for all views

template<std::ranges::random_access_range T>
void foo(const T& coll); // not callable for all views
\end{cpp}


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Non-const \&\& Does Work for All Views}

To also support these views in generic code, you should declare the range parameters as universal references (also called forwarding references). These are references that can refer to all expressions while retaining the fact that the referred object is not const[ In the C++ standard, universal references are called forwarding references, which is unfortunate because they do not really forward until std::forward<>() is called for them, and perfect forwarding is not always the reason to use these references (as this example demonstrates).]. For example:

\begin{cpp}
void print(std::ranges::input_range auto&& coll); // can in principle pass all views

template<std::ranges::random_access_range T>
void foo(T&& coll);
\end{cpp}

Thus, the following program works fine:

\noindent
\hspace*{\fill} \\ %插入空行
\textit{ranges/printranges.cpp}

\begin{cpp}
#include <iostream>
#include <vector>
#include <list>
#include <ranges>

void print(auto&& rg)
{
	for (const auto& elem : rg) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}

int main()
{
	std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9};
	std::list lst{1, 2, 3, 4, 5, 6, 7, 8, 9};
	
	print(vec | std::views::take(3)); // OK
	print(vec | std::views::drop(3)); // OK
	
	print(lst | std::views::take(3)); // OK
	print(lst | std::views::drop(3)); // OK
	for (const auto& elem : lst | std::views::drop(3)) { // OK
		std::cout << elem << ' ';
	}
	std::cout << '\n';
	
	auto isEven = [] (const auto& val) {
		return val % 2 == 0;
	};
	print(vec | std::views::filter(isEven)); // OK
}
\end{cpp}

For the same reason, the generic maxValue() function introduced before does not always work:

\begin{cpp}
template<std::ranges::input_range Range>
std::ranges::range_value_t<Range> maxValue(const Range& rg)
{
	... // ERROR when iterating over the elements of a filter view
}

// max value of a filtered range:
auto odd = [] (auto val) {
					return val % 2 != 0;
				};
std::cout << maxValue(arr | std::views::filter(odd)) << '\n'; // ERROR
\end{cpp}

As written, it is better to implement the generic maxValue() function as follows:

\noindent
\hspace*{\fill} \\ %插入空行
\textit{ranges/maxvalue2.hpp}

\begin{cpp}
#include <ranges>

template<std::ranges::input_range Range>
std::ranges::range_value_t<Range> maxValue(Range&& rg)
{
	if (std::ranges::empty(rg)) {
		return std::ranges::range_value_t<Range>{};
	}
	auto pos = std::ranges::begin(rg);
	auto max = *pos;
	while (++pos != std::ranges::end(rg)) {
		if (*pos > max) {
			max = *pos;
		}
	}
	return max;
}
\end{cpp}

Here, we declare parameter rg as a universal/forwarding reference:

\begin{cpp}
template<std::ranges::input_range Range>
std::ranges::range_value_t<Range> maxValue(Range&& rg)
\end{cpp}

That way, we ensure that the passed views are not becoming const, which means that we can also pass a filter view now:

\noindent
\hspace*{\fill} \\ %插入空行
\textit{ranges/maxvalue2.cpp}

\begin{cpp}
#include "maxvalue2.hpp"
#include <iostream>
#include <algorithm>

int main()
{
	int arr[] = {0, 8, 15, 42, 7};
	// max value of a filtered range:
	auto odd = [] (auto val) { // predicate for odd values
				return val % 2 != 0;
			};
	std::cout << maxValue(arr | std::views::filter(odd)) << '\n'; // OK
}
\end{cpp}

The output of the program is:

{\footnotesize
\begin{shell}
15
\end{shell}
}

Are you wondering now how to declare a generic function that can be called for all const and non-const ranges and views and guarantees that the elements are not modified? Well, again, there is an important lesson to learn here:

\textbf{Since C++20, there is no longer a way to declare a generic function to takes all standard collection types (const and non-const containers and views) with the guarantee that the elements are not modified.}

All you can do is to take the range/view and ensure in the body of your function that elements are not modified. However, it might be surprisingly complicated to do that because as we will now see:

\begin{itemize}
\item
Declaring views as const does not necessarily make the elements const.

\item
Views do not have const\_iterator members.

\item
Views do not provide cbegin() and cend() members (yet).

\item
std::ranges::cbegin() and std::cbegin() are broken for views.

\item
Declaring a view element as const might have no effect.
\end{itemize}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Use const\& for Concurrent Iterations}

Regarding the advice to use universal/forwarding references, there is an important restriction: you should not use them when you iterate over views concurrently.

Consider the following example:

\begin{cpp}
std::list<int> lst{1, 2, 3, 4, 5, 6, 7, 8};

auto v = lst | std::views::drop(2);

// while another thread prints the elements of the view:
std::jthread printThread{[&] {
		for (const auto& elem : v) {
			std::cout << elem << '\n';
		}
}};

// this thread computes the sum of the element values:
auto sum = std::accumulate(v.begin(), v.end(), // fatal runtime ERROR
0L);
\end{cpp}

By using a std::jthread, we start a thread that iterates over the elements of the view v to print them. At the same time, we iterate over v to compute the sum of the element values. For standard containers, parallel iterations that only read are safe (there is a guarantee for containers, that calling begin() counts as read access). However, this guarantee does not apply to standard views. Because we might call begin() for view v concurrently, this code causes undefined behavior (a possible data race).

Functions that perform concurrent iterations that only read should use const view to convert possible runtime errors into compile-time errors:

\begin{cpp}
const auto v = lst | std::views::drop(2);

std::jthread printThread{[&] {
		for (const auto& elem : v) { // compile-time ERROR
			std::cout << elem << '\n';
		}
}};

auto sum = std::accumulate(v.begin(), v.end(), // compile-time ERROR
0L);
\end{cpp}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Overloading for Views}

You might claim that you can simply overload a generic function for containers and views. For views, it might be enough to just add an overload that constrains the function for views and takes the parameter by value:

\begin{cpp}
void print(const auto& rg); // for containers
void print(std::ranges::view auto rg) // for views
\end{cpp}

However, the rules of overload resolution can become tricky when you once pass by value and once by reference. In this case, it causes ambiguities:

\begin{cpp}
std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9};
print(vec | std::views::take(3)); // ERROR: ambiguous
\end{cpp}

It also does not help to use a concept for the views that subsumes a concept used for the general case:

\begin{cpp}
void print(const std::ranges::range auto& rg); // for containers
void print(std::ranges::view auto rg) // for views

std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9};
print(vec | std::views::take(3)); // ERROR: ambiguous
\end{cpp}

It also does not help to use a concept for the views that subsumes a concept used for the general case:

\begin{cpp}
void print(const std::ranges::range auto& rg); // for containers
void print(std::ranges::view auto rg) // for views

std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9};
print(vec | std::views::take(3)); // ERROR: ambiguous
\end{cpp}

Instead, you have to state that the const\& overload is not for views:

\begin{cpp}
template<std::ranges::input_range T> // for containers
requires (!std::ranges::view<T>) // and not for views
void print(const T& rg);

void print(std::ranges::view auto rg) // for views

std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9};
print(vec | std::views::take(3)); // OK
\end{cpp}

However, remember that copying a view might create a view with different state and behavior than the source view. For this reason, it is anyway questionable whether it is good to pass all views by value.

\subsubsection*{\zihao{3} 6.5.2\hspace{0.2cm}Views with Write Access}
\addcontentsline{toc}{subsubsection}{6.5.2\hspace{0.2cm}Views with Write Access}

Containers have deep constness. Because they have value semantics and own their elements, they propagate any constness to their elements. When a containers is const, its elements are const. As a consequence, the following code fails to compile:

\begin{cpp}
template<typename T>
void modifyConstRange(const T& range)
{
	range.front() += 1; // modify an element of a const range
}

std::array<int, 10> coll{}; // array of 10 ints with value 0
...
modifyConstRange(coll); // compile-time ERROR
\end{cpp}

This compile-time error is helpful because it helps to detect code that would otherwise be broken at runtime. For example, if you accidentally use the assignment operator instead of a comparison, the code does not compile:

\begin{cpp}
template<typename T>
void modifyConstRange(const T& range)
{
	if (range[0] = 0) { // OOPS: should be ==
		...
	}
}

std::array<int, 10> coll{}; // array of 10 ints with value 0
...
modifyConstRange(coll); // compile-time ERROR (thank goodness)
\end{cpp}

Knowing that elements cannot be modified also helps for optimizations (such as avoiding the need to make backups and check for changes) or to be sure that element access cannot cause undefined behavior due to data races when multiple threads are used.

With views the situation is more complicated. Views on ranges passed as lvalues have reference semantics. They refer to elements stored somewhere else. By design, these views do not propagate constness to their elements. They have shallow constness:

\begin{cpp}
std::array<int, 10> coll{}; // array of 10 ints with value 0
...
std::ranges::take_view v{coll, 5}; // view to first five elements of coll
modifyConstRange(v); // OK, modifies the first element of coll
\end{cpp}

That applies to almost all views on lvalues regardless of how they are created:

\begin{cpp}
modifyConstRange(coll | std::views::drop(5)); // OK, elements of coll are not const
modifyConstRange(coll | std::views::take(5)); // OK, elements of coll are not const
\end{cpp}

As a consequence, you can use the range adaptor std::views::all() to pass a container to a generic function that takes a range as a const reference:

\begin{cpp}
modifyConstRange(coll); // compile-time ERROR: elements are const
modifyConstRange(std::views::all(coll)); // OK, elements of coll are not const
\end{cpp}

Note that views on rvalues (if they are valid) usually still propagate constness:

\begin{cpp}
readConstRange(getColl() | std::views::drop(5)); // compile-time ERROR (good)
readConstRange(getColl() | std::views::take(5)); // compile-time ERROR (good)
\end{cpp}

Also, note that it is not possible to modify the elements of a const container using a view:

\begin{cpp}
const std::array<int, 10> coll{}; // array of 10 ints with value 0
...
auto v = std::views::take(coll, 5); // view to first five elements of coll
modifyConstRange(v); // compile-time ERROR (good)
\end{cpp}

Therefore, you can ensure that elements of a container cannot be modified by a function that takes a view by making the container const before the view refers to it:

\begin{cpp}
std::array<int, 10> coll{}; // array of 10 ints with value 0
...
std::ranges::take_view v{std::as_const(coll), 5}; // view to five elems of const coll
modifyConstRange(v); // compile-time ERROR
modifyConstRange(std::as_const(coll) | std::views::take(5)); // compile-time ERROR
\end{cpp}

The function std::as\_const() has been provided since C++17 in the header file <utility>. However, calling std::as\_const() after the view was created has no effect (except that for a few views, you are no longer able to iterate over the elements).

C++23 will introduce a helper view std::ranges::as\_const\_view with the range adaptor std::views::as\_const() so that you can simply make the elements of a view const as follows (see \url{http://wg21.link/p2278r4}):

\begin{cpp}
std::views::as_const(v); // make elements of view v const
\end{cpp}

However, note again that you must not forget the namespace views here:

\begin{cpp}
std::as_const(v); // OOPS: no effect on views
\end{cpp}

The functions as\_const() in the namespace std and in the namespace std::ranges both make something const but the former makes the object const while the latter makes the elements const[The members of the C++ standards committee sometimes decide in favor of features that look the same even though details differ and may become a source of trouble.]. You might wonder why views with reference semantics were not designed in a way that they propagate constness. One argument was that they internally use pointers and therefore should behave like pointers.

However, then it is strange that views on rvalues do not work that way. Another argument was that the constness is worth almost nothing because it can easily be removed by copying the view to a non-const view:

\begin{cpp}
void foo(const auto& rg) // if rg would propagate constness for views on lvalues
{
	auto rg2 = rg; // rg2 would no longer propagate constness
	...
}
\end{cpp}

The initialization would act kind of a const\_cast<>. However, if this is generic code for containers programmers are already used not to copy a passed collection, because it is expensive to do so. Therefore, we now have another good reason not to copy a passed range. And the effect of declaring ranges (containers and views) as const would be way more consistent. However, the design decision is done now and as a programmer you have to deal with it.

\subsubsection*{\zihao{3} 6.5.3\hspace{0.2cm}Views on Ranges That Change}
\addcontentsline{toc}{subsubsection}{6.5.3\hspace{0.2cm}Views on Ranges That Change}

As we have learned, using const for ranges that are views is a problem for two reasons:

\begin{itemize}
\item
const may disable iteration over the elements

\item
const might not be propagated to the elements of a view
\end{itemize}

The obvious question then is how to ensure that code cannot modify the elements of a range when using a view.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Making the Elements const When Using Them}

The only easy way to ensure that elements of a view cannot be modified is to force constness on element access:

\begin{itemize}
\item
Either by using const in the range-based for loop:

\begin{cpp}
for (const auto& elem : rg) {
	...
}
\end{cpp}

\item
Or by passing elements converted to const:

\begin{cpp}
for (auto pos = rg.begin(); pos != rg.end(); ++pos) {
	elemfunc(std::as_const(*pos));
}
\end{cpp}
\end{itemize}

However, here is the bad news: the designers of the views library plan to disable the effect of declaring elements const for some views such as the upcoming zip view:

\begin{cpp}
for (const auto& elem : myZipView) {
	elem.member = value; // WTF: C++23 plans to let this compile
}
\end{cpp}

Maybe we can still stop this. However, beware that making collections or their elements const may not work when using C++ standard views.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{const\_iterator and cbegin() Are Not Provided or Are Broken}

Unfortunately, the usual approach of making all elements of a container const does not work for views:

\begin{itemize}
\item
In general, views do not provide a const\_iterator to do the following:

\begin{cpp}
for (decltype(rg)::const_iterator pos = rg.begin(); // not for views
pos != range.end();
++pos) {
	elemfunc(*pos);
}
\end{cpp}

Therefore, we also cannot simply convert the range as a whole:

\begin{cpp}
std::ranges::subrange<decltype(rg)::const_iterator> crg{rg}; // not for views
\end{cpp}

\item
In general, views do not have the member functions cbegin() and cend() to do the following:

\begin{cpp}
callTraditionalAlgo(rg.cbegin(), rg.cend()); // not for views
\end{cpp}
\end{itemize}

You might propose that we use the free-standing helper functions std::cbegin() and std::cend(), which have been provided since C++11 instead. They were introduced to ensure that elements are const when you iterate over them. Here, however, the situation is even worse, because std::cbegin() and std::cend() are broken for views. Their specification did not take into account types that have shallow constness (internally, they call the const member function begin() and do not add constness to the value type). Therefore, for views that do not propagate constness, these functions are simply broken[std::cbegin() and std::cend() should simply be fixed. However, so far, the C++ standards committee has rejected each proposal to fix them.]:

\begin{cpp}
for (auto pos = std::cbegin(range); pos != std::cend(range); ++pos) {
	elemfunc(*pos); // does not provide constness for values of views
}
\end{cpp}

Note also that when using these helper functions, there are some issues with ADL. For that reason, C++20 introduces corresponding helper functions of the ranges library in the namespace std::ranges. Unfortunately, std::ranges::cbegin() and std::ranges::cend() are also broken for views in C++20 (this will be fixed in C++23, though):

\begin{cpp}
for (auto pos = std::ranges::cbegin(rg); pos != std::ranges::cend(rg); ++pos) {
	elemfunc(*pos); // OOPS: Does not provide constness for the values in C++20
}
\end{cpp}

Thus, in C++20, we have yet another severe problem when typing to make all elements of a view const:

\textbf{BE CAREFUL when using cbegin(), cend(), cdata() in generic code because these functions are not available or are broken for some views.}

I do not know what is worse: that we have this problem or that the C++ standards committee and its subgroup for the ranges library were not willing to fix this problem for C++20. For example, we could provide const\_iterator and cbegin() members in std::ranges::view\_interface<>, which serves as a base class for all views. The funny thing is that only one view provides const\_iterator support so far: std::string\_view. Ironically, that is more or less the only view where we do not need it, because in a string view, the characters are always const.

However, there is some hope: \url{http://wg21.link/p2278} provides an approach to fix this broken constness for C++23 (unfortunately, not for std::cbegin() and std::cend(), sigh).9 With that approach, inside a generic function, you can make the elements const as follows:

\begin{cpp}
void print(auto&& rgPassed)
{
	auto rg = std::views::as_const(rgPassed); // ensure all elements are const
	... // use rg instead of rgPassed now
}
\end{cpp}

As another approach, you can do the following:

\begin{cpp}
void print(R&& rg)
{
	if constexpr (std::ranges::const_range<R>) {
		// the passed range and its elements are constant
		...
	}
	else {
		// call this function again after making view and elements const:
		print(std::views::as_const(std::forward<R>(rg)));
	}
}
\end{cpp}

Unfortunately, C++23 will still not provide a generic way to declare a reference parameter for both containers and views that guarantees that the elements are const inside. You cannot declare a function print() that guarantees in its signature not to modify the elements.

