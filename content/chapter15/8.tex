
So far, we have passed only awaiters to co\_await. For example, by using a standard awaiter:

\begin{cpp}
co_await std::suspend_always{};
\end{cpp}

Or, as another example, co\_await took a user-defined awaiter:

\begin{cpp}
co_await CoroPrio{CoroPrioRequest::less}; // SUSPEND with lower prio
\end{cpp}

However, co\_await expr is an operator that can be part of a bigger expression and take values that do not have an awaiter type. For example:

\begin{cpp}
co_await 42;
co_await (x + y);
\end{cpp}

The co\_await operator has the same priority as sizeof or new. For this reason, you cannot skip the parentheses in the example above without changing the meaning. The statement

\begin{cpp}
co_await x + y;
\end{cpp}

would be evaluated as follows:

\begin{cpp}
(co_await x) + y;
\end{cpp}

Note that x + y or just x does not have to be an awaiter here. co\_await needs an awaitable and awaiters are only one (typical) implementation of them. In fact, co\_await accepts any value of any type provided there is a mapping to the API of an awaiter. For the mapping, the C++ standard provides two approaches:

\begin{itemize}
\item 
The promise member function await\_transform()

\item 
operator co\_await()
\end{itemize}

Both approaches allow coroutines to pass any value of any type to co\_await specifying an awaiter implicitly or indirectly.


\mySubsubsection{15.8.1}{await\_transform()}

If a co\_await expression occurs in a coroutine, the compiler first looks up whether there is a member function await\_transform() that is provided by the promise of the coroutine. If that is the case, await\_transform() is called and has to yield an awaiter, which is then used to suspend the coroutine.

For example, this means that:

\begin{cpp}
class CoroTask {
	struct promise_type {
		...
		auto await_transform(int val) {
			return MyAwaiter{val};
		}
	};
	...
};

CoroTask coro()
{
	co_await 42;
}
\end{cpp}

has the same effect as:

\begin{cpp}
class CoroTask {
	...
};

CoroTask coro()
{
	co_await MyAwaiter{42};
}
\end{cpp}

You can also use it to enable a coroutine to pass a value to the promise before using a (standard) awaiter:

\begin{cpp}
class CoroTask {
	struct promise_type {
		...
		auto await_transform(int val) {
			... // process val
			return std::suspend_always{};
		}
	};
	...
};

CoroTask coro()
{
	co_await 42; // let 42 be processed by the promise and suspend
}
\end{cpp}

\mySamllsection{Using Values to Let co\_await Update Running Coroutines}

Remember the example in which an awaiter was used to change the priority of the coroutine. There, we used an awaiter of the type CoroPrio to enable the coroutine to request the new priority as follows:

\begin{cpp}
co_await CoroPrio{CoroPrioRequest::less}; // SUSPEND with lower prio
\end{cpp}

We could also allow only the new priority to be passed:

\begin{cpp}
co_await CoroPrioRequest::less; // SUSPEND with lower prio
\end{cpp}

All we would need is for the coroutine interface promise to provide a member function await\_transform() for values of this type:

\begin{cpp}
class CoroPrioTask {
public:
	struct promise_type;
	using CoroHdl = std::coroutine_handle<promise_type>;
private:
	CoroHdl hdl; // native coroutine handle
	friend class CoroPrioScheduler; // give access to the handle
public:
	struct promise_type {
		CoroPrioScheduler* schedPtr = nullptr; // each task knows its scheduler:
		...
		auto await_transform(CoroPrioRequest); // deal with co_await CoroPrioRequest
	};
	...
};
\end{cpp}

The implementation of await\_transform() may look as follows:

\begin{cpp}
inline auto CoroPrioTask::promise_type::await_transform(CoroPrioRequest pr) {
	auto hdl = CoroPrioTask::CoroHdl::from_promise(*this);
	schedPtr->changePrio(hdl, pr);
	return std::suspend_always{};
}
\end{cpp}

Here, we again use the static member function from\_promise() for coroutine handles to get the handle, because changePrio() needs the handle as its first argument.

That way, we can skip the awaiter CoroPrio as a whole. See coro/coropriosched2.hpp for the whole code (and coro/coroprio2.cpp and coro/coroprio2.hpp for its use).

\mySamllsection{Letting co\_await Act Like co\_yield}

Remember the example with co\_yield. To handle the value to be yielded we do the following:

\begin{cpp}
struct promise_type {
	int coroValue = 0; // last value from co_yield
	auto yield_value(int val) { // reaction to co_yield
		coroValue = val; // - store value locally
		return std::suspend_always{}; // - suspend coroutine
	}
	...
};

co_yield val; // calls yield_value(val) on promise
\end{cpp}

We can get the same effect with the following:

\begin{cpp}
 can get the same effect with the following:
struct promise_type {
	int coroValue = 0; // last value from co_yield
	auto await_transform(int val) {
		coroValue = val; // - store value locally
		return std::suspend_always{};
	}
	...
};

co_await val; // calls await_transform(val) on promise
\end{cpp}

In fact,

\begin{cpp}
co_yield val;
\end{cpp}

is equivalent to

\begin{cpp}
co_await prm.yield_value(val);
\end{cpp}

where prm is the promise of the enclosing coroutine.

\mySubsubsection{15.8.2}{operator co\_await()}

The other option for letting co\_await deal with any value of (almost) any type is to implement operator co\_await() for that type. This means that you have to pass a value of a class.

Assume we have implemented operator co\_await() for some type MyType:

\begin{cpp}
class MyType {
	auto operator co_await() {
		return std::suspend_always{};
	}
};
\end{cpp}

Then, calling co\_await for an object of that type:

\begin{cpp}
CoroTask coro()
{
	...
	co_await MyType{};
}
\end{cpp}

calls the operator and uses the returned awaiter to handle the suspension. Here, operator co\_await() yields std::suspend\_always{}, which means that we effectively get:

\begin{cpp}
CoroTask coro()
{
	...
	co_await std::suspend_always{};
}
\end{cpp}

However, you could pass arguments to MyType{} and pass them to an awaiter so that you can pass values to the suspended coroutine for immediate or later resumption.

Another example is to pass a coroutine to co\_await, which can then be called, including implementing preparations such as changing threads or scheduling the coroutine a thread pool.













