
Before we go into details, let us look at some motivating examples.

\mySubsubsection{11.1.1}{Scheduling a Meeting on the 5th of Every Month}

Consider a program where we want to to iterate over all months in a year to schedule a meeting on the 5th of every month. The program can be written as follows:

\filename{lib/chrono1.cpp}

\begin{cpp}
#include <chrono>
#include <iostream>

int main()
{
	namespace chr = std::chrono; // shortcut for std::chrono
	using namespace std::literals; // for h, min, y suffixes
	
	// for each 5th of all months of 2021:
	chr::year_month_day first = 2021y / 1 / 5;
	for (auto d = first; d.year() == first.year(); d += chr::months{1}) {
		// print out the date:
		std::cout << d << ":\n";
		
		// init and print 18:30 UTC of those days:
		auto tp{chr::sys_days{d} + 18h + 30min};
		std::cout << std::format(" We meet on {:%A %D at %R}\n", tp);
	}
}
\end{cpp}

The program has an output like the following:

\begin{shell}
2021-01-05:
 We meet on Tuesday 01/05/21 at 18:30
2021-02-05:
 We meet on Friday 02/05/21 at 18:30
2021-03-05:
 We meet on Friday 03/05/21 at 18:30
2021-04-05:
 We meet on Monday 04/05/21 at 18:30
2021-05-05:
 We meet on Wednesday 05/05/21 at 18:30
...
2021-11-05:
 We meet on Friday 11/05/21 at 18:30
2021-12-05:
 We meet on Sunday 12/05/21 at 18:30
\end{shell}

Let us go through this program step by step.

\mySamllsection{Namespace Declarations}

We start with the namespace and using declarations to make the use of the chrono library a little more convenient:

\begin{itemize}
\item 
First we introduce chr:: as a shortcut for the standard namespace of the chrono library std::chrono:

\begin{cpp}
namespace chr = std::chrono; // shortcut for std::chrono
\end{cpp}

To make examples more readable, from time to time I will use just chr:: instead of std::chrono::.

\item
Then, we ensure that we can use literal suffixes such as s, min, h, and y (the latter is new since C++20).

\begin{cpp}
using namespace std::literals; // for min, h, y suffixes
\end{cpp}
\end{itemize}

To avoid any qualification, you could use a using declaration instead:

\begin{cpp}
using namespace std::chrono; // skip chrono namespace qualification
\end{cpp}

As usual, you should limit the scope of such a using declaration to avoid unwanted side effects.

\mySamllsection{Calendrical Type year\_month\_day}

\begin{cpp}
chr::year_month_day first = 2021y / 1 / 5;
\end{cpp}

Data flow starts with the initialization of the start date first of type std::chrono::year\_month\_day:

The type year\_month\_day is a calendrical type that provides attributes for all three fields of a date so that it is easy to deal with the year, the month, and the day of a particular date.

Because we want to iterate over all fifth days of each month, we initialize the object with January 5, 2021, using operator / to combine a year with a value for the month and a value for the day as follows:

\begin{itemize}
\item 
First, we create the year as an object of the type std::chrono::year. Here, we use the new standard literal \textbf{y}:

\begin{cpp}
2021y
\end{cpp}

To have this literal available, we have to provide one of the following using declarations:

\begin{cpp}
using std::literals; // enable all standard literals
using std::chrono::literals; // enable all standard chrono literals
using namespace std::chrono; // enable all standard chrono literals
using namespace std; // enable all standard literals
\end{cpp}

Without these literals we would need something like the following:

\begin{cpp}
std::chrono::year{2021}
\end{cpp}

\item
Then, we use operator / to combine the std::chrono::year with an integral value, which creates an object of type std::chrono::year\_month.

Because the first operand is a year, it is clear that the second operand must be a month. You cannot specify a day here.
specify a day here.

\item
Finally, we use operator / again to combine the std::chrono::year\_month object with an integral value to create a std::chrono::year\_month\_day.
\end{itemize}

This initialization for calendrical types is type-safe and requires only the specification the type of the first operand.

Because the operator already yields the right type, we could also declare first with auto. Without the namespace declarations, we would have to write:

\begin{cpp}
auto first = std::chrono::year{2021} / 1 / 5;
\end{cpp}

With the chrono literals available, we could simply write:

\begin{cpp}
auto first = 2021y/1/5;
\end{cpp}

\mySamllsection{Other Ways to Initialize Calendrical Types}

There are other ways to initialize a calendrical type like year\_month\_day:

\begin{cpp}
auto d1 = std::chrono::years{2021}/1/5; // January 5, 2021
auto d2 = std::chrono:month{1}/5/2021; // January 5, 2021
auto d3 = std::chrono:day{5}/1/2021; // January 5, 2021
\end{cpp}

That is, the type of the first argument for operator / specifies how to interpret the other arguments.

With the chrono literals available, we could simply write:

\begin{cpp}
using namespace std::literals;
auto d4 = 2021y/1/5; // January 5, 2021
auto d5 = 5/1/2021; // January 5, 2021
\end{cpp}

There is no standard suffix for a month, but we have predefined standard objects:

\begin{cpp}
auto d6 = std::chrono::January / 5 / 2021; // January 5, 2021
\end{cpp}

With the corresponding using declaration, we could even write just the following:

\begin{cpp}
using namespace std::chrono;
auto d6 = January/5/2021; // January 5, 2021
\end{cpp}

In all cases, we initialize an object of type std::chrono::year\_month\_day.

\mySamllsection{New Duration Types}

In our example, we then call a loop to iterate over all months of the year:

\begin{cpp}
for (auto d = first; d.year() == first.year(); d += chr::months{1}) {
	...
}
\end{cpp}

The type std::chrono::months is a new duration type that represents a month. You can use it for all calendrical types to deal with the specific month of a date, such as adding one month as we have done here:

\begin{cpp}
std::chrono::year_month_day d = ... ;
d += chr::months{1}; // add one month
\end{cpp}

However, note that when we use it for ordinary durations and timepoints, the type months represents the average duration of a month, which is 30.436875 days. Therefore, with ordinary timepoints, you should use months and years with care.

\mySamllsection{Output Operators for All Chrono Types}

Inside the loop, we print the current date:

\begin{cpp}
std::cout << d << '\n';
\end{cpp}

Since C++20, there is an output operator defined for more or less all possible chrono types.

\begin{cpp}
std::chrono::year_month_day d = ... ;
std::cout << "d: " << d << '\n';
\end{cpp}

This makes it easy to just print any chrono value. However, the output does not always fit specific needs. For type year\_month\_day, the output format is what we as programmers would expect for such a type: year-month-day. For example:

\begin{shell}
2021-01-05
\end{shell}

The other default output formats usually use a slash as the separator, which is documented here.

For user-defined output, the chrono library also supports the new library for formatted output. We use that later to print out the timepoint tp:

\begin{cpp}
std::cout << std::format("We meet on {:%D at %R}\n", tp);
\end{cpp}

Formatting specifiers such as \%A for the weekday, \%D for the date, and \%R for the time (hour and minute) correspond with the specifiers for the C function strftime() and the POSIX date command, so that the output might, for example, look as follows:

\begin{shell}
We meet on 10/05/21 at 18:30
\end{shell}

Locale-specific output is also supported. The details of formatted output for chrono types is described later in detail.

\mySamllsection{Combining Dates and Times}

To initialize tp, we combine the days of the loop with a specific time of the day:

\begin{cpp}
auto tp{sys_days{d} + 18h + 30min};
\end{cpp}

To combine dates and times we have to use timepoints and durations. A calendrical type such as std::chrono::year\_month\_day is not a timepoint. Therefore, we first convert the year\_month\_day value to a time\_point<> object:

\begin{cpp}
std::chrono::year_month_day d = ... ;
std::chrono::sys_days{d} // convert to a time_point
\end{cpp}

The type std::chrono::sys\_days is a new shortcut for system timepoints with the granularity of days. It is equivalent to: std::chrono::time\_point<std::chrono::system\_clock, std::chrono::days>.

By adding some durations (18 hours and 30 minutes), we compute a new value, which—as usual in the chrono library—has a type with a granularity that is good enough for the result of the computation. Because we combine days with hours and minutes, the resulting type is a system timepoint with the granularity of minutes. However, we do not have to know the type. Just using auto works fine.

To specify the type of tp more explicitly, we could also declare it as follows:

\begin{itemize}
\item 
As system timepoint without specifying its granularity:

\begin{cpp}
chr::sys_time tp{chr::sys_days{d} + 18h + 30min};
\end{cpp}

Thanks to class template argument deduction, the template parameter for the granularity is deduced.

\item
As system timepoint with a specified granularity:

\begin{cpp}
chr::sys_time<chr::minutes> tp{chr::sys_days{d} + 18h + 30min};
\end{cpp}

In this case, the initial value must not be more fine grained than the specified type or you have to use rounding functions.

\item
As system timepoint convenient type for seconds as granularity:

\begin{cpp}
chr::sys_seconds tp{chr::sys_days{d} + 18h + 30min};
\end{cpp}

Again, the initial value must not be more fine grained than the specified type or you have to use rounding functions.
\end{itemize}

In all these cases, the default output operator prints the timepoint according to the specified format as described above. For example:

\begin{shell}
We meet on 10/05/21 at 18:30
\end{shell}

Note that when dealing with system time, by default the output is UTC.

A more fine-grained timepoint would also use whatever is necessary to output the exact value (such as milliseconds). See later.

\mySubsubsection{11.1.2}{Scheduling a Meeting on the Last Day of Every Month}

Let us modify the first example program by iterating over the last days of each month. The way you can do that is as follows:

\filename{lib/chrono2.cpp}

\begin{cpp}
#include <chrono>
#include <iostream>

int main()
{
	namespace chr = std::chrono; // shortcut for std::chrono
	using namespace std::literals; // for h, min, y suffixes
	
	// for each last of all months of 2021:
	auto first = 2021y / 1 / chr::last;
	for (auto d = first; d.year() == first.year(); d += chr::months{1}) {
		// print out the date:
		std::cout << d << ":\n";
		
		// init and print 18:30 UTC of those days:
		auto tp{chr::sys_days{d} + 18h + 30min};
		std::cout << std::format(" We meet on {:%A %D at %R}\n", tp);
	}
}
\end{cpp}

All we modified was the initialization of first. We declare it with type auto and initialize it with std::chrono::last as day:

\begin{cpp}
auto first = 2021y / 1 / chr::last;
\end{cpp}

The type std::chrono::last not only represents the last day of a month, it also has the effect that first has a different type: std::chrono::year\_month\_day\_last. The effect is that by adding one month, the day of the date gets adjusted. In fact, the type just always holds the last day. The conversion to the numerical day happens when we output the date and specify a corresponding output format.

As a result, the output changes to the following:

\begin{shell}
2021/Jan/last:
 We meet on Sunday 01/31/21 at 18:30
2021/Feb/last:
 We meet on Sunday 02/28/21 at 18:30
2021/Mar/last:
 We meet on Wednesday 03/31/21 at 18:30
2021/Apr/last:
 We meet on Friday 04/30/21 at 18:30
2021/May/last:
 We meet on Monday 05/31/21 at 18:30
...
2021/Nov/last:
 We meet on Tuesday 11/30/21 at 18:30
2021/Dec/last:
 We meet on Friday 12/31/21 at 18:30
\end{shell}

As you can see, the default output format of year\_month\_day\_last uses last and slashes instead of dashes as a separator (only year\_month\_day uses hyphens in its default output format). For example:

\begin{shell}
2021/Jan/last
\end{shell}

You could still declare first as std::chrono::year\_month\_day:

\begin{cpp}
// for each last days of all months of 2021:
std::chrono::year_month_day first = 2021y / 1 / chr::last;
for (auto d = first; d.year() == first.year(); d += chr::months{1}) {
	// print out the date:
	std::cout << d << ":\n";
	
	// init and print 18:30 UTC of those days:
	auto tp{chr::sys_days{d} + 18h + 30min};
	std::cout << std::format(" We meet on {:%D at %R}\n", tp);
}
\end{cpp}

However, this would cause the following output:

\begin{shell}
2021-01-31:
 We meet on Sunday 01/31/21 at 18:30
2021-02-31 is not a valid date:
 We meet on Wednesday 03/03/21 at 18:30
2021-03-31:
 We meet on Wednesday 03/31/21 at 18:30
2021-04-31 is not a valid date:
 We meet on Saturday 05/01/21 at 18:30
2021-05-31:
 We meet on Monday 05/31/21 at 18:30
...
\end{shell}

Because the type of first stores the numeric value of the day, initialized with the last day of January, we iterate over the 31st day of each month. If such a day does not exist, the default output format prints that this is an invalid date, while std::format() even performs a bad computation.

A way to deal with such situations is to check whether a date is valid and implement what to do then. For example:

\filename{lib/chrono3.cpp}

\begin{cpp}
#include <chrono>
#include <iostream>

int main()
{
	namespace chr = std::chrono; // shortcut for std::chrono
	using namespace std::literals; // for h, min, y suffixes
	
	// for each last of all months of 2021:
	chr::year_month_day first = 2021y / 1 / 31;
	for (auto d = first; d.year() == first.year(); d += chr::months{1}) {
		// print out the date:
		if (d.ok()) {
			std::cout << d << ":\n";
		}
		else {
			// for months not having the 31st use the 1st of the next month:
			auto d1 = d.year() / d.month() / 1 + chr::months{1};
			std::cout << d << ":\n";
		}
		
		// init and print 18:30 UTC of those days:
		auto tp{chr::sys_days{d} + 18h + 30min};
		std::cout << std::format(" We meet on {:%A %D at %R}\n", tp);
	}
}
\end{cpp}

By using the member function ok(), we adjust an invalid date to take the first day of the next month. We get the following output:

\begin{shell}
2021-01-31:
 We meet on Sunday 01/31/21 at 18:30
2021-02-31 is not a valid date:
 We meet on Wednesday 03/03/21 at 18:30
2021-03-31:
 We meet on Wednesday 03/31/21 at 18:30
2021-04-31 is not a valid date:
 We meet on Saturday 05/01/21 at 18:30
2021-05-31:
 We meet on Monday 05/31/21 at 18:30
...
2021-11-31 is not a valid date:
 We meet on Wednesday 12/01/21 at 18:30
2021-12-31:
 We meet on Friday 12/31/21 at 18:30
\end{shell}

\mySubsubsection{11.1.3}{Scheduling a Meeting Every First Monday}

In a similar way, we can schedule a meeting on each first Monday of a month:

\filename{lib/chrono4.cpp}

\begin{cpp}
#include <chrono>
#include <iostream>

int main()
{
	namespace chr = std::chrono; // shortcut for std::chrono
	using namespace std::literals; // for min, h, y suffixes
	
	// for each first Monday of all months of 2021:
	auto first = 2021y / 1 / chr::Monday[1];
	for (auto d = first; d.year() == first.year(); d += chr::months{1}) {
		// print out the date:
		std::cout << d << '\n';
		
		// init and print 18:30 UTC of those days:
		auto tp{chr::sys_days{d} + 18h + 30min};
		std::cout << std::format(" We meet on {:%A %D at %R}\n", tp);
	}
}
\end{cpp}

Again, first has a special type, std::chrono::year\_month\_weekday, which represents a weekday in a month of a year: 

The default output format signals that with a specific format. However, the formatted output works fine:

\begin{shell}
2021/Jan/Mon[1]
 We meet on Monday 01/04/21 at 18:30
2021/Feb/Mon[1]
 We meet on Monday 02/01/21 at 18:30
2021/Mar/Mon[1]
 We meet on Monday 03/01/21 at 18:30
2021/Apr/Mon[1]
 We meet on Monday 04/05/21 at 18:30
2021/May/Mon[1]
 We meet on Monday 05/03/21 at 18:30
...
2021/Nov/Mon[1]
 We meet on Monday 11/01/21 at 18:30
2021/Dec/Mon[1]
 We meet on Monday 12/06/21 at 18:30
\end{shell}

\mySamllsection{Calendrical Types for Weekdays}

This time, we initialize first as an object of the calendrical type std::chrono::year\_month\_weekday and initialize it with the first Monday of January of 2021:

\begin{shell}
auto first = 2021y / 1 / chr::Monday[1];
\end{shell}

Again, we use operator/ to combine different date fields. However, this time, types for weekdays come into play:

\begin{itemize}
\item 
First, we call 2021y / 1 to combine a std::chrono::year with an integral value to create a std::chrono::year\_month.

\item 
Then, we call operator[] for std::chrono::Monday, which is a standard object of type std::chrono::weekday, to create an object of type std::chrono::weekday\_indexed representing the nth weekday.

\item
Finally, operator/ is used to combine the std::chrono::year\_month with the object of type std::chrono::weekday\_indexed, which creates a std::chrono::year\_month\_weekday object.
\end{itemize}

Therefore, a fully specified declaration would look as follows:

\begin{cpp}
std::chrono::year_month_weekday first = 2021y / 1 / std::chrono::Monday[1];
\end{cpp}

Again, note that the default output format of year\_month\_weekday uses slashes instead of dashes as a separator (only year\_month\_day uses hyphens in its default output format). For example:

\begin{shell}
2021/Jan/Mon[1]
\end{shell}

\mySubsubsection{11.1.4}{Using Different Timezones}

Let us modify the first example program to bring timezones into play. In fact, we want the program to iterate over all first Mondays of each month in a year and schedule a meeting in different timezones.

For this we need the following modifications:

\begin{itemize}
\item 
Iterate over all months of the current year

\item 
Schedule the meeting at 18:30 our local time

\item 
Print the meeting time using other timezones
\end{itemize}

The program can now be written as follows:

\filename{lib/chronotz.cpp}

\begin{cpp}
#include <chrono>
#include <iostream>

int main()
{
	namespace chr = std::chrono; // shortcut for std::chrono
	using namespace std::literals; // for min, h, y suffixes
	
	try {
		// initialize today as current local date:
		auto localNow = chr::current_zone()->to_local(chr::system_clock::now());
		chr::year_month_day today{chr::floor<chr::days>(localNow)};
		std::cout << "today: " << today << '\n';
		// for each first Monday of all months of the current year:
		auto first = today.year() / 1 / chr::Monday[1];
		for (auto d = first; d.year() == first.year(); d += chr::months{1}) {
			// print out the date:
			std::cout << d << '\n';
			
			// init and print 18:30 local time of those days:
			auto tp{chr::local_days{d} + 18h + 30min}; // no timezone
			std::cout << " tp: " << tp << '\n';
			
			// apply this local time to the current timezone:
			chr::zoned_time timeLocal{chr::current_zone(), tp}; // local time
			std::cout << " local: " << timeLocal << '\n';
			
			// print out date with other timezones:
			chr::zoned_time timeUkraine{"Europe/Kiev", timeLocal}; // Ukraine time
			chr::zoned_time timeUSWest{"America/Los_Angeles", timeLocal}; // Pacific time
			std::cout << " Ukraine: " << timeUkraine << '\n';
			std::cout << " Pacific: " << timeUSWest << '\n';
		}
	}
	catch (const std::exception& e) {
		std::cerr << "EXCEPTION: " << e.what() << '\n';
	}
}
\end{cpp}

Starting the program in Europe in 2021 results in the following output:

\begin{shell}
today: 2021-03-29
2021/Jan/Mon[1]
    tp:      2021-01-04 18:30:00
    local:   2021-01-04 18:30:00 CET
    Ukraine: 2021-01-04 19:30:00 EET
    Pacific: 2021-01-04 09:30:00 PST
2021/Feb/Mon[1]
    tp:      2021-02-01 18:30:00
    local:   2021-02-01 18:30:00 CET
    Ukraine: 2021-02-01 19:30:00 EET
    Pacific: 2021-02-01 09:30:00 PST
2021/Mar/Mon[1]
    tp:      2021-03-01 18:30:00
    local:   2021-03-01 18:30:00 CET
    Ukraine: 2021-03-01 19:30:00 EET
    Pacific: 2021-03-01 09:30:00 PST
2021/Apr/Mon[1]
    tp:      2021-04-05 18:30:00
    local:   2021-04-05 18:30:00 CEST
    Ukraine: 2021-04-05 19:30:00 EEST
    Pacific: 2021-04-05 09:30:00 PDT
2021/May/Mon[1]
    tp:      2021-05-03 18:30:00
    local:   2021-05-03 18:30:00 CEST
    Ukraine: 2021-05-03 19:30:00 EEST
    Pacific: 2021-05-03 09:30:00 PDT
...
2021/Oct/Mon[1]
    tp:      2021-10-04 18:30:00
    local:   2021-10-04 18:30:00 CEST
    Ukraine: 2021-10-04 19:30:00 EEST
    Pacific: 2021-10-04 09:30:00 PDT
2021/Nov/Mon[1]
    tp:      2021-11-01 18:30:00
    local:   2021-11-01 18:30:00 CET
    Ukraine: 2021-11-01 19:30:00 EET
    Pacific: 2021-11-01 10:30:00 PDT
2021/Dec/Mon[1]
    tp:      2021-12-06 18:30:00
    local:   2021-12-06 18:30:00 CET
    Ukraine: 2021-12-06 19:30:00 EET
    Pacific: 2021-12-06 09:30:00 PST
\end{shell}

Look at the output for October and November: in Los Angeles, the meeting is now scheduled at different times although the same timezone PDT is used. That happens because the source for the meeting time (central Europe) changed from summer to winter/standard time.

Again, let us go through the modifications of this program step by step.

\mySamllsection{Dealing with Today}

The first new statement is the initialization of today as an object of type year\_month\_day:

\begin{cpp}
auto localNow = chr::current_zone()->to_local(chr::system_clock::now());
chr::year_month_day today = chr::floor<chr::days>(localNow);
\end{cpp}

Support for std::chrono::system\_clock::now() has already been provided since C++11 and yields a std::chrono::time\_point<> with the granularity of the system clock. This system clock uses UTC (since C++20, the system\_clock is guaranteed to use Unix time, which is based on UTC). Therefore, we first have to adjust the current UTC time and date to the time and date of the current/local timezone, which current\_zone()->to\_local() does. Otherwise, our local date might not fit the UTC date (because we have already passed midnight but UTC has not, or the other way around).

Using localNow directly to initialize a year\_month\_day value does not compile, because we would “narrow” the value (lose the hours, minutes, seconds, and subseconds parts of the value). By using a convenience function such as floor() (available since C++17), we round the value down according to our requested granularity.

If you need the current date according to UTC, the following would be enough:

\begin{cpp}
chr::year_month_day today = chr::floor<chr::days>(chr::system_clock::now());
\end{cpp}

\mySamllsection{Local Dates and Times}

Again, we combine the days we iterate over with a specific time of day. However, this time, we convert each day to type std::chrono::local\_days first:

\begin{cpp}
auto tp{chr::local_days{d} + 18h + 30min};
\end{cpp}

The type std::chrono::local\_days is a shortcut of time\_point<local\_t, days>. Here, the pseudo clock std::chrono::local\_t is used, which means that we have a local timepoint, a timepoint with no associated timezone (not even UTC) yet.

The next statement combines the local timepoint with the current timezone so that we get a time-zone specific point of time of type std::chrono::zoned\_time<>:

\begin{cpp}
chr::zoned_time timeLocal{chr::current_zone(), tp}; // local time
\end{cpp}

Note that a timepoint is already associated with the system clock, which means that it already associates the time with UTC. Combining such a timepoint with a different timezone converts the time to a specific timezone.

The default output operators demonstrate the difference between a timepoint and a zoned time:

\begin{cpp}
auto tpLocal{chr::local_days{d} + 18h + 30min}; // local timepoint
std::cout << "timepoint: " << tpLocal << '\n';

chr::zoned_time timeLocal{chr::current_zone(), tpLocal}; // apply to local timezone
std::cout << "zonedtime: " << timeLocal << '\n';
\end{cpp}

This code outputs, for example:

\begin{shell}
timepoint: 2021-01-04 18:30:00
zonedtime: 2021-01-04 18:30:00 CET
\end{shell}

You see that the timepoint is printed without a timezone while the zoned time has a timezone. However, both outputs print the same time because we apply a local timepoint to our local timezone.

In fact, the difference between timepoints and zoned times is as follows:

\begin{itemize}
\item 
A timepoint may be associated with a defined epoch. It may define a unique point in time; however, it might also be associated with an undefined or pseudo epoch, for which the meaning is not clear yet until we combine it with a timezone.

\item 
A zoned time is always associated with a timezone so that the epoch finally has a defined meaning. It always represents a unique point in time.
\end{itemize}

Look what happens when we use std::chrono::sys\_days instead of std::chrono::local\_days:

\begin{cpp}
auto tpSys{chr::sys_days{d} + 18h + 30min}; // system timepoint
std::cout << "timepoint: " << tpSys << '\n';

chr::zoned_time timeSys{chr::current_zone(), tpSys}; // convert to local timezone
std::cout << "zonedtime: " << timeSys << '\n';
\end{cpp}

Here we use a system timepoint, which has an associated timezone UTC. While a local timepoint is applied to a timezone, as system timepoint is converted to a timezone. Therefore, when we run the program in a timezone with one hour difference we get the following output:

\begin{shell}
timepoint: 2021-01-04 18:30:00
zonedtime: 2021-01-04 19:30:00 CET
\end{shell}

\mySamllsection{Using Other Timezones}

Finally, we print the timepoint using different timezones, one for the Ukraine (the nation Russia waged a war on) passing Kiev and one for the Pacific timezone in North America passing Los Angeles:

\begin{cpp}
chr::zoned_time timeUkraine{"Europe/Kiev", timeLocal}; // Ukraine time
chr::zoned_time timeUSWest{"America/Los_Angeles", timeLocal}; // Pacific time
std::cout << " Ukraine: " << timeUkraine << '\n';
std::cout << " Pacific: " << timeUSWest << '\n';
\end{cpp}

To specify a timezone, we have to use the official timezone names of the IANA timezone database, which is usually based on cities that represent the timezones. Timezone abbreviations such as PST may change over the year or apply to different timezones.

Using the default output operator of these objects adds the corresponding timezone abbreviation, whether it is in “winter time:”

\begin{shell}
local:   2021-01-04 18:30:00 CET
Ukraine: 2021-01-04 19:30:00 EET
Pacific: 2021-01-04 09:30:00 PST
\end{shell}

or whether it is in “summer time:”

\begin{shell}
local:   2021-07-05 18:30:00 CEST
Ukraine: 2021-07-05 19:30:00 EEST
Pacific: 2021-07-05 09:30:00 PDT
\end{shell}

Sometimes, some timezones are in summer time while others are not. For example, at the beginning of November we have daylight/summer time in the US but not in the Ukraine:

\begin{shell}
local:   2021-11-01 18:30:00 CET
Ukraine: 2021-11-01 19:30:00 EET
Pacific: 2021-11-01 10:30:00 PDT
\end{shell}

\mySamllsection{When Timezones Are Not Supported}

C++ can exist and be useful on small systems, even on a toaster. In that case, the availability of the IANA timezone database would cost far too much resources. Therefore, it is not required that the timezone database exists.

All timezone-specific calls throw an exception, if the timezone database is not supported. For this reason, you should catch exceptions when using timezones in a portable C++ program:

\begin{cpp}
try {
	// initialize today as current local date:
	auto localNow = chr::current_zone()->to_local(chr::system_clock::now());
	...
}
catch (const std::exception& e) {
	std::cerr << "EXCEPTION: " << e.what() << '\n'; // IANA timezone DB missing
}
\end{cpp}

Note that for Visual C++, this also applies to older Windows systems, because the required OS support does not exist before Windows 10.
In addition, platforms may support the timezone API without using all of the IANA timezone database.

For example, with a German Windows 11 installation, I get output such as GMT-8 and GMT-7 instead of PST and PDT.















