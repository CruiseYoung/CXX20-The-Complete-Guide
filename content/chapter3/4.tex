
Concepts might check both syntactic and semantic constraints:

\begin{itemize}
\item
Syntactic constraints mean that at compile time, we can check whether certain functional requirements are satisfied (“Is a specific operation supported?” or “Does a specific operation yield a specific type?”).

\item
Semantic constraints mean that certain requirements are satisfied that can only be checked at runtime (“Does an operation have the same effect?” or “Does the same operation performed for a specific value always yield the same result?”).
\end{itemize}

Sometimes, concepts allow programmers to convert semantic constraints into syntactic constraints by providing an interface to specify that a semantic constraint is fulfilled or is not fulfilled.

\mySubsubsection{3.4.1}{Examples of Semantic Constraints}

Let us look at some examples of semantic constraints.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::sized\_range}

An example of a semantic constraint is the concept std::ranges::sized\_range. It guarantees that the number of elements in a range can be computed in constant time (either by calling the member size() or by computing the difference between the beginning and the end).

If a range type provides size() (as a member function or as a free-standing function), this concept is fulfilled by default. To opt out from this concept (e.g., because it iterates over all elements to yield its result), you can and should set std::disable\_sized\_range<Rg> to true:

\begin{cpp}
class MyCont {
	...
	std::size_t size() const; // assume this is expensive, so that this is not a sized range
};
// opt out from concept std::ranges::sized_range:
constexpr bool std::ranges::disable_sized_range<MyCont> = true;
\end{cpp}

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::ranges::range vs. std::ranges::view}

A similar example of a semantic constraint is the concept std::ranges::view. Besides some syntactic constraints, it also guarantees that move constructor/assignment, copy constructor/assignment (if available), and destructor have constant complexity (the time they take does not depend on the number of elements).

An implementor can provide the corresponding guarantee by deriving publicly from either std::ranges::view\_base or std::ranges::view\_interface<> or by setting the template specialization std::ranges::enable\_view<Rg> to true.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::invocable vs. std::regular\_invocable}

A simple example of a semantic constraint is the difference between the concepts std::invocable and std::regular\_invocable. The latter guarantees not to modify the state of the passed operation and the passed arguments.

However, we cannot check the difference between these two concepts with a compiler. Therefore, the concept std::regular\_invocable documents the intention of the specified API. Often, for simplicity, just std::invocable is used.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{std::weakly\_incrementable vs. std::incrementable}

Besides certain syntactic differences, there are also semantic differences between the concepts incrementable and weakly\_incrementable:

\begin{itemize}
\item
incrementable requires that each increment of the same value gives the same result.

\item
weakly\_incrementable requires only that a type supports the increment operators. Incrementing the same value may yield different results.
\end{itemize}

Therefore:

\begin{itemize}
\item
When incrementable is satisfied, you can iterate multiple times from a starting value over a range.

\item
When only weakly\_incrementable is satisfied, you can iterate over a range only once. A second iteration with the same starting value might yield different results.
\end{itemize}

This difference matters for iterators: input stream iterators (iterators that read values from a stream) can iterate only once because the next iteration yields different values. Consequently, input stream iterators satisfy the weakly\_incrementable concept but not the incrementable concept. However, the concepts cannot be used to check for this difference:

\begin{cpp}
std::weakly_incrementable<std::istream_iterator<int>> // yields true
std::incrementable<std::istream_iterator<int>> // OOPS: also yields true
\end{cpp}

The reason is that the difference is a semantic constraint that cannot be checked at compile time. Therefore, the concepts can be used to document the constraints:

\begin{cpp}
template<std::weakly_incrementable T>
void algo1(T beg, T end); // single-pass algorithm

template<std::incrementable T>
void algo2(T beg, T end); // multi-pass algorithm
\end{cpp}

Note that we use different names for the algorithms here. Due to the fact that we cannot check the semantic difference of the constraints, it is up to the programmer to not pass an input stream iterator:

\begin{cpp}
algo1(std::istream_iterator<int>{std::cin}, // OK
	  std::istream_iterator<int>{});

algo2(std::istream_iterator<int>{std::cin}, // OOPS: violates constraint
	  std::istream_iterator<int>{});
\end{cpp}

However, you cannot distinguish between two implementations based on this difference:

\begin{cpp}
template<std::weakly_incrementable T>
void algo(T beg, T end); // single-pass implementation

template<std::incrementable T>
void algo(T beg, T end); // multi-pass implementation
\end{cpp}

If you pass an input stream iterator here, the compiler will incorrectly use the multi-pass implementation:

\begin{cpp}
algo(std::istream_iterator<int>{std::cin}, // OOPS: calls the wrong overload
	 std::istream_iterator<int>{});
\end{cpp}

Fortunately, there is a solution here, because for this semantic difference, C++98 had already introduced iterator traits, which are used by the iterator concepts. If you use these concepts (or the corresponding range concepts), everything works fine:

\begin{cpp}
template<std::input_iterator T>
void algo(T beg, T end); // single-pass implementation
	
template<std::forward_iterator T>
void algo(T beg, T end); // multi-pass implementation

algo(std::istream_iterator<int>{std::cin}, // OK: calls the right overload
	std::istream_iterator<int>{});
\end{cpp}

You should prefer the more specific concepts for iterators and ranges, which also honor the new and slightly modified iterator categories.


















