Let us finally elaborate on the evaluation of expressions with comparison operators with the support of rewritten calls.


\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Calling Equality Operators}

To compile

\begin{cpp}
x != y
\end{cpp}

the compiler might now try all of the following:

\begin{cpp}
x.operator!=(y) // calling member operator!= for x
operator!=(x, y) // calling a free-standing operator!= for x and y

!x.operator==(y) // calling member operator== for x
!operator==(x, y) // calling a free-standing operator== for x and y

!x.operator==(y) // calling member operator== generated by operator<=> for x

!y.operator==(x) // calling member operator== generated by operator<=> for y
\end{cpp}

The last form is tried to support an implicit type conversion for the first operand, which requires that the operand is a parameter.

In general, the compiler tries to call:

\begin{itemize}
\item
A free-standing operator !=: operator!=(x, y) or a member operator !=: x.operator!=(y)

Having both operators != defined is an ambiguity error.

\item
A free-standing operator ==: !operator==(x, y) or a member operator ==: !x.operator==(y)

Note that the member operator == may be generated from a defaulted operator<=> member.

Again, having both operators == defined is an ambiguity error. This also applies if the member

operator== is generated due to a defaulted operator<=>.
\end{itemize}

When an implicit type conversion for the first operand v is necessary, the compiler also tries to reorder the operands. Consider:

\begin{cpp}
42 != y // 42 implicitly converts to the type of y
\end{cpp}

In that case, the compiler tries to call in that order:

\begin{itemize}
\item
A free-standing or member operator !=

\item
A free-standing or member operator == (note that the member operator == may be generated from a defaulted operator<=> member) [The original C++20 standard was fixed here slightly with \url{http://wg21.link/p2468r2}.]
\end{itemize}

Note that a rewritten expression never tries to call a member operator !=.

\noindent
\hspace*{\fill} \\ %插入空行
\textbf{Calling Relational Operators}

For the relational operators we have similar behavior, except that the rewritten statements fall back on the new operator <=> and compare the result with 0. The operator behaves like a three-way comparison function returning a negative value for less, 0 for equal, and a positive value for greater (the returned value is not a numeric value; it is only a value that supports the corresponding comparisons).

For example, to compile

\begin{cpp}
x <= y
\end{cpp}

the compiler might now try all of the following:

\begin{cpp}
x.operator<=(y) // calling member operator<= for x
operator<=(x, y) // calling a free-standing operator<= for x and y

x.operator<=>(y) <= 0 // calling member operator<=> for x
operator<=>(x, y) <= 0 // calling a free-standing operator<=> for x and y

0 <= y.operator<=>(x) // calling member operator<=> for y
\end{cpp}

Again, the last form is tried to support an implicit type conversion for the first operand, for which it has to become a parameter.






