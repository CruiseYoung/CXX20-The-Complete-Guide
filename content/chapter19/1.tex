
Since C++20, you can use new types for non-type template paramet

\begin{itemize}
\item 
Floating-point types (such as double)

\item 
Structures and simple classes (such as std::pair<>), which indirectly also allows you to use string literals as template parameters

\item 
Lambdas
\end{itemize}

In fact, non-type template parameters may now be all structural types. A structural type is a type that

\begin{itemize}
\item 
either is a (const or volatile qualified) arithmetic, enum, or pointer type

\item 
or and lvalue reference type

\item 
or a literal type (is either an aggregate or has a constexpr constructor, no copy/move constructor, no destructor, no copy/move constructor or destructor, and where every initialization of data members is a constant expression) where:

\begin{itemize}
\item 
All non-static members are public and not mutable and use only structural types or arrays thereof

\item 
All base classes (if there are any) are inherited publicly and also structural types
\end{itemize}
\end{itemize}

Let us look at what the consequences of this new definition are.

\mySubsubsection{19.1.1}{Floating-Point Values as Non-Type Template Parameters}

Consider the following example:

\filename{lang/nttpdouble.cpp}

\begin{cpp}
#include <iostream>
#include <cmath>

template<double Vat>
int addTax(int value)
{
	return static_cast<int>(std::round(value * (1 + Vat)));
}

int main()
{
	std::cout << addTax<0.19>(100) << '\n';
	std::cout << addTax<0.19>(4199) << '\n';
	std::cout << addTax<0.07>(1950) << '\n';
}
\end{cpp}

The output of the program is as follows:

\begin{shell}
119
4997
2087
\end{shell}

By declaring addTax() as follows:

\begin{cpp}
template<double Vat>
int addTax(int value)
\end{cpp}

the function template addTax() takes a double as a template parameter, which is then used as value-added tax to add it to an integral value.

Passing a floating-point value is now also allowed when the non-type template parameter is declared with auto:

\begin{cpp}
template<auto Vat>
int addTax(int value)
{
	...
}

std::cout << addTax<0>(1950) << '\n'; // Vat is the int value 0
std::cout << addTax<0.07>(1950) << '\n'; // Vat is the double value 0.07
\end{cpp}

In the same way, you can now use floating-point values in class templates (declared as double or as auto):

\begin{cpp}
template<double Vat>
class Tax {
	...
};
\end{cpp}

\mySamllsection{Dealing with Inexact Floating-Point Values}

Due to rounding errors, values of floating-point types end up being slightly imprecise. This has an effect when dealing with floating-point values as template parameters. The issue is, when two instantiations of a template have the same type.

Consider the following example:

\filename{lang/nttpdouble2.cpp}

\begin{cpp}
#include <iostream>
#include <limits>
#include <type_traits>

template<double Val>
class MyClass {
};

int main()
{
	std::cout << std::boolalpha;
	std::cout << std::is_same_v<MyClass<42.0>, MyClass<17.7>> // always false
			  << '\n';
	std::cout << std::is_same_v<MyClass<42.0>, MyClass<126.0 / 3>> // true or false
			  << '\n';
	std::cout << std::is_same_v<MyClass<42.7>, MyClass<128.1/ 3>> // true or false
			  << "\n\n";
	std::cout << std::is_same_v<MyClass<0.1 + 0.3 + 0.00001>,
	MyClass<0.3 + 0.1 + 0.00001>> // true or false
			  << '\n';
	std::cout << std::is_same_v<MyClass<0.1 + 0.3 + 0.00001>,
	MyClass<0.00001 + 0.3 + 0.1>> // true or false
			  << "\n\n";
	constexpr double NaN = std::numeric_limits<double>::quiet_NaN();
	std::cout << std::is_same_v<MyClass<NaN>, MyClass<NaN>> // always true
			  << '\n';
}
\end{cpp}

The output of this program depends on the platform. Often, it is as follows:

\begin{shell}
false
true
false
---
true
false
---
true
\end{shell}

Note that templates instantiated for NaN always have the same type even though NaN == NaN is false.

\mySubsubsection{19.1.2}{Objects as Non-Type Template Parameters}

Since C++20, you can use an object/value of a data structure or class as a non-type template parameter provided all members are public and the type is a literal type.

Consider the following example:

\filename{lang/nttpstruct.cpp}

\begin{cpp}
#include <iostream>
#include <cmath>
#include <cassert>

struct Tax {
	double value;
	
	constexpr Tax(double v)
	: value{v} {
		assert(v >= 0 && v < 1);
	}
	
	friend std::ostream& operator<< (std::ostream& strm, const Tax& t) {
		return strm << t.value;
	}
};

template<Tax Vat>
int addTax(int value)
{
	return static_cast<int>(std::round(value * (1 + Vat.value)));
}

int main()
{
	constexpr Tax tax{0.19};
	std::cout << "tax: " << tax << '\n';
	
	std::cout << addTax<tax>(100) << '\n';
	std::cout << addTax<tax>(4199) << '\n';
	std::cout << addTax<Tax{0.07}>(1950) << '\n';
}
\end{cpp}

Here, we declare a literal data structure Tax with public members, a constexpr constructor, and an additional member function:

\begin{cpp}
struct Tax {
	double value;
	constexpr Tax(double v) {
		...
	}
	friend std::ostream& operator<< (std::ostream& strm, const Tax& t) {
		...
	}
};
\end{cpp}

This allows us to pass objects of this type as template arguments:

\begin{cpp}
constexpr Tax tax{0.19};
std::cout << "tax: " << tax << '\n';
std::cout << addTax<tax>(100) << '\n'; // pass Tax object as a template argument
\end{cpp}

This works if the data structure or class is a structural type. This roughly means that:

\begin{itemize}
\item 
All non-static members are public and not mutable and use only structural types or arrays thereof

\item 
All base classes (if there are any) are inherited publicly and also structural types

\item 
The type is a literal type (is either an aggregate or has a constexpr constructor, no copy/move constructor, no destructor, no copy/move constructor or destructor, and where every initialization of data members is a constant expression)
\end{itemize}

For example:

\filename{lang/nttpstruct2.cpp}

\begin{cpp}
#include <iostream>
#include <array>

constexpr int foo()
{
	return 42;
}

struct Lit {
	int x = foo(); // OK because foo() is constexpr
	int y;
	constexpr Lit(int i) // OK because constexpr
		: y{i} {
	}
};

struct Data {
	int i;
	std::array<double,5> vals;
	Lit lit;
};

template<auto Obj>
void func()
{
	std::cout << typeid(Obj).name() << '\n';
}

int main()
{
	func<Data{42, {1, 2, 3}, 42}>(); // OK
	
	constexpr Data d2{1, {2}, 3};
	func<d2>();
}
\end{cpp}

Type Type cannot be used if its constructor or foo() would not be constexpr or a std::string member would be used.

\mySamllsection{std::pair<> and std::array<> Values as Non-Type Template Parameters}

As a consequence, you can now use compile-time objects of types std::pair<> and std::array<> as template parameters:

[For this, C++ had to add the additional requirement that std::pair<> and std::array<> may not be implemented with a private base class, which some implementers did before C++20 (see \url{http://wg21.link/lwg3382}).]

\begin{cpp}
template<auto Val>
class MyClass {
	...
};

MyClass<std::pair{47,11}> mcp; // OK since C++20
MyClass<std::array{0, 8, 15}> mca; // OK since C++20
\end{cpp}

\mySamllsection{Strings as Non-Type Template Parameters}

Note that a data structure that has a character array as a public member is a structural type. That way, we can now quite easily pass string literals as template arguments.

For example:

\filename{lang/nttpstring.cpp}

\begin{cpp}
#include <iostream>
#include <string_view>

template<auto Prefix>
class Logger {
	...
public:
	void log(std::string_view msg) const {
		std::cout << Prefix << msg << '\n';
	}
};

template<std::size_t N>
struct Str {
	char chars[N];
	const char* value() {
		return chars;
	}
	friend std::ostream& operator<< (std::ostream& strm, const Str& s) {
		return strm << s.chars;
	}
};
template<std::size_t N> Str(const char(&)[N]) -> Str<N>; // deduction guide

int main()
{
	Logger<Str{"> "}> logger;
	logger.log("hello");
}
\end{cpp}

The program has the following output:

\begin{shell}
> hello
\end{shell}

\mySubsubsection{19.1.3}{Lambdas as Non-Type Template Parameters}

Because lambdas are just shortcuts for function objects, they can now also be used as non-type template parameters provided the lambda can be used at compile time.

Consider the following example:

\filename{lang/nttplambda.cpp}

\begin{cpp}
#include <iostream>
#include <cmath>

template<std::invocable auto GetVat>
int addTax(int value)
{
	return static_cast<int>(std::round(value * (1 + GetVat())));
}

int main()
{
	auto getDefaultTax = [] {
		return 0.19;
	};
	std::cout << addTax<getDefaultTax>(100) << '\n';
	std::cout << addTax<getDefaultTax>(4199) << '\n';
	std::cout << addTax<getDefaultTax>(1950) << '\n';
}
\end{cpp}

The function template addTax() uses a helper function, which can now also be a lambda:

\begin{cpp}
template<std::invocable auto GetVat>
int addTax(int value)
{
	return static_cast<int>(std::round(value * (1 + GetVat())));
}
\end{cpp}

We can now pass a lambda to this function template:

\begin{cpp}
auto getDefaultTax = [] {
	return 0.19;
};

addTax<getDefaultTax>(100) // passes lambda as template argument
\end{cpp}

We could even define the lambda directly when calling the function template:

\begin{cpp}
addTax<[]{ return 0.19; }>(100) // passes lambda as template argument
\end{cpp}

Note that it is a good idea to constrain the template parameter with the concepts std::invocable or std::regular\_invocable. That way, you can document and ensure that the passed callable can be called with arguments of the specified types.

By using just std::invocable auto, we require that the callable takes no arguments. If the passed callable should take arguments, you need something like this:

\begin{cpp}
template<std::invocable<std::string> auto GetVat>
int addTax(int value, const std::string& name)
{
	double vat = GetVat(name); // get VAT according to the passed name
	...
}
\end{cpp}

Note that you cannot skip auto in the declaration of the function template. We use std::invocable as a type constraint for the type a passed value/object/callback has:

\begin{cpp}
template<std::invocable auto GetVat> // GetVat is a callable with constrained type
\end{cpp}

Without auto, we would declare a function template that has an ordinary type parameter, which we constrain:

\begin{cpp}
template<std::invocable GetVat> // GetVat is a constrained type
\end{cpp}

It would also work if we declare the function template with the concrete type of the lambda (which, however, means that we have to define the lambda first):

\begin{cpp}
auto getDefaultTax = [] {
	return 0.19;
};

template<decltype(getDefaultTax) GetVat>
int addTax(int value)
{
	return static_cast<int>(std::round(value * (1 + GetVat())));
}
\end{cpp}

Note the following constraints for using lambdas as non-type template parameters:

\begin{itemize}
\item 
The lambda may not capture anything.

\item
In must be possible to use the lambda at compile time.
\end{itemize}

Fortunately, since C++17, any lambda is implicitly constexpr provided it uses only features that are valid for compile-time computing. Alternatively, you can declare the lambda with constexpr or consteval to get an error on the lambda itself instead of when using it as a template parameter if invalid compile-time features are used.









