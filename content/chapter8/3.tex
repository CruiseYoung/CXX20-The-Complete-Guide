
本节讨论C++20中创建引用现有外部值的视图的所有特性(通常作为单个范围参数传递，作为开始迭代器和哨兵，或作为开始迭代器和计数)。

\mySubsubsection{8.3.1}{子范围}

\begin{longtable}[c]{|l|l|}
\hline
\textbf{类型:}                 & std::ranges::subrange\textless{}\textgreater{} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{内容:}              & 从传递开始到结束的所有元素   \\ \hline
\textbf{工厂:}      & \begin{tabular}[c]{@{}l@{}}std::views::counted()\\ std::views::reverse()在逆子范围上\end{tabular} \\ \hline
\textbf{元素类型:}         & 传递迭代器中值的类型               \\ \hline
\textbf{要求:}             & 至少是输入迭代器                       \\ \hline
\textbf{类别:}             & 和传入的一样                                 \\ \hline
\textbf{是否为有限范围:} & 若传递的是普通随机访问迭代器或是长度提示                                                \\ \hline
\textbf{是否为常规范围:}      & 若在通用迭代器上                         \\ \hline
\textbf{是否为租借范围:}    & 总是                                         \\ \hline
\textbf{缓存:}               & 无                                        \\ \hline
\textbf{常量可迭代:}       & 若传递的迭代器可复制               \\ \hline
\textbf{传播常量性:} & 从不                                          \\ \hline
\end{longtable}

类模板std::ranges::subrange<>定义了一个范围元素的视图，通常以开始迭代器和哨兵(结束迭代器)对的形式传递，也可以传递单个范围对象，并间接传递开始迭代器和计数。在内部，视图本身通过存储开始(迭代器)和结束(哨兵)来展示元素。

子范围视图的主要用例是将一对开始迭代器和哨兵(结束迭代器)转换为一个对象。例如:

\begin{cpp}
std::vector<int> coll{0, 8, 15, 47, 11, -1, 13};

std::ranges::subrange s1{std::ranges::find(coll, 15),
						std::ranges::find(coll, -1)};
print(coll); // 15 47 11
\end{cpp}

你可以用结束值的特殊哨兵来初始化子范围:

\begin{cpp}
std::ranges::subrange s2{coll.begin() + 1, EndValue<-1>{}};
print(s2); // 8 15 47 11
\end{cpp}

这两种方法在将一对迭代器转换为范围/视图时都特别有用，例如，这样范围适配器就可以处理元素:

\begin{cpp}
void foo(auto beg, auto end)
{
	// init view for all but the first five elements (if there are any):
	auto v = std::ranges::subrange{beg, end} | std::views::drop(5);
	...
}
\end{cpp}

下面是演示子范围用法的完整示例:

\filename{ranges/subrange.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <unordered_map>
#include <ranges>

void printPairs(auto&& rg)
{
	for (const auto& [key, val] : rg) {
		std::cout << key << ':' << val << ' ';
	}
	std::cout << '\n';
}

int main()
{
	// English/German dictionary:
	std::unordered_multimap<std::string,std::string> dict = {
		{"strange", "fremd"},
		{"smart", "klug"},
		{"car", "Auto"},
		{"smart","raffiniert"},
		{"trait", "Merkmal"},
		{"smart", "elegant"},
	};
	
	// get begin and end of all elements with translation of "smart":
	auto [beg, end] = dict.equal_range("smart");
	
	// create subrange view to print all translations:
	printPairs(std::ranges::subrange(beg, end));
}
\end{cpp}

该程序有以下输出:

\begin{shell}
smart:klug smart:elegant smart:raffiniert
\end{shell}

equal\_range()返回了键为"smart"的dict中所有元素的开头和结尾，这里使用一个子范围将这两个迭代器转换为一个视图(这里是字符串对元素的视图):

\begin{cpp}
std::ranges::subrange(beg, end)
\end{cpp}

然后，可以将视图传递给printPairs()，遍历元素并打印出来。

注意，子范围可以改变它的大小，以便在begin和end都有效的情况下在begin和end之间插入或删除元素:

\begin{cpp}
std::list coll{1, 2, 3, 4, 5, 6, 7, 8};

auto v1 = std::ranges::subrange(coll.begin(), coll.end());
print(v1); // 1 2 3 4 5 6 7 8

coll.insert(++coll.begin(), 0);
coll.push_back(9);
print(v2); // 1 0 2 3 4 5 6 7 8 9
\end{cpp}

\mySamllsection{子范围的工厂}

没有范围工厂用于从begin(迭代器)和end(哨兵)初始化子范围。然而，有一个范围工厂可以从begin和count创建子范围:[C++20最初声明all()也可以产生子范围。当后来引入了所属视图时，这个选项被删除了(参见\url{http://wg21.link/p2415})]

\begin{cpp}
std::views::counted(beg, sz)
\end{cpp}

std::views::counted()创建一个包含非连续范围的前sz个元素的子范围，从迭代器beg引用的元素开始(对于连续范围，counts()创建一个span视图)。

当std::views::counted()创建子范围时，子范围以std::counted\_iterator作为开始，以std::default\_sentinel\_t类型的伪哨兵作为结束:

\begin{cpp}
std::views::counted(rg.begin(), 5);
\end{cpp}

相当于:

\begin{cpp}
std::ranges::subrange{std::counted_iterator{rg.begin(), 5},
	std::default_sentinel};
\end{cpp}

这样做的效果是，即使插入或删除元素，该子范围内的计数仍然保持稳定:

\begin{cpp}
std::list coll{1, 2, 3, 4, 5, 6, 7, 8};

auto v2 = std::views::counted(coll.begin(), coll.size());
print(v2); // 1 2 3 4 5 6 7 8

coll.insert(++coll.begin(), 0);
coll.push_back(9);
print(v2); // 1 0 2 3 4 5 6 7
\end{cpp}

有关详细信息，请参阅std::views::counted()和std::counted\_iterator类型的描述。

下面是一个完整的示例，演示了counted()如何使用子范围:

\filename{ranges/subrangecounted.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <unordered_map>
#include <ranges>

void printPairs(auto&& rg)
{
	for (const auto& [key, val] : rg) {
		std::cout << key << ':' << val << ' ';
	}
	std::cout << '\n';
}

int main()
{
	// English/German dictionary:
	std::unordered_multimap<std::string,std::string> dict = {
		{"strange", "fremd"},
		{"smart", "klug"},
		{"car", "Auto"},
		{"smart","raffiniert"},
		{"trait", "Merkmal"},
		{"smart", "elegant"},
	};
	
	printPairs(dict);
	printPairs(std::views::counted(dict.begin(), 3));
}
\end{cpp}

该程序有以下输出:

\begin{shell}
trait:Merkmal car:Auto smart:klug smart:elegant smart:raffiniert strange:fremd
trait:Merkmal car:Auto smart:klug
\end{shell}

注意，在极少数情况下，std::views::reverse()也可能产生子范围。当反转一个反转的子范围时，就会发生这种情况，将会得到原始的子范围。


\mySamllsection{子范围的特殊特征}

子范围可以是也可以不是一个长度范围。实现的方式是，子范围有第三个模板形参，枚举类型std::ranges::subrange\_kind，它的值可以是std::ranges::unsized或std::ranges::sized。该模板形参的值可以指定，也可以从为迭代器和哨兵类型调用的std::sized\_sentinel\_for概念派生。

会有以下后果:

\begin{itemize}
\item
若传递相同类型的连续迭代器或随机访问迭代器，则子范围的大小为:

\begin{cpp}
std::vector vec{1, 2, 3, 4, 5}; // has random access
...
std::ranges::subrange sv{vec.begin()+1, vec.end()-1}; // sized
std::cout << std::ranges::sized_range<decltype(sv)>; // true
\end{cpp}

\item
若传递的迭代器不支持随机访问或不常见，则子范围不确定大小:

\begin{cpp}
std::list lst{1, 2, 3, 4, 5}; // no random access
...
std::ranges::subrange sl{++lst.begin(), --lst.end()}; // unsized
std::cout << std::ranges::sized_range<decltype(sl)>; // false
\end{cpp}

\item
后一种情况下，可以传递一个长度来使子范围变成一个长度范围:

\begin{cpp}
std::list lst{1, 2, 3, 4, 5}; // no random access
...
std::ranges::subrange sl2{++lst.begin(), --lst.end(), lst.size()-2}; // sized
std::cout << std::ranges::sized_range<decltype(sl2)>; // true
\end{cpp}

若用错误的大小初始化视图，或者在开始和结束之间插入或删除元素之后使用视图，则为未定义行为。
\end{itemize}

\mySamllsection{子范围的接口}

“类std::ranges::subrange<>的操作表”列出了子范围的API。

只有当迭代器是默认可初始化时，才提供默认构造函数。

使用szHint参数的构造函数，允许开发者将未设置长度的范围转换为设置长度的子范围，如上所示。

子范围的迭代器指向底层(或临时创建的)范围，所以子范围是租借范围。但请注意，当底层范围不再存在时，迭代器仍然为悬空。

\mySamllsection{类似元组的子范围接口}

std::ranges::subange也有一个类似于元组的接口来支持结构化绑定(C++17中引入)，所以可以很容易地初始化一个开始迭代器和一个哨兵(结束迭代器)，方法如下:

\begin{cpp}
auto [beg, end] = std::ranges::subrange{coll};
\end{cpp}

为此，提供类std::ranges::subange;

\begin{itemize}
\item
std::tuple\_size<>的特化

\item
std::tuple\_element<>的特化

\item
获取索引0和1的get<>()函数
\end{itemize}

\begin{longtable}[c]{|l|l|}
\hline
\textbf{操作}      & \textbf{效果}                                                           \\ \hline
\endfirsthead
%
\endhead
%
subrange r\{\}          & 创建一个空子范围                                                 \\ \hline
subrange r\{rg\}        & 使用范围rg的元素创建子范围                          \\ \hline
subrange r\{rg, szHint\}       & 使用范围rg的元素创建子范围，指定该范围有szHint个元素           \\ \hline
subrange r\{beg, end\}  & 使用range {[}beg, end)的元素创建子范围                \\ \hline
subrange r\{beg, end, szHint\} & 使用range {[}beg, end)的元素创建子范围，指定该范围有szHint个元素 \\ \hline
r.begin()               & 生成begin迭代器                                                 \\ \hline
r.end()                 & 生成哨兵(end迭代器)                                        \\ \hline
r.empty()               & 生成r是否为空                                                 \\ \hline
if (r)                  & 若r不为空，则为True                                                    \\ \hline
r.size()                & 生成元素的数量(若有长度则可用)                         \\ \hline
r.front()               & 生成第一个元素(若转发可用)                         \\ \hline
r.back()                & 生成最后一个元素(若为双向且通用则可用)           \\ \hline
r{[}idx{]}              & 生成第n个元素(如果随机访问可用)                      \\ \hline
r.data()                & 生成一个指向元素内存的原始指针(若元素在连续内存中可用)。       \\ \hline
r.next()                & 生成从第二个元素开始的子范围                        \\ \hline
r.next(n)               & 生成从第n个元素开始的子范围                          \\ \hline
r.prev()                & 生成从第一个元素之前的元素开始的子范围      \\ \hline
r.prev(n)               & 生成一个子范围，从第n个元素开始，在第一个元素之前 \\ \hline
r.advance(dist)         & 修改r，使其稍后开始num元素(以负num开始较早)                       \\ \hline
auto {[}beg, end{]} = r & 用begin和end/哨兵(r)初始化beg和end                  \\ \hline
\end{longtable}

\begin{center}
表8.4 类std::ranges::subrange<>的操作
\end{center}

\mySamllsection{使用子范围协调原始数组类型}

子范围的类型仅取决于迭代器的类型(以及是否提供了size())，这可以用来协调原始数组的类型。

考虑下面的例子:

\begin{cpp}
int a1[5] = { ... };
int a2[10] = { ... };

std::same_as<decltype(a1), decltype(a2)> // false

std::same_as<decltype(std::ranges::subrange{a1}),
			 decltype(std::ranges::subrange{a2})> // true
\end{cpp}

注意，这只适用于原始数组。对于std::array<>和其他容器，迭代器(可能)具有不同的类型，所以协调的类型与子范围是不可移植的。

\mySubsubsection{8.3.2}{参考视图}

\begin{longtable}[c]{|l|l|}
\hline
\textbf{类型:}                 & std::ranges::ref\_view\textless{}\textgreater{} \\ \hline
\endfirsthead
%
\endhead
%
\textbf{内容:}              & 一个范围的所有元素   \\ \hline
\textbf{工厂:}      & \begin{tabular}[c]{@{}l@{}}std::views::all() and all other adaptors on lvalues\end{tabular} \\ \hline
\textbf{元素类型:}         & 与传入的范围类型相同                 \\ \hline
\textbf{要求:}             & 至少为输入范围                     \\ \hline
\textbf{类别:}             & 与传入相同                                 \\ \hline
\textbf{是否是长度范围:} & 若是长度范围                                                \\ \hline
\textbf{是否是常规范围:}      & 若是常规范围                         \\ \hline
\textbf{是否是租借范围:}    & 总是                                         \\ \hline
\textbf{缓存:}               & 无                                        \\ \hline
\textbf{常量可迭代:}       & 若在可迭代范围内               \\ \hline
\textbf{传播常量性:} & 从不                                          \\ \hline
\end{longtable}

类模板std::ranges::ref\_view<>定义了一个简单引用范围的视图，通过值传递视图的效果就像通过引用传递范围一样。

其效果类似于std::reference\_wrapper<>类型(C++11引入)，对使用std::ref()和std::cref()创建的第一类对象进行引用，但这个包装器的好处仍然可以直接用作范围。

ref\_view的用例是将容器转换为复制成本较低的轻量级对象。例如:

\begin{cpp}
void foo(std::ranges::input_range auto coll) // NOTE: takes range by value
{
	for (const auto& elem : coll) {
		...
	}
}

std::vector<std::string> coll{ ... };

foo(coll); // copies coll
foo(std::ranges::ref_view{coll}); // pass coll by reference
\end{cpp}

将容器传递给协程(通常必须按值接受参数)可能是这种技术的一种应用。

请注意，只能创建一个左值(一个有名字的范围)的参考视图:

\begin{cpp}
std::vector coll{0, 8, 15};
...
std::ranges::ref_view v1{coll}; // OK, refers to coll
std::ranges::ref_view v2{std::move(coll)}; // ERROR
std::ranges::ref_view v3{std::vector{0, 8, 15}}; // ERROR
\end{cpp}

对于右值，必须使用归属视图。

下面是一个使用参考视图的完整示例:

\filename{ranges/refview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <vector>
#include <ranges>

void printByVal(std::ranges::input_range auto coll) // NOTE: takes range by value
{
	for (const auto& elem : coll) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}

int main()
{
	std::vector<std::string> coll{"love", "of", "my", "life"};
	
	printByVal(coll); // copies coll
	printByVal(std::ranges::ref_view{coll}); // pass coll by reference
	printByVal(std::views::all(coll)); // ditto (using a range adaptor)
}
\end{cpp}

\mySamllsection{参考视图的范围适配器}

参考视图也可以(通常应该)用range工厂创建:

\begin{cpp}
std::views::all(rg)
\end{cpp}

std::views::all()创建一个ref\_view到传入的范围rg，前提是rg是左值，而非视图(若rg已经是视图，则返回rg；若传递右值，则返回归属视图)。

此外，若传递的左值还不是视图，几乎所有其他范围适配器也会创建一个参考视图。

上面的示例程序使用这种间接的方式，通过最后一次调用printByVal()创建了一个参考视图。它传递一个std::ranges::ref\_view<std::vector<std::string>{}>{}>:

\begin{cpp}
std::vector<std::string> coll{"love", "of", "my", "life"};
...
printByVal(std::views::all(coll));
\end{cpp}

请注意，所有其他接受范围的视图都间接地为传递的范围调用all()(通过使用std::views::all\_t<>)。出于这个原因，若传递一个不是视图的左值给其中一个视图，一个参考视图总是自动创建的。例如，调用:

\begin{cpp}
std::views::take(coll, 3)
\end{cpp}

基本上与调用以下代码的效果相同:

\begin{cpp}
std::ranges::take_view{std::ranges::ref_view{coll}, 3};
\end{cpp}

但使用适配器时，可能会有一些优化。

详细信息请参见std::views::all()的描述。

\mySamllsection{参考视图的特点}

参考视图存储对基础范围的引用，所以参考视图是一个租借范围。只要引用的视图有效，就可以使用它。例如，若底层视图是一个vector，重新分配并不会使该视图失效。但请注意，当底层范围不再存在时，迭代器仍然可以悬空。

\mySamllsection{参考视图的接口}

“类std::ranges::ref\_view<>的操作表”列出了ref\_view的API。

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{操作} & \textbf{效果}                                                \\ \hline
\endfirsthead
%
\endhead
%
ref\_view r\{rg\}  & 创建一个引用范围rg的ref\_view                 \\ \hline
r.begin()          & 生成begin迭代器                                  \\ \hline
r.end()            & 生成哨兵(end迭代器)                             \\ \hline
r.empty()          & 生成r是否为空(若范围支持则可用) \\ \hline
if(r)              & 若r不为空则为true(若定义了empty()则可用)        \\ \hline
r.size() & 生成元素的数量(若引用了一个长度范围，则可用)                            \\ \hline
r.front()          & 生成第一个元素(若转发可用)              \\ \hline
r.back()           & 生成最后一个元素(若双向且通用则可用) \\ \hline
r{[}idx{]}         & 生成第n个元素(若随机访问可用)            \\ \hline
r.data() & 生成一个指向元素内存的原始指针(若元素在连续内存中可用) \\ \hline
r.base()           & 生成对r所引用的范围的引用               \\ \hline
\end{longtable}

\begin{center}
表8.5 类std::ranges::ref\_view<>的操作表
\end{center}

注意，没有为这个视图提供默认构造函数。

\mySubsubsection{8.3.3}{归属视图}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:}                 & std::ranges::owning\_view\textless{}\textgreater{}  \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}              & All elements of a moved range                       \\ \hline
\textbf{Adaptors:}             & std::views::all() and all other adaptors on rvalues \\ \hline
\textbf{Element type:}         & Same type as passed range                           \\ \hline
\textbf{Requires:}             & At least input range                                \\ \hline
\textbf{Category:}             & Same as passed                                      \\ \hline
\textbf{Is sized range:}       & If on sized range                                   \\ \hline
\textbf{Is common range:}      & If on common range                                  \\ \hline
\textbf{Is borrowed range:}    & If on borrowed range                                \\ \hline
\textbf{Caches:}               & Nothing                                             \\ \hline
\textbf{Const iterable:}       & If on const-iterable range                          \\ \hline
\textbf{Propagates constness:} & Always                                              \\ \hline
\end{longtable}

The class template std::ranges::owning\_view<> defines a view that takes ownership of the elements of another range.[Originally, C++20 did not have an owning view. The view was introduced with a later fix (see \url{http://wg21.link/p2415}).]

This is the only view (so far) that might own multiple elements. However, construction is still cheap, because an initial range has to be an rvalue (temporary object or object marked with std::move()). The constructor will then move the range to an internal member of the view.

For example:

\begin{cpp}
std::vector vec{0, 8, 15};
std::ranges::owning_view v0{vec}; // ERROR
std::ranges::owning_view v1{std::move(vec)}; // OK
print(v1); // 0 8 15
print(vec); // unspecified value (was moved away)

std::array<std::string, 3> arr{"tic", "tac", "toe"};
std::ranges::owning_view v2{arr}; // ERROR
std::ranges::owning_view v2{std::move(arr)}; // OK
print(v2); // "tic" "tac" "toe"
print(arr); // "" "" ""
\end{cpp}

This is the only standard view of C++20 that does not support copying at all. You can only move it. For example:

\begin{cpp}
std::vector coll{0, 8, 15};
std::ranges::owning_view v0{std::move(coll)};

auto v3 = v0; // ERROR
auto v4 = std::move(v0); // OK (range in v0 moved to v4)
\end{cpp}

The major use case of the owning\_view is to create a view from a range without depending on the lifetime of the range anymore. For example:

\begin{cpp}
void foo(std::ranges::view auto coll) // NOTE: takes range by value
{
	for (const auto& elem : coll) {
		...
	}
}

std::vector<std::string> coll{ ... };

foo(coll); // ERROR: no view
foo(std::move(coll)); // ERROR: no view
foo(std::ranges::owning_view{coll}); // ERROR: must pass rvalue
foo(std::ranges::owning_view{std::move(coll)}); // OK: move coll as view
\end{cpp}

Converting a range to an owning view is usually done implicitly by passing a temporary container to a range adaptor (see below).

\mySamllsection{所属视图的范围适配器}

Owning views can also (and usually should) be created with a range factory:

\begin{cpp}
std::views::all(rg)
\end{cpp}

std::views::all() creates an owning\_view to the passed range rg provided rg is an rvalue and not a view yet (all() yields rg if it is already a view and a ref view if otherwise an lvalue is passed).

In addition, almost all other range adaptors also create an owning view if an rvalue is passed that is not a view yet.

The example above can therefore implement the call of foo() as follows:

\begin{cpp}
foo(std::views::all(std::move(coll))); // move coll as view
\end{cpp}

To create an owning view, the adaptor all() requires an rvalue (for an lvalue, all() creates a ref view). This means that you have to pass a temporary range or a named range marked with std::move() (all() yields a ref view if an lvalue is passed).

Here is a complete example:

\filename{ranges/owningview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <vector>
#include <ranges>

auto getColl()
{
	return std::vector<std::string>{"you", "don't", "fool", "me"};
}

int main()
{
	std::ranges::owning_view v1 = getColl(); // view owning a vector of strings
	auto v2 = std::views::all(getColl()); // ditto
	static_assert(std::same_as<decltype(v1), decltype(v2)>);
	
	// iterate over drop view of owning view of vector<string>:
	for (const auto& elem : getColl() | std::views::drop(1)) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}
\end{cpp}

Here, v1 and v2 both have type std::ranges::owning\_view<std::vector<std::string>>>. However, the usual way to create an owning view is demonstrated the range-based for loop at the end of the program: it creates an owning view indirectly when we pass the a temporary container to a range adaptor.

The expression

\begin{cpp}
getColl() | std::views::drop(1)
\end{cpp}

creates a

\begin{cpp}
std::ranges::drop_view<std::ranges::owning_view<std::vector<std::string>>>
\end{cpp}

The way this happens is that the drop view indirectly calls all() for the passed temporary range (by using std::views::all\_t<>).

For more details, see the description of std::views::all().


\mySamllsection{所属视图的特殊特性}

The owning view moves the passed range into itself. Therefore, the owning view is a borrowed range if the range it owns is a borrowed range.

\mySamllsection{所属视图的接口}

Table Operations of the class std::ranges::owning\_view<> lists the API of an owning\_view.

The default constructor is provided only if the iterator is default initializable.

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation}   & \textbf{Effect}                                                \\ \hline
\endfirsthead
%
\endhead
%
owning\_view r\{\}   & Creates an owning\_view that is empty                          \\ \hline
owning\_view r\{rg\} & Craetes an owning\_view that owns the elements of rg           \\ \hline
r.begin()            & Yields the begin iterator                                      \\ \hline
r.end()              & Yields the sentinel(end iterator)                              \\ \hline
r.empty()            & Yields whether r is empty(available if the range supports it)  \\ \hline
if(r)                & true if r is not empty (available if empty() is defined)       \\ \hline
r.size() & Yields the number of elements(available if it refers to a sized range)                             \\ \hline
r.front()            & Yields the first element(available if forwarfing)              \\ \hline
r.back()             & Yields the last element(available if bidirectional and common) \\ \hline
r{[}idx{]}           & Yields the n-th element(available if random access)            \\ \hline
r.data() & Yields a raw pointer to the memory of the elements(available if elements are in contiguous memory) \\ \hline
r.base()             & Yields a reference to the range that rowns                    \\ \hline
\end{longtable}

\begin{center}
Table 8.6. Operations of the class std::ranges::owning\_view<>
\end{center}

\mySubsubsection{8.3.4}{通用视图}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Type:}     & std::ranges::common\_view\textless{}\textgreater{}                \\ \hline
\endfirsthead
%
\endhead
%
\textbf{Content:}  & All elements of a range with harmonized iterator types            \\ \hline
\textbf{Adaptor:}              & std::views::common()        \\ \hline
\textbf{Element type:}         & Same type a as passed range \\ \hline
\textbf{Requires:} & Non-common at least forward range (adaptor accepts common ranges) \\ \hline
\textbf{Category:} & Usually forward(contiguous if on a sized contiguous range)        \\ \hline
\textbf{Is sized range:}       & If on sized range           \\ \hline
\textbf{Is common range:}      & Always                      \\ \hline
\textbf{Is borrowed ranges:}   & If on borrowed range        \\ \hline
\textbf{Caches:}               & Nothing                     \\ \hline
\textbf{Const iterable:}       & If on const-iterable range  \\ \hline
\textbf{Progagates constness:} & Only if on rvalue range     \\ \hline
\end{longtable}

The class template std::ranges::common\_view<> is a view that harmonizes the begin and end iterator types of a range to be able to pass them to code where the same iterator type is required (such as to constructors of containers or traditional algorithms).

Note that the constructor of the view requires that the passed range is not a common range (iterators have different types). For example:

\begin{cpp}
std::list<int> lst{1, 2, 3, 4, 5, 6, 7, 8, 9};

auto v1 = std::ranges::common_view{lst}; // ERROR: is already common

auto take5 = std::ranges::take_view{lst, 5}; // yields no common view
auto v2 = std::ranges::common_view{take5}; // OK
\end{cpp}

The corresponding range adaptor can also deal with ranges that already are common. Therefore, it is better to use the range adaptor std::views::common() to create a common view.

\mySamllsection{通用视图的范围适配器}

Common views can also (and usually should) be created with a range adaptor:

\begin{cpp}
std::views::common(rg)
\end{cpp}

std::views::common() creates a view that refers to rg as a common range. If rg is already common, it returns std::views::all(rg).

The examples above can therefore be made to always compile as follows:

\begin{cpp}
std::list<int> lst{1, 2, 3, 4, 5, 6, 7, 8, 9};

auto v1 = std::views::common(lst); // OK

auto take5 = std::ranges::take_view{lst, 5}; // yields no common view
auto v2 = std::views::common(take5); // v2 is common view
std::vector<int> coll{v2.begin(), v2.end()}; // OK
\end{cpp}

Note that by using the adaptor, it is not a compile-time error to create a common view from a range that is already common. This is the key reason to prefer the adaptor over directly initializing the view.

Here is a full example program for using common views:

\filename{ranges/commonview.cpp}

\begin{cpp}
#include <iostream>
#include <string>
#include <list>
#include <vector>
#include <ranges>

void print(std::ranges::input_range auto&& coll)
{
	for (const auto& elem : coll) {
		std::cout << elem << ' ';
	}
	std::cout << '\n';
}

int main()
{
	std::list<std::string> coll{"You're", "my", "best", "friend"};
	
	auto tv = coll | std::views::take(3);
	static_assert(!std::ranges::common_range<decltype(tv)>);
	// could not initialize a container by passing begin and end of the view
	
	std::ranges::common_view vCommon1{tv};
	static_assert(std::ranges::common_range<decltype(vCommon1)>);
	
	auto tvCommon = coll | std::views::take(3) | std::views::common;
	static_assert(std::ranges::common_range<decltype(tvCommon)>);
	
	std::vector<std::string> coll2{tvCommon.begin(), tvCommon.end()}; // OK
	print(coll);
	print(coll2);
}
\end{cpp}

Here, we first create a take view, which is not common if it is not a random-access range. Because it is not common, we cannot use it to initialize a container with its elements:

\begin{cpp}
std::vector<std::string> coll2{tv.begin(), tv.end()}; // ERROR: begin/end types differ
\end{cpp}

Using the common view, the initialization works fine. Use std::views::common() if you do not know whether the range you want to harmonize is already common.

The major use case of the common view is to pass ranges or views that have different types for the begin and end iterators to generic code that requires begin and end to have the same type. A typical example is to pass the begin and end of a range to a constructor of a container or to a traditional algorithm. For example:

\begin{cpp}
std::list<int> lst {1, 2, 3, 4, 5, 6, 7, 8, 9};

auto v1 = std::views::take(lst, 5); // Note: types of begin() and end() differ
std::vector<int> coll{v1.begin(), v1.end()}; // ERROR: containers require the same type

auto v2 = std::views::common(std::views::take(lst, 5)); // same type now
std::vector<int> coll{v2.begin(), v2.end()}; // OK
\end{cpp}

\mySamllsection{通用视图的接口}

Table Operations of the class std::ranges::common\_view<> lists the API of a common view.


% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{Operation}   & \textbf{Effect}                                                \\ \hline
\endfirsthead
%
\endhead
%
common\_view r\{\} & Creates a common\_view that refers to a default constrcted range                                   \\ \hline
common\_view r\{rg\} & Creates a common\_view that refers to range rg                 \\ \hline
r.begin()            & Yields the begin iterator                                      \\ \hline
r.end()              & Yields the sentinel(end iterator)                              \\ \hline
r.empty()            & Yields whether r is empty(available if the range supportes it) \\ \hline
if (r)               & true if r is not empty(available if empty() is defined)        \\ \hline
r.size()           & Yields the number of elements (available if it refers to a sized range)                            \\ \hline
r.front()            & Yields the first element(available if forwarding)              \\ \hline
r.back()             & Yields the last element(available if bidrectional and common)  \\ \hline
r{[}idx{]}           & Yields the n-th element(available if random access)            \\ \hline
r.data()           & Yields a raw pointer to the memory of the elements(available if elements are in contiguous memory) \\ \hline
r.base()             & Yields a reference to the range that r refers to               \\ \hline
\end{longtable}

\begin{center}
Table 8.7. Operations of the class std::ranges::common\_view<>
\end{center}

The default constructor is provided only if the iterator is default initializable. Internally, common\_view uses iterators of type std::common\_iterator.

